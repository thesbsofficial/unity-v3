------formdata-undici-021293909545
Content-Disposition: form-data; name="metadata"

{"main_module":"functionsWorker-0.24691087331005968.js"}
------formdata-undici-021293909545
Content-Disposition: form-data; name="functionsWorker-0.24691087331005968.js"; filename="functionsWorker-0.24691087331005968.js"
Content-Type: application/javascript+module

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// lib/security.js
function base64FromBytes(bytes) {
  const binString = Array.from(bytes, (byte) => String.fromCodePoint(byte)).join("");
  return btoa(binString);
}
function bytesFromBase64(base64) {
  const binString = atob(base64);
  return Uint8Array.from(binString, (char) => char.codePointAt(0));
}
function hexFromBytes(bytes) {
  return Array.from(bytes, (byte) => byte.toString(16).padStart(2, "0")).join("");
}
async function derivePbkdf2(password, salt, iterations = PBKDF2_ITERATIONS) {
  const encoder = new TextEncoder();
  const passwordKey = await crypto.subtle.importKey(
    "raw",
    encoder.encode(password),
    "PBKDF2",
    false,
    ["deriveBits"]
  );
  const derivedBits = await crypto.subtle.deriveBits(
    {
      name: "PBKDF2",
      salt,
      iterations,
      hash: "SHA-256"
    },
    passwordKey,
    256
    // 256-bit output
  );
  return new Uint8Array(derivedBits);
}
async function verifyPasswordPbkdf2(password, storedHash, storedSalt, iterations = PBKDF2_ITERATIONS) {
  const salt = bytesFromBase64(storedSalt);
  const derived = await derivePbkdf2(password, salt, iterations);
  const candidateHash = base64FromBytes(derived);
  return timingSafeEqualString(candidateHash, storedHash);
}
async function verifyPasswordAgainstUser(password, user) {
  const hashType = (user?.password_hash_type || "").toLowerCase();
  if (hashType.startsWith("pbkdf2")) {
    return await verifyPasswordPbkdf2(
      password,
      user.password_hash,
      user.password_salt,
      user.password_iterations || PBKDF2_ITERATIONS
    );
  }
  if (hashType === "bcrypt") {
    throw new Error("bcrypt verification must be handled by caller with bcryptjs library");
  }
  const legacyHash = await hashPasswordLegacy(password);
  return timingSafeEqualString(legacyHash, user.password_hash);
}
async function verifyPassword(password, user) {
  if (!user) return false;
  return verifyPasswordAgainstUser(password, user);
}
async function hashPasswordLegacy(password) {
  const encoder = new TextEncoder();
  const data = encoder.encode(password);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  return hexFromBytes(new Uint8Array(hashBuffer));
}
function timingSafeEqualString(a, b) {
  if (!a || !b) return false;
  if (a.length !== b.length) return false;
  let result = 0;
  for (let i = 0; i < a.length; i++) {
    result |= a.charCodeAt(i) ^ b.charCodeAt(i);
  }
  return result === 0;
}
async function hashToken(token) {
  const encoder = new TextEncoder();
  const data = encoder.encode(token);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  return hexFromBytes(new Uint8Array(hashBuffer));
}
function generateOrderNumber() {
  const randomBytes2 = crypto.getRandomValues(new Uint8Array(6));
  const part1 = hexFromBytes(randomBytes2.slice(0, 3)).toUpperCase();
  const part2 = hexFromBytes(randomBytes2.slice(3, 6)).toUpperCase();
  return `SBS-${part1}-${part2}`;
}
function base32Encode(bytes) {
  let bits = 0;
  let value = 0;
  let output = "";
  for (let i = 0; i < bytes.length; i++) {
    value = value << 8 | bytes[i];
    bits += 8;
    while (bits >= 5) {
      output += BASE32_ALPHABET[value >>> bits - 5 & 31];
      bits -= 5;
    }
  }
  if (bits > 0) {
    output += BASE32_ALPHABET[value << 5 - bits & 31];
  }
  while (output.length % 8 !== 0) {
    output += "=";
  }
  return output;
}
function generateTotpSecret() {
  const bytes = crypto.getRandomValues(new Uint8Array(20));
  return base32Encode(bytes).replace(/=+$/, "");
}
function generateRecoveryCodes(count = 8) {
  const codes = [];
  for (let i = 0; i < count; i++) {
    const bytes = crypto.getRandomValues(new Uint8Array(5));
    const code = Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("").toUpperCase();
    codes.push(code);
  }
  return codes;
}
var PBKDF2_ITERATIONS, BASE32_ALPHABET;
var init_security = __esm({
  "lib/security.js"() {
    init_functionsRoutes_0_5646645567038772();
    PBKDF2_ITERATIONS = 21e4;
    __name(base64FromBytes, "base64FromBytes");
    __name(bytesFromBase64, "bytesFromBase64");
    __name(hexFromBytes, "hexFromBytes");
    __name(derivePbkdf2, "derivePbkdf2");
    __name(verifyPasswordPbkdf2, "verifyPasswordPbkdf2");
    __name(verifyPasswordAgainstUser, "verifyPasswordAgainstUser");
    __name(verifyPassword, "verifyPassword");
    __name(hashPasswordLegacy, "hashPasswordLegacy");
    __name(timingSafeEqualString, "timingSafeEqualString");
    __name(hashToken, "hashToken");
    __name(generateOrderNumber, "generateOrderNumber");
    BASE32_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
    __name(base32Encode, "base32Encode");
    __name(generateTotpSecret, "generateTotpSecret");
    __name(generateRecoveryCodes, "generateRecoveryCodes");
  }
});

// lib/sessions.js
async function getSessionColumns(env) {
  const now = Date.now();
  if (cachedSessionColumns && now - cachedSessionColumnsFetchedAt < SESSION_SCHEMA_CACHE_TTL_MS) {
    return cachedSessionColumns;
  }
  try {
    const result = await env.DB.prepare(`PRAGMA table_info('sessions')`).all();
    cachedSessionColumns = new Set((result?.results || []).map((col) => col.name));
  } catch (error) {
    console.error("Failed to read sessions schema:", error);
    cachedSessionColumns = /* @__PURE__ */ new Set();
  }
  cachedSessionColumnsFetchedAt = now;
  return cachedSessionColumns;
}
function hasColumn(columns, name) {
  return columns?.has?.(name);
}
function buildSessionQuery(columns, predicate) {
  const selectParts = [
    "s.id AS session_id",
    "s.user_id"
  ];
  if (hasColumn(columns, "token")) {
    selectParts.push("s.token AS session_token");
  } else {
    selectParts.push("NULL AS session_token");
  }
  if (hasColumn(columns, "csrf_secret")) {
    selectParts.push("s.csrf_secret");
  } else {
    selectParts.push("NULL AS csrf_secret");
  }
  if (hasColumn(columns, "expires_at")) {
    selectParts.push("s.expires_at");
  } else {
    selectParts.push("NULL AS expires_at");
  }
  if (hasColumn(columns, "invalidated_at")) {
    selectParts.push("s.invalidated_at");
  } else {
    selectParts.push("NULL AS invalidated_at");
  }
  if (hasColumn(columns, "ip_address")) {
    selectParts.push("s.ip_address");
  } else {
    selectParts.push("NULL AS ip_address");
  }
  if (hasColumn(columns, "user_agent")) {
    selectParts.push("s.user_agent");
  } else {
    selectParts.push("NULL AS user_agent");
  }
  if (hasColumn(columns, "last_seen_at")) {
    selectParts.push("s.last_seen_at");
  } else {
    selectParts.push("NULL AS last_seen_at");
  }
  const selectSql = `SELECT ${selectParts.join(", ")} FROM sessions s`;
  const whereParts = [];
  if (hasColumn(columns, "expires_at")) {
    whereParts.push(`s.expires_at > datetime('now')`);
  }
  if (hasColumn(columns, "invalidated_at")) {
    whereParts.push('(s.invalidated_at IS NULL OR s.invalidated_at = "")');
  }
  whereParts.push(predicate);
  const whereSql = `WHERE ${whereParts.join(" AND ")}`;
  const orderSql = hasColumn(columns, "created_at") ? " ORDER BY s.created_at DESC" : "";
  return `${selectSql} ${whereSql}${orderSql} LIMIT 1`;
}
async function validateSession(env, token) {
  if (!token) return null;
  const columns = await getSessionColumns(env);
  let sessionRow = null;
  if (hasColumn(columns, "token_hash")) {
    try {
      const query = buildSessionQuery(columns, "s.token_hash = ?");
      const hashedToken = await hashToken(token);
      sessionRow = await env.DB.prepare(query).bind(hashedToken).first();
    } catch (error) {
      console.error("Hashed session lookup failed:", error);
    }
  }
  if (!sessionRow && hasColumn(columns, "token")) {
    try {
      const query = buildSessionQuery(columns, "s.token = ?");
      sessionRow = await env.DB.prepare(query).bind(token).first();
    } catch (error) {
      console.error("Plain session lookup failed:", error);
    }
  }
  if (!sessionRow) return null;
  const user = await env.DB.prepare(`SELECT * FROM users WHERE id = ?`).bind(sessionRow.user_id).first();
  if (!user) return null;
  let allowlisted = null;
  try {
    const allowRow = await env.DB.prepare(`SELECT user_id FROM admin_allowlist WHERE user_id = ?`).bind(sessionRow.user_id).first();
    allowlisted = allowRow?.user_id ?? null;
  } catch (error) {
    allowlisted = null;
  }
  if (sessionRow.locked_until) {
    const lockedUntil = new Date(sessionRow.locked_until);
    if (!Number.isNaN(lockedUntil.getTime()) && lockedUntil > /* @__PURE__ */ new Date()) {
      return null;
    }
  }
  if (hasColumn(columns, "last_seen_at")) {
    try {
      await env.DB.prepare(`
                UPDATE sessions
                SET last_seen_at = CURRENT_TIMESTAMP
                WHERE id = ?
            `).bind(sessionRow.session_id).run();
    } catch (error) {
      console.warn("Unable to update last_seen_at:", error);
    }
  }
  const sessionData = {
    session_id: sessionRow.session_id,
    user_id: sessionRow.user_id,
    csrf_secret: sessionRow.csrf_secret || sessionRow.session_token || token,
    expires_at: sessionRow.expires_at || null,
    invalidated_at: sessionRow.invalidated_at || null,
    ip_address: sessionRow.ip_address || null,
    user_agent: sessionRow.user_agent || null,
    last_seen_at: sessionRow.last_seen_at || null,
    social_handle: user.social_handle || user.username || user.instagram_handle || null,
    email: user.email || null,
    phone: user.phone || user.contact_phone || null,
    instagram: user.instagram || user.instagram_handle || null,
    snapchat: user.snapchat || user.snapchat_handle || null,
    preferred_contact: user.preferred_contact || user.preferred_contact_method || "email",
    first_name: user.first_name || null,
    last_name: user.last_name || null,
    role: user.role || (user.is_admin ? "admin" : "customer"),
    totp_secret: user.totp_secret || null,
    email_verified_at: user.email_verified_at || (user.email_verified === 1 ? user.updated_at : null) || null,
    email_verification_required: user.email_verification_required ?? null,
    locked_until: user.locked_until || null,
    is_allowlisted: allowlisted
  };
  return sessionData;
}
function parseCookies(cookieHeader) {
  if (!cookieHeader) return {};
  return cookieHeader.split(";").reduce((cookies, cookie) => {
    const [name, ...rest] = cookie.trim().split("=");
    if (name) {
      cookies[name] = rest.join("=");
    }
    return cookies;
  }, {});
}
function extractSessionToken(request) {
  const cookieHeader = request.headers.get("Cookie");
  const cookies = parseCookies(cookieHeader);
  return cookies[SESSION_COOKIE_NAME] || null;
}
var cachedSessionColumns, cachedSessionColumnsFetchedAt, SESSION_SCHEMA_CACHE_TTL_MS, SESSION_COOKIE_NAME, SESSION_TTL_SECONDS;
var init_sessions = __esm({
  "lib/sessions.js"() {
    init_functionsRoutes_0_5646645567038772();
    init_security();
    cachedSessionColumns = null;
    cachedSessionColumnsFetchedAt = 0;
    SESSION_SCHEMA_CACHE_TTL_MS = 5 * 60 * 1e3;
    __name(getSessionColumns, "getSessionColumns");
    __name(hasColumn, "hasColumn");
    __name(buildSessionQuery, "buildSessionQuery");
    SESSION_COOKIE_NAME = "sbs_session";
    SESSION_TTL_SECONDS = 30 * 24 * 60 * 60;
    __name(validateSession, "validateSession");
    __name(parseCookies, "parseCookies");
    __name(extractSessionToken, "extractSessionToken");
  }
});

// lib/admin.js
var admin_exports = {};
__export(admin_exports, {
  ADMIN_CONSTANTS: () => ADMIN_CONSTANTS,
  generateAdminMenuHTML: () => generateAdminMenuHTML,
  isAdminSession: () => isAdminSession,
  logAdminAction: () => logAdminAction,
  promoteToAdmin: () => promoteToAdmin,
  runAdminDiagnostics: () => runAdminDiagnostics,
  setupTotpForAdmin: () => setupTotpForAdmin,
  shouldElevateToAdmin: () => shouldElevateToAdmin,
  verifyAdminAuth: () => verifyAdminAuth
});
function isAdminSession(session) {
  return session?.role === "admin" && (session?.is_allowlisted === 1 || !!session?.is_allowlisted);
}
async function verifyAdminAuth(request, env) {
  let token = null;
  const authHeader = request.headers.get("Authorization");
  if (authHeader && authHeader.startsWith("Bearer ")) {
    token = authHeader.substring(7);
  } else {
    token = extractSessionToken(request);
  }
  if (!token) return null;
  const baseSelect = `
        SELECT 
            s.user_id, s.csrf_secret, s.expires_at, s.invalidated_at,
            u.email, u.role, u.first_name, u.last_name, u.social_handle,
            al.user_id AS is_allowlisted
        FROM sessions s
        JOIN users u ON s.user_id = u.id
        LEFT JOIN admin_allowlist al ON al.user_id = u.id
        WHERE s.expires_at > datetime('now')
          AND (s.invalidated_at IS NULL OR s.invalidated_at IS NULL)
          AND u.role = 'admin'
    `;
  try {
    const tokenHash = await hashToken(token);
    const byHash = await env.DB.prepare(`${baseSelect} AND s.token_hash = ?`).bind(tokenHash).first();
    if (byHash) return byHash;
  } catch (e1) {
  }
  try {
    const byPlain = await env.DB.prepare(`${baseSelect} AND s.token = ?`).bind(token).first();
    if (byPlain) return byPlain;
  } catch (e2) {
  }
  return null;
}
function shouldElevateToAdmin(env, socialHandle) {
  const allowlistHandles = env.ADMIN_ALLOWLIST_HANDLES?.split(",").map((h) => h.trim().toLowerCase().replace(/^@/, "")).filter(Boolean) || [];
  const normalized = socialHandle.toLowerCase().replace(/^@/, "");
  return allowlistHandles.includes(normalized);
}
async function promoteToAdmin(env, userId) {
  await env.DB.prepare(`
        UPDATE users
        SET role = 'admin'
        WHERE id = ?
    `).bind(userId).run();
  await env.DB.prepare(`
        INSERT OR IGNORE INTO admin_allowlist (user_id, notes)
        VALUES (?, 'Auto-promoted via ADMIN_ALLOWLIST_HANDLES')
    `).bind(userId).run();
}
async function logAdminAction(env, session, action, resource = null, metadata = null, ipAddress = null) {
  if (!session?.user_id) return;
  const metaJson = metadata ? JSON.stringify(metadata) : null;
  try {
    await env.DB.prepare(`
            INSERT INTO admin_audit_logs (
                user_id,
                action,
                resource,
                metadata_json,
                ip_address
            ) VALUES (?, ?, ?, ?, ?)
        `).bind(
      session.user_id,
      action,
      resource,
      metaJson,
      ipAddress
    ).run();
    return;
  } catch (e1) {
    try {
      await env.DB.prepare(`
                INSERT INTO admin_audit_logs (
                    admin_id,
                    user_id,
                    action,
                    resource,
                    metadata,
                    metadata_json,
                    ip_address,
                    user_agent
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            `).bind(
        session.user_id,
        session.user_id,
        action,
        resource,
        metaJson,
        metaJson,
        ipAddress,
        session.user_agent || null
      ).run();
    } catch (e2) {
      console.error("Audit log insert failed (both schemas):", e1, e2);
    }
  }
}
function generateAdminMenuHTML() {
  return `
<section class="admin-menu" style="background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%); padding: 1.5rem; border-radius: 12px; margin-bottom: 2rem; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
    <h2 style="color: #000; margin: 0 0 1rem 0; font-size: 1.5rem; font-weight: 700;">\u{1F6E1}\uFE0F Admin Controls</h2>
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
        <button id="runBoard07" type="button" style="background: #000; color: #FFD700; border: 2px solid #FFD700; padding: 0.75rem 1.5rem; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.3s ease;">
            \u{1F50D} Run Diagnostics (Board-07)
        </button>
        <button id="setupTOTP" type="button" style="background: #000; color: #FFD700; border: 2px solid #FFD700; padding: 0.75rem 1.5rem; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.3s ease;">
            \u{1F510} Setup 2FA/TOTP
        </button>
        <button id="viewAuditLogs" type="button" style="background: #000; color: #FFD700; border: 2px solid #FFD700; padding: 0.75rem 1.5rem; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.3s ease;">
            \u{1F4CB} View Audit Logs
        </button>
    </div>
</section>
    `.trim();
}
async function setupTotpForAdmin(env, session) {
  const existingUser = await env.DB.prepare(`
        SELECT totp_secret FROM users WHERE id = ?
    `).bind(session.user_id).first();
  if (existingUser?.totp_secret) {
    throw new Error("TOTP is already configured for this account");
  }
  const secret = generateTotpSecret();
  const recoveryCodes = generateRecoveryCodes(8);
  await env.DB.prepare(`
        UPDATE users
        SET totp_secret = ?, totp_recovery_codes = ?
        WHERE id = ?
    `).bind(
    secret,
    JSON.stringify(recoveryCodes),
    session.user_id
  ).run();
  const identifier = encodeURIComponent(
    session.email || session.social_handle || `user-${session.user_id}`
  );
  const issuer = encodeURIComponent("SBS Unity");
  const otpauthUrl = `otpauth://totp/${issuer}:${identifier}?secret=${secret}&issuer=${issuer}&algorithm=SHA256&digits=6&period=30`;
  return {
    secret,
    recovery_codes: recoveryCodes,
    otpauth_url: otpauthUrl
  };
}
async function runAdminDiagnostics(env) {
  const checks = [];
  try {
    const tables = await env.DB.prepare(`
            SELECT name FROM sqlite_master
            WHERE type='table'
            ORDER BY name
        `).all();
    const tableNames = tables.results.map((t) => t.name);
    const requiredTables = [
      "users",
      "sessions",
      "orders",
      "admin_allowlist",
      "admin_audit_logs",
      "password_reset_tokens",
      "email_verification_tokens"
    ];
    const missingTables = requiredTables.filter((t) => !tableNames.includes(t));
    checks.push({
      name: "tables_present",
      passed: missingTables.length === 0,
      details: tableNames,
      missing: missingTables
    });
  } catch (error) {
    checks.push({
      name: "tables_present",
      passed: false,
      error: error.message
    });
  }
  try {
    const userColumns = await env.DB.prepare(`
            PRAGMA table_info('users')
        `).all();
    const columnNames = userColumns.results.map((c) => c.name);
    const requiredColumns = [
      "id",
      "social_handle",
      "email",
      "password_hash",
      "role",
      "password_salt",
      "password_hash_type",
      "totp_secret",
      "email_verified_at",
      "locked_until"
    ];
    const missingColumns = requiredColumns.filter((c) => !columnNames.includes(c));
    checks.push({
      name: "users_columns",
      passed: missingColumns.length === 0,
      total_columns: columnNames.length,
      missing: missingColumns
    });
  } catch (error) {
    checks.push({
      name: "users_columns",
      passed: false,
      error: error.message
    });
  }
  try {
    const sessionColumns = await env.DB.prepare(`
            PRAGMA table_info('sessions')
        `).all();
    const columnNames = sessionColumns.results.map((c) => c.name);
    const requiredColumns = [
      "id",
      "user_id",
      "token_hash",
      "csrf_secret",
      "expires_at",
      "invalidated_at",
      "ip_address",
      "user_agent"
    ];
    const missingColumns = requiredColumns.filter((c) => !columnNames.includes(c));
    checks.push({
      name: "sessions_columns",
      passed: missingColumns.length === 0,
      total_columns: columnNames.length,
      missing: missingColumns
    });
  } catch (error) {
    checks.push({
      name: "sessions_columns",
      passed: false,
      error: error.message
    });
  }
  try {
    const allowlistCount = await env.DB.prepare(`
            SELECT COUNT(*) as total FROM admin_allowlist
        `).first();
    checks.push({
      name: "admin_allowlist",
      passed: true,
      total: allowlistCount.total
    });
  } catch (error) {
    checks.push({
      name: "admin_allowlist",
      passed: false,
      error: error.message
    });
  }
  try {
    const auditCount = await env.DB.prepare(`
            SELECT COUNT(*) as total
            FROM admin_audit_logs
            WHERE created_at > datetime('now', '-1 day')
        `).first();
    checks.push({
      name: "audit_logs_24h",
      passed: true,
      total: auditCount.total
    });
  } catch (error) {
    checks.push({
      name: "audit_logs_24h",
      passed: false,
      error: error.message
    });
  }
  try {
    const sessionCount = await env.DB.prepare(`
            SELECT COUNT(*) as total
            FROM sessions
            WHERE expires_at > datetime('now')
                AND invalidated_at IS NULL
        `).first();
    checks.push({
      name: "active_sessions",
      passed: true,
      total: sessionCount.total
    });
  } catch (error) {
    checks.push({
      name: "active_sessions",
      passed: false,
      error: error.message
    });
  }
  const envVars = {
    ADMIN_ALLOWLIST_HANDLES: !!env.ADMIN_ALLOWLIST_HANDLES,
    ALLOWED_ORIGINS: !!env.ALLOWED_ORIGINS,
    NODE_ENV: !!env.NODE_ENV,
    DB: !!env.DB
  };
  checks.push({
    name: "environment_variables",
    passed: envVars.DB && envVars.ADMIN_ALLOWLIST_HANDLES,
    details: envVars
  });
  return checks;
}
var ADMIN_CONSTANTS;
var init_admin = __esm({
  "lib/admin.js"() {
    init_functionsRoutes_0_5646645567038772();
    init_security();
    init_sessions();
    __name(isAdminSession, "isAdminSession");
    __name(verifyAdminAuth, "verifyAdminAuth");
    __name(shouldElevateToAdmin, "shouldElevateToAdmin");
    __name(promoteToAdmin, "promoteToAdmin");
    __name(logAdminAction, "logAdminAction");
    __name(generateAdminMenuHTML, "generateAdminMenuHTML");
    __name(setupTotpForAdmin, "setupTotpForAdmin");
    __name(runAdminDiagnostics, "runAdminDiagnostics");
    ADMIN_CONSTANTS = {
      ADMIN_ACTIONS: {
        MENU_VIEW: "admin_menu_view",
        BOARD07: "admin_board07",
        TOTP_SETUP: "admin_totp_setup",
        AUDIT_LOGS_VIEW: "admin_audit_logs_view"
      }
    };
  }
});

// api/admin/activity.js
function jsonResponse(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization"
    }
  });
}
async function onRequestGet(context) {
  const { request, env } = context;
  const url = new URL(request.url);
  try {
    const session = await verifyAdminAuth(request, env);
    if (!session) {
      return jsonResponse({
        success: false,
        error: "Unauthorized - Admin access required"
      }, 401);
    }
    if (url.pathname.endsWith("/activity")) {
      return await handleGetActivity(context, session);
    } else if (url.pathname.endsWith("/stats")) {
      return await handleGetStats(context, session);
    }
    return jsonResponse({ error: "Endpoint not found" }, 404);
  } catch (error) {
    console.error("\u274C Admin activity/stats error:", error);
    return jsonResponse({
      success: false,
      error: "Failed to fetch data",
      details: error.message
    }, 500);
  }
}
async function handleGetActivity(context, session) {
  const { env } = context;
  const url = new URL(context.request.url);
  const limit = parseInt(url.searchParams.get("limit")) || 50;
  try {
    await logAdminAction(env, session, "admin_activity_view");
    const auditLogs = await env.DB.prepare(`
            SELECT
                aal.id,
                aal.action,
                aal.resource,
                aal.metadata_json,
                aal.ip_address,
                aal.created_at,
                u.email as admin_email,
                u.first_name,
                u.last_name
            FROM admin_audit_logs aal
            JOIN users u ON aal.user_id = u.id
            ORDER BY aal.created_at DESC
            LIMIT ?
        `).bind(limit).all();
    const recentOrders = await env.DB.prepare(`
            SELECT
                id,
                order_number,
                customer_name,
                total,
                status,
                created_at
            FROM orders
            ORDER BY created_at DESC
            LIMIT 10
        `).all();
    const recentUsers = await env.DB.prepare(`
            SELECT
                id,
                email,
                first_name,
                last_name,
                role,
                created_at
            FROM users
            WHERE role = 'customer'
            ORDER BY created_at DESC
            LIMIT 10
        `).all();
    const recentSubmissions = await env.DB.prepare(`
            SELECT
                id,
                batch_id,
                contact_name,
                item_count,
                status,
                created_at
            FROM sell_submissions
            ORDER BY created_at DESC
            LIMIT 10
        `).all();
    return jsonResponse({
      success: true,
      data: {
        admin_actions: auditLogs.results || [],
        recent_orders: recentOrders.results || [],
        recent_users: recentUsers.results || [],
        recent_submissions: recentSubmissions.results || [],
        generated_at: (/* @__PURE__ */ new Date()).toISOString(),
        generated_by: session.email
      }
    });
  } catch (error) {
    console.error("\u274C Error fetching admin activity:", error);
    throw error;
  }
}
async function handleGetStats(context, session) {
  const { env } = context;
  const url = new URL(context.request.url);
  const period = url.searchParams.get("period") || "7d";
  try {
    await logAdminAction(env, session, "admin_stats_view", null, { period });
    const days = period === "24h" ? 1 : period === "7d" ? 7 : period === "30d" ? 30 : 9999;
    const dateFilter = period !== "all" ? `WHERE DATE(created_at) >= DATE('now', '-${days} days')` : "";
    const userStats = await env.DB.prepare(`
            SELECT
                COUNT(*) as total_users,
                COUNT(CASE WHEN role = 'customer' THEN 1 END) as customers,
                COUNT(CASE WHEN role = 'admin' THEN 1 END) as admins,
                COUNT(CASE WHEN is_verified = 1 THEN 1 END) as verified_users,
                COUNT(CASE WHEN DATE(created_at) >= DATE('now', '-${days} days') THEN 1 END) as new_users_period
            FROM users
        `).first();
    const orderStats = await env.DB.prepare(`
            SELECT
                COUNT(*) as total_orders,
                COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_orders,
                COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_orders,
                SUM(CASE WHEN status = 'completed' THEN total ELSE 0 END) as total_revenue,
                AVG(CASE WHEN status = 'completed' THEN total ELSE NULL END) as avg_order_value,
                COUNT(CASE WHEN DATE(created_at) >= DATE('now', '-${days} days') THEN 1 END) as orders_period
            FROM orders
        `).first();
    const productStats = await env.DB.prepare(`
            SELECT
                COUNT(*) as total_products,
                COUNT(CASE WHEN status = 'available' THEN 1 END) as available_products,
                COUNT(CASE WHEN status = 'sold' THEN 1 END) as sold_products,
                COUNT(CASE WHEN featured = 1 THEN 1 END) as featured_products,
                COUNT(CASE WHEN DATE(created_at) >= DATE('now', '-${days} days') THEN 1 END) as products_added_period
            FROM products
        `).first();
    const submissionStats = await env.DB.prepare(`
            SELECT
                COUNT(*) as total_submissions,
                COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_submissions,
                COUNT(CASE WHEN status = 'approved' THEN 1 END) as approved_submissions,
                COUNT(CASE WHEN status = 'rejected' THEN 1 END) as rejected_submissions,
                SUM(item_count) as total_items_submitted,
                COUNT(CASE WHEN DATE(created_at) >= DATE('now', '-${days} days') THEN 1 END) as submissions_period
            FROM sell_submissions
        `).first();
    const sessionStats = await env.DB.prepare(`
            SELECT
                COUNT(*) as active_sessions,
                COUNT(DISTINCT user_id) as active_users,
                COUNT(CASE WHEN DATE(created_at) >= DATE('now', '-1 days') THEN 1 END) as sessions_24h
            FROM sessions
            WHERE expires_at > datetime('now')
        `).first();
    const topCategories = await env.DB.prepare(`
            SELECT
                category,
                COUNT(*) as product_count,
                COUNT(CASE WHEN status = 'sold' THEN 1 END) as sold_count
            FROM products
            GROUP BY category
            ORDER BY product_count DESC
            LIMIT 10
        `).all();
    const dailyStats = await env.DB.prepare(`
            SELECT
                DATE(created_at) as date,
                COUNT(CASE WHEN table_type = 'orders' THEN 1 END) as orders,
                COUNT(CASE WHEN table_type = 'users' THEN 1 END) as users,
                COUNT(CASE WHEN table_type = 'products' THEN 1 END) as products
            FROM (
                SELECT created_at, 'orders' as table_type FROM orders
                UNION ALL
                SELECT created_at, 'users' as table_type FROM users WHERE role = 'customer'
                UNION ALL
                SELECT created_at, 'products' as table_type FROM products
            )
            WHERE DATE(created_at) >= DATE('now', '-7 days')
            GROUP BY DATE(created_at)
            ORDER BY date DESC
        `).all();
    return jsonResponse({
      success: true,
      period,
      data: {
        users: userStats,
        orders: orderStats,
        products: productStats,
        submissions: submissionStats,
        sessions: sessionStats,
        top_categories: topCategories.results || [],
        daily_trends: dailyStats.results || [],
        generated_at: (/* @__PURE__ */ new Date()).toISOString(),
        generated_by: session.email
      }
    });
  } catch (error) {
    console.error("\u274C Error fetching admin stats:", error);
    throw error;
  }
}
async function onRequestOptions(context) {
  return jsonResponse(null, 204);
}
var init_activity = __esm({
  "api/admin/activity.js"() {
    init_functionsRoutes_0_5646645567038772();
    init_admin();
    __name(jsonResponse, "jsonResponse");
    __name(onRequestGet, "onRequestGet");
    __name(handleGetActivity, "handleGetActivity");
    __name(handleGetStats, "handleGetStats");
    __name(onRequestOptions, "onRequestOptions");
  }
});

// api/admin/analytics.js
async function onRequestGet2(context) {
  const { request, env } = context;
  const url = new URL(request.url);
  const period = url.searchParams.get("period") || "7d";
  try {
    const authHeader = request.headers.get("Authorization");
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return jsonResponse2({ success: false, error: "Unauthorized" }, 401);
    }
    const token = authHeader.substring(7);
    const encoder = new TextEncoder();
    const data = encoder.encode(token);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const tokenHash = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
    const session = await env.DB.prepare(`
            SELECT s.user_id, u.role, u.is_allowlisted
            FROM sessions s
            JOIN users u ON s.user_id = u.id
            WHERE s.token_hash = ? AND s.expires_at > datetime('now')
            AND u.role = 'admin' AND u.is_allowlisted = 1
        `).bind(tokenHash).first();
    if (!session) {
      return jsonResponse2({ success: false, error: "Invalid session or insufficient privileges" }, 401);
    }
    console.log(`\u{1F4CA} Fetching analytics for period: ${period}`);
    const days = period === "24h" ? 1 : period === "7d" ? 7 : period === "30d" ? 30 : 365;
    const summaries = await env.DB.prepare(`
            SELECT * FROM analytics_daily_summary
            WHERE date >= date('now', '-${days} days')
            ORDER BY date DESC
        `).all();
    const totals = await env.DB.prepare(`
            SELECT
                SUM(unique_visitors) as total_visitors,
                SUM(page_views) as total_page_views,
                SUM(orders_completed) as total_orders,
                SUM(revenue) as total_revenue,
                AVG(conversion_rate) as avg_conversion_rate,
                AVG(avg_order_value) as avg_order_value
            FROM analytics_daily_summary
            WHERE date >= date('now', '-${days} days')
        `).first();
    const topProducts = await env.DB.prepare(`
            SELECT
                product_id,
                product_name,
                category,
                brand,
                SUM(views) as total_views,
                SUM(cart_adds) as total_cart_adds,
                SUM(purchases) as total_purchases,
                SUM(revenue) as total_revenue,
                AVG(overall_conversion_rate) as avg_conversion_rate
            FROM analytics_product_performance
            WHERE date >= date('now', '-${days} days')
            GROUP BY product_id
            ORDER BY total_revenue DESC
            LIMIT 10
        `).all();
    const topSearches = await env.DB.prepare(`
            SELECT
                search_term,
                SUM(search_count) as total_searches,
                AVG(results_found) as avg_results,
                AVG(click_through_rate) as avg_ctr
            FROM analytics_searches
            WHERE date >= date('now', '-${days} days')
            GROUP BY search_term
            ORDER BY total_searches DESC
            LIMIT 10
        `).all();
    const today = await env.DB.prepare(`
            SELECT * FROM analytics_daily_summary
            WHERE date = date('now')
        `).first();
    const previousPeriod = await env.DB.prepare(`
            SELECT
                SUM(revenue) as prev_revenue,
                SUM(unique_visitors) as prev_visitors,
                SUM(orders_completed) as prev_orders
            FROM analytics_daily_summary
            WHERE date >= date('now', '-${days * 2} days')
            AND date < date('now', '-${days} days')
        `).first();
    const revenueGrowth = previousPeriod?.prev_revenue > 0 ? ((totals.total_revenue - previousPeriod.prev_revenue) / previousPeriod.prev_revenue * 100).toFixed(2) : 0;
    const visitorGrowth = previousPeriod?.prev_visitors > 0 ? ((totals.total_visitors - previousPeriod.prev_visitors) / previousPeriod.prev_visitors * 100).toFixed(2) : 0;
    return jsonResponse2({
      success: true,
      period,
      date_range: {
        start: new Date(Date.now() - days * 24 * 60 * 60 * 1e3).toISOString().split("T")[0],
        end: (/* @__PURE__ */ new Date()).toISOString().split("T")[0]
      },
      overview: {
        total_visitors: totals?.total_visitors || 0,
        total_page_views: totals?.total_page_views || 0,
        total_orders: totals?.total_orders || 0,
        total_revenue: parseFloat(totals?.total_revenue || 0).toFixed(2),
        avg_conversion_rate: parseFloat(totals?.avg_conversion_rate || 0).toFixed(2),
        avg_order_value: parseFloat(totals?.avg_order_value || 0).toFixed(2),
        revenue_growth: revenueGrowth,
        visitor_growth: visitorGrowth
      },
      today: today || {
        unique_visitors: 0,
        page_views: 0,
        orders_completed: 0,
        revenue: 0,
        conversion_rate: 0
      },
      daily_trend: summaries.results || [],
      top_products: topProducts.results || [],
      top_searches: topSearches.results || [],
      last_sync: summaries.results?.[0]?.synced_at || null
    });
  } catch (error) {
    console.error("\u274C Analytics fetch error:", error);
    return jsonResponse2({
      success: false,
      error: error.message
    }, 500);
  }
}
function jsonResponse2(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*"
    }
  });
}
var init_analytics = __esm({
  "api/admin/analytics.js"() {
    init_functionsRoutes_0_5646645567038772();
    __name(onRequestGet2, "onRequestGet");
    __name(jsonResponse2, "jsonResponse");
  }
});

// api/admin/auth.js
function jsonResponse3(data, status = 200, headers = {}) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization",
      ...headers
    }
  });
}
function generateSessionToken() {
  const array = new Uint8Array(32);
  crypto.getRandomValues(array);
  return Array.from(array, (byte) => byte.toString(16).padStart(2, "0")).join("");
}
async function hashToken2(token) {
  const encoder = new TextEncoder();
  const data = encoder.encode(token);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
}
async function onRequestGet3(context) {
  const { request, env } = context;
  const url = new URL(request.url);
  if (url.pathname.endsWith("/verify")) {
    return await handleVerifySession(context);
  }
  return jsonResponse3({ error: "Endpoint not found" }, 404);
}
async function onRequestPost(context) {
  const { request, env } = context;
  const url = new URL(request.url);
  if (url.pathname.endsWith("/login")) {
    return await handleLogin(context);
  } else if (url.pathname.endsWith("/logout")) {
    return await handleLogout(context);
  }
  return jsonResponse3({ error: "Endpoint not found" }, 404);
}
async function handleLogin(context) {
  const { request, env } = context;
  try {
    const body = await request.json();
    const { email, password } = body;
    if (!email || !password) {
      return jsonResponse3({
        success: false,
        error: "Email and password are required"
      }, 400);
    }
    console.log(`\u{1F510} Admin login attempt for: ${email}`);
    const user = await env.DB.prepare(`
            SELECT id, email, password_hash, password_salt, password_hash_type,
                   password_iterations, role, is_allowlisted, first_name, last_name
            FROM users
            WHERE email = ? AND role = 'admin'
        `).bind(email).first();
    if (!user) {
      console.log(`\u274C Admin user not found: ${email}`);
      return jsonResponse3({
        success: false,
        error: "Invalid credentials"
      }, 401);
    }
    const isValidPassword = await verifyPassword(password, user);
    if (!isValidPassword) {
      console.log(`\u274C Invalid password for admin: ${email}`);
      return jsonResponse3({
        success: false,
        error: "Invalid credentials"
      }, 401);
    }
    if (!user.is_allowlisted) {
      console.log(`\u274C Admin not allowlisted: ${email}`);
      return jsonResponse3({
        success: false,
        error: "Access denied. Contact system administrator."
      }, 403);
    }
    const sessionToken = generateSessionToken();
    const tokenHash = await hashToken2(sessionToken);
    const expiresAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3).toISOString();
    const clientIP = request.headers.get("CF-Connecting-IP") || request.headers.get("X-Forwarded-For") || "unknown";
    const userAgent = request.headers.get("User-Agent") || "unknown";
    await env.DB.prepare(`
            INSERT INTO sessions (user_id, token_hash, csrf_secret, expires_at, ip_address, user_agent)
            VALUES (?, ?, ?, ?, ?, ?)
        `).bind(
      user.id,
      tokenHash,
      generateSessionToken(),
      // CSRF secret
      expiresAt,
      clientIP,
      userAgent
    ).run();
    await env.DB.prepare(`
            INSERT INTO session_tokens (token_hash, user_id, expires_at)
            VALUES (?, ?, ?)
        `).bind(tokenHash, user.id, expiresAt).run();
    const mockSession = { user_id: user.id, role: "admin", is_allowlisted: 1 };
    await logAdminAction(env, mockSession, "admin_login", null, {
      email: user.email,
      ip_address: clientIP,
      user_agent: userAgent
    });
    console.log(`\u2705 Admin login successful: ${email}`);
    return jsonResponse3({
      success: true,
      message: "Login successful",
      token: sessionToken,
      user: {
        id: user.id,
        email: user.email,
        role: user.role,
        name: `${user.first_name || ""} ${user.last_name || ""}`.trim() || "Admin"
      },
      expires_at: expiresAt
    });
  } catch (error) {
    console.error("\u274C Admin login error:", error);
    return jsonResponse3({
      success: false,
      error: "Login failed",
      details: error.message
    }, 500);
  }
}
async function handleLogout(context) {
  const { request, env } = context;
  try {
    const authHeader = request.headers.get("Authorization");
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return jsonResponse3({
        success: false,
        error: "No session token provided"
      }, 400);
    }
    const token = authHeader.substring(7);
    const tokenHash = await hashToken2(token);
    const session = await env.DB.prepare(`
            SELECT s.user_id, u.email, u.role
            FROM sessions s
            JOIN users u ON s.user_id = u.id
            WHERE s.token_hash = ? AND s.expires_at > datetime('now')
        `).bind(tokenHash).first();
    await env.DB.prepare(`
            DELETE FROM sessions WHERE token_hash = ?
        `).bind(tokenHash).run();
    await env.DB.prepare(`
            DELETE FROM session_tokens WHERE token_hash = ?
        `).bind(tokenHash).run();
    if (session) {
      const mockSession = { user_id: session.user_id, role: session.role, is_allowlisted: 1 };
      await logAdminAction(env, mockSession, "admin_logout", null, {
        email: session.email
      });
      console.log(`\u2705 Admin logout successful: ${session.email}`);
    }
    return jsonResponse3({
      success: true,
      message: "Logout successful"
    });
  } catch (error) {
    console.error("\u274C Admin logout error:", error);
    return jsonResponse3({
      success: false,
      error: "Logout failed",
      details: error.message
    }, 500);
  }
}
async function handleVerifySession(context) {
  const { request, env } = context;
  try {
    const authHeader = request.headers.get("Authorization");
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return jsonResponse3({
        success: false,
        error: "No session token provided"
      }, 401);
    }
    const token = authHeader.substring(7);
    const tokenHash = await hashToken2(token);
    const session = await env.DB.prepare(`
            SELECT s.user_id, s.csrf_secret, s.expires_at, s.ip_address,
                   u.email, u.role, u.is_allowlisted, u.first_name, u.last_name
            FROM sessions s
            JOIN users u ON s.user_id = u.id
            WHERE s.token_hash = ? AND s.expires_at > datetime('now')
        `).bind(tokenHash).first();
    if (!session) {
      return jsonResponse3({
        success: false,
        error: "Invalid or expired session"
      }, 401);
    }
    if (!isAdminSession(session)) {
      return jsonResponse3({
        success: false,
        error: "Access denied. Admin privileges required."
      }, 403);
    }
    await env.DB.prepare(`
            UPDATE sessions
            SET updated_at = datetime('now')
            WHERE token_hash = ?
        `).bind(tokenHash).run();
    return jsonResponse3({
      success: true,
      message: "Session valid",
      user: {
        id: session.user_id,
        email: session.email,
        role: session.role,
        name: `${session.first_name || ""} ${session.last_name || ""}`.trim() || "Admin"
      },
      session: {
        expires_at: session.expires_at,
        csrf_secret: session.csrf_secret
      }
    });
  } catch (error) {
    console.error("\u274C Admin session verification error:", error);
    return jsonResponse3({
      success: false,
      error: "Session verification failed",
      details: error.message
    }, 500);
  }
}
async function onRequestOptions2(context) {
  return jsonResponse3(null, 204);
}
var init_auth = __esm({
  "api/admin/auth.js"() {
    init_functionsRoutes_0_5646645567038772();
    init_security();
    init_admin();
    __name(jsonResponse3, "jsonResponse");
    __name(generateSessionToken, "generateSessionToken");
    __name(hashToken2, "hashToken");
    __name(onRequestGet3, "onRequestGet");
    __name(onRequestPost, "onRequestPost");
    __name(handleLogin, "handleLogin");
    __name(handleLogout, "handleLogout");
    __name(handleVerifySession, "handleVerifySession");
    __name(onRequestOptions2, "onRequestOptions");
  }
});

// api/admin/delete-image.js
async function sha256b64(text) {
  const encoder = new TextEncoder();
  const data = encoder.encode(text);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = new Uint8Array(hashBuffer);
  return btoa(String.fromCharCode(...hashArray));
}
async function onRequestDelete({ request, env }) {
  const cookie = request.headers.get("Cookie") || "";
  const sessionId = cookie.split("sbs_session=")[1]?.split(";")[0];
  if (!sessionId) {
    return new Response(JSON.stringify({
      success: false,
      error: "Not authenticated"
    }), {
      status: 401,
      headers: { "Content-Type": "application/json" }
    });
  }
  try {
    const sessionHash = await sha256b64(sessionId);
    const sessionResult = await env.DB.prepare(
      "SELECT user_id, expires_at FROM sessions WHERE token = ? AND invalidated_at IS NULL"
    ).bind(sessionHash).first();
    if (!sessionResult) {
      return new Response(JSON.stringify({
        success: false,
        error: "Session not found. Please log in again."
      }), {
        status: 401,
        headers: { "Content-Type": "application/json" }
      });
    }
    const now = (/* @__PURE__ */ new Date()).toISOString();
    if (sessionResult.expires_at < now) {
      return new Response(JSON.stringify({
        success: false,
        error: "Session expired. Please log in again."
      }), {
        status: 401,
        headers: { "Content-Type": "application/json" }
      });
    }
    const userResult = await env.DB.prepare(
      "SELECT role FROM users WHERE id = ?"
    ).bind(sessionResult.user_id).first();
    if (!userResult || userResult.role !== "admin") {
      return new Response(JSON.stringify({
        success: false,
        error: "Admin access required"
      }), {
        status: 403,
        headers: { "Content-Type": "application/json" }
      });
    }
    const { imageId } = await request.json();
    if (!imageId) {
      return new Response(JSON.stringify({
        success: false,
        error: "Missing imageId"
      }), {
        status: 400,
        headers: { "Content-Type": "application/json" }
      });
    }
    const accountId = env.CLOUDFLARE_ACCOUNT_ID;
    const apiToken = env.CLOUDFLARE_IMAGES_API_TOKEN || env.CLOUDFLARE_API_TOKEN;
    if (!accountId || !apiToken) {
      return new Response(JSON.stringify({
        success: false,
        error: "Missing Cloudflare credentials"
      }), {
        status: 500,
        headers: { "Content-Type": "application/json" }
      });
    }
    const deleteUrl = `https://api.cloudflare.com/client/v4/accounts/${accountId}/images/v1/${imageId}`;
    const deleteResponse = await fetch(deleteUrl, {
      method: "DELETE",
      headers: {
        "Authorization": `Bearer ${apiToken}`
      }
    });
    const deleteResult = await deleteResponse.json();
    if (!deleteResponse.ok || !deleteResult.success) {
      console.error("CF Images delete failed:", deleteResult);
      return new Response(JSON.stringify({
        success: false,
        error: deleteResult.errors?.[0]?.message || "Failed to delete image"
      }), {
        status: deleteResponse.status,
        headers: { "Content-Type": "application/json" }
      });
    }
    return new Response(JSON.stringify({
      success: true,
      message: "Image deleted successfully",
      imageId
    }), {
      status: 200,
      headers: { "Content-Type": "application/json" }
    });
  } catch (error) {
    console.error("Delete image error:", error);
    return new Response(JSON.stringify({
      success: false,
      error: error.message || "Internal server error"
    }), {
      status: 500,
      headers: { "Content-Type": "application/json" }
    });
  }
}
var init_delete_image = __esm({
  "api/admin/delete-image.js"() {
    init_functionsRoutes_0_5646645567038772();
    __name(sha256b64, "sha256b64");
    __name(onRequestDelete, "onRequestDelete");
  }
});

// lib/notification-service.js
var NotificationService, notification_service_default;
var init_notification_service = __esm({
  "lib/notification-service.js"() {
    init_functionsRoutes_0_5646645567038772();
    NotificationService = class {
      static {
        __name(this, "NotificationService");
      }
      constructor(env) {
        this.env = env;
        this.resendApiKey = env.RESEND_API_KEY;
        this.siteUrl = env.SITE_URL || "https://thesbsofficial.com";
      }
      /**
       * Send order status update notification
       */
      async sendOrderStatusUpdate(order, newStatus) {
        if (!this.resendApiKey) {
          console.warn("\u{1F4E7} Email notifications disabled - RESEND_API_KEY not configured");
          return { success: false, reason: "email_not_configured" };
        }
        try {
          const statusMessages = {
            "pending": "We've received your order and it's being processed.",
            "confirmed": "Your order has been confirmed and is being prepared.",
            "processing": "Your order is currently being processed.",
            "shipped": "Great news! Your order has been shipped.",
            "delivered": "Your order has been delivered. Thank you for shopping with SBS!",
            "cancelled": "Your order has been cancelled. If you have questions, please contact us.",
            "ready": "Your order is ready for collection/delivery!"
          };
          const subject = `Order Update: ${order.order_number} - ${newStatus.charAt(0).toUpperCase() + newStatus.slice(1)}`;
          const message = statusMessages[newStatus] || `Your order status has been updated to: ${newStatus}`;
          const emailHtml = `
                <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 30px; text-align: center;">
                        <h1 style="color: white; margin: 0; font-size: 28px;">SBS</h1>
                        <p style="color: white; margin: 10px 0 0 0; opacity: 0.9;">Sneaker & Clothing Store</p>
                    </div>
                    
                    <div style="padding: 30px; background: white;">
                        <h2 style="color: #333; margin-top: 0;">Order Update</h2>
                        
                        <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                            <p style="margin: 0; font-weight: bold; color: #667eea;">Order #${order.order_number}</p>
                            <p style="margin: 5px 0 0 0; color: #666;">Status: <strong>${newStatus.charAt(0).toUpperCase() + newStatus.slice(1)}</strong></p>
                        </div>
                        
                        <p style="color: #333; line-height: 1.6;">${message}</p>
                        
                        ${newStatus === "shipped" ? `
                            <div style="background: #e8f5e8; padding: 15px; border-radius: 8px; margin: 20px 0;">
                                <p style="margin: 0; color: #2d5016;"><strong>\u{1F4E6} Shipping Information</strong></p>
                                <p style="margin: 5px 0 0 0; color: #2d5016;">Your order is on its way! You should receive it within 1-3 business days.</p>
                            </div>
                        ` : ""}
                        
                        <div style="text-align: center; margin: 30px 0;">
                            <a href="${this.siteUrl}/dashboard.html" 
                               style="background: #667eea; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;">
                                View Order Details
                            </a>
                        </div>
                        
                        <hr style="border: none; border-top: 1px solid #eee; margin: 30px 0;">
                        
                        <p style="color: #666; font-size: 14px; margin: 0;">
                            Questions? Reply to this email or contact us at <a href="mailto:support@thesbsofficial.com" style="color: #667eea;">support@thesbsofficial.com</a>
                        </p>
                    </div>
                    
                    <div style="background: #f8f9fa; padding: 20px; text-align: center; color: #666; font-size: 12px;">
                        <p style="margin: 0;">SBS - Sneaker & Clothing Store</p>
                        <p style="margin: 5px 0 0 0;">Dublin, Ireland</p>
                    </div>
                </div>
            `;
          const response = await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${this.resendApiKey}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              from: "SBS Store <orders@thesbsofficial.com>",
              to: [order.user_email || order.email],
              subject,
              html: emailHtml
            })
          });
          if (!response.ok) {
            const error = await response.text();
            console.error("\u{1F4E7} Email send failed:", error);
            return { success: false, reason: "email_send_failed", error };
          }
          console.log(`\u{1F4E7} Order notification sent to ${order.user_email || order.email}: ${newStatus}`);
          return { success: true, method: "email" };
        } catch (error) {
          console.error("\u{1F4E7} Notification error:", error);
          return { success: false, reason: "notification_error", error: error.message };
        }
      }
      /**
       * Send order confirmation email
       */
      async sendOrderConfirmation(order, orderItems) {
        if (!this.resendApiKey) {
          console.warn("\u{1F4E7} Email notifications disabled - RESEND_API_KEY not configured");
          return { success: false, reason: "email_not_configured" };
        }
        try {
          const itemsHtml = orderItems.map((item) => `
                <tr>
                    <td style="padding: 10px; border-bottom: 1px solid #eee;">
                        <div style="font-weight: bold;">${item.name}</div>
                        <div style="color: #666; font-size: 14px;">Size: ${item.size}</div>
                    </td>
                    <td style="padding: 10px; border-bottom: 1px solid #eee; text-align: center;">
                        ${item.quantity}
                    </td>
                    <td style="padding: 10px; border-bottom: 1px solid #eee; text-align: right;">
                        \u20AC${item.price}
                    </td>
                </tr>
            `).join("");
          const emailHtml = `
                <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 30px; text-align: center;">
                        <h1 style="color: white; margin: 0; font-size: 28px;">Order Confirmed! \u{1F389}</h1>
                        <p style="color: white; margin: 10px 0 0 0; opacity: 0.9;">Thank you for shopping with SBS</p>
                    </div>
                    
                    <div style="padding: 30px; background: white;">
                        <div style="background: #e8f5e8; padding: 20px; border-radius: 8px; margin-bottom: 30px;">
                            <h2 style="margin: 0 0 10px 0; color: #2d5016;">Order #${order.order_number}</h2>
                            <p style="margin: 0; color: #2d5016;">Your order has been confirmed and will be processed shortly.</p>
                        </div>
                        
                        <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                            <thead>
                                <tr style="background: #f8f9fa;">
                                    <th style="padding: 15px 10px; text-align: left; border-bottom: 2px solid #667eea;">Item</th>
                                    <th style="padding: 15px 10px; text-align: center; border-bottom: 2px solid #667eea;">Qty</th>
                                    <th style="padding: 15px 10px; text-align: right; border-bottom: 2px solid #667eea;">Price</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${itemsHtml}
                                <tr style="background: #f8f9fa; font-weight: bold;">
                                    <td style="padding: 15px 10px;" colspan="2">Total</td>
                                    <td style="padding: 15px 10px; text-align: right;">\u20AC${(() => {
            const value = Number(order.total ?? order.total_amount);
            return Number.isFinite(value) ? value.toFixed(2) : "TBD";
          })()}</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin: 20px 0;">
                            <p style="margin: 0; color: #856404;"><strong>\u{1F4CB} What's Next?</strong></p>
                            <p style="margin: 5px 0 0 0; color: #856404;">We'll prepare your order and send you updates. Typical processing time is 1-2 business days.</p>
                        </div>
                        
                        <div style="text-align: center; margin: 30px 0;">
                            <a href="${this.siteUrl}/dashboard.html" 
                               style="background: #667eea; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block; margin-right: 10px;">
                                Track Order
                            </a>
                            <a href="${this.siteUrl}/shop.html" 
                               style="background: #6c757d; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;">
                                Continue Shopping
                            </a>
                        </div>
                    </div>
                    
                    <div style="background: #f8f9fa; padding: 20px; text-align: center; color: #666; font-size: 12px;">
                        <p style="margin: 0;">Questions? Contact us at <a href="mailto:support@thesbsofficial.com" style="color: #667eea;">support@thesbsofficial.com</a></p>
                        <p style="margin: 5px 0 0 0;">SBS - Dublin, Ireland</p>
                    </div>
                </div>
            `;
          const response = await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${this.resendApiKey}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              from: "SBS Store <orders@thesbsofficial.com>",
              to: [order.user_email || order.email],
              subject: `Order Confirmation - ${order.order_number}`,
              html: emailHtml
            })
          });
          if (!response.ok) {
            const error = await response.text();
            console.error("\u{1F4E7} Order confirmation email failed:", error);
            return { success: false, reason: "email_send_failed", error };
          }
          console.log(`\u{1F4E7} Order confirmation sent to ${order.user_email || order.email}`);
          return { success: true, method: "email" };
        } catch (error) {
          console.error("\u{1F4E7} Order confirmation error:", error);
          return { success: false, reason: "notification_error", error: error.message };
        }
      }
    };
    notification_service_default = NotificationService;
  }
});

// api/admin/orders.js
function jsonResponse4(data, status = 200, headers = {}) {
  return new Response(JSON.stringify(data), {
    status,
    headers: { ...BASE_HEADERS, ...headers }
  });
}
async function requireAdminSession(context) {
  const session = await verifyAdminAuth(context.request, context.env);
  if (!session) {
    return { error: jsonResponse4({ error: "Unauthorized" }, 401) };
  }
  return { session };
}
async function fetchOrderWithItems(DB, orderNumber) {
  const order = await DB.prepare(`
        SELECT o.*
        FROM orders o
        WHERE o.order_number = ?
    `).bind(orderNumber).first();
  if (!order) {
    return null;
  }
  try {
    const rawItems = order.items_json ? JSON.parse(order.items_json) : [];
    order.items = Array.isArray(rawItems) ? rawItems.filter(Boolean) : [];
  } catch (e) {
    console.error("Failed to parse items_json:", e);
    order.items = [];
  }
  if (!order.total && order.total_amount) {
    order.total = order.total_amount;
  }
  if (!order.customer_name && order.user_id) {
    order.customer_name = `Customer #${order.user_id}`;
  }
  if (!order.customer_phone) {
    order.customer_phone = order.delivery_phone || "N/A";
  }
  return order;
}
async function attachItemsToOrders(DB, orders) {
  if (!orders.length) {
    return;
  }
  for (const order of orders) {
    try {
      const rawItems = order.items_json ? JSON.parse(order.items_json) : [];
      order.items = Array.isArray(rawItems) ? rawItems.filter(Boolean) : [];
    } catch (e) {
      console.error(`Failed to parse items_json for order ${order.id}:`, e);
      order.items = [];
    }
    if (!order.total && order.total_amount) {
      order.total = order.total_amount;
    }
    if (!order.customer_name && order.user_id) {
      order.customer_name = `Customer #${order.user_id}`;
    }
    if (!order.customer_phone) {
      order.customer_phone = order.delivery_phone || "N/A";
    }
  }
}
function deriveOrderEmail(order) {
  return order?.customer_email || order?.user_email || order?.email || null;
}
function mapItemsForNotification(items = []) {
  return items.map((item) => ({
    name: item.name || item.product_name || item.product_category || item.product_id || "SBS Item",
    size: item.size || item.product_size || "N/A",
    quantity: Number.isFinite(Number(item.quantity)) ? Number(item.quantity) : 1,
    price: Number.isFinite(Number(item.price || item.price)) ? Number(item.price || item.price) : "TBD"
  }));
}
function normalizeStatus(value) {
  return (value || "").toLowerCase();
}
function createOrderNumber() {
  const generated = generateOrderNumber();
  return generated.startsWith("SBS-") ? generated.replace("SBS-", "ORD-") : generated;
}
async function onRequestGet4(context) {
  try {
    const check = await requireAdminSession(context);
    if (check.error) return check.error;
    const { DB } = context.env;
    const url = new URL(context.request.url);
    const orderNumber = url.searchParams.get("order_number");
    const statusFilter = normalizeStatus(url.searchParams.get("status"));
    if (orderNumber) {
      const order = await fetchOrderWithItems(DB, orderNumber);
      if (!order) {
        return jsonResponse4({ error: "Order not found" }, 404);
      }
      await logAdminAction(context.env, check.session, "admin_order_view", `order_${orderNumber}`, {
        via: "orders_api",
        order_number: orderNumber
      });
      return jsonResponse4({ success: true, order });
    }
    let baseQuery = `
            SELECT o.*
            FROM orders o
        `;
    const params = [];
    if (statusFilter && statusFilter !== "all") {
      baseQuery += " WHERE lower(o.status) = ?";
      params.push(statusFilter);
    }
    baseQuery += " ORDER BY o.created_at DESC LIMIT 100";
    const stmt = params.length ? DB.prepare(baseQuery).bind(...params) : DB.prepare(baseQuery);
    const { results: orders } = await stmt.all();
    await attachItemsToOrders(DB, orders);
    const todayStr = (/* @__PURE__ */ new Date()).toDateString();
    const stats = {
      pending: orders.filter((o) => normalizeStatus(o.status) === "pending").length,
      confirmed: orders.filter((o) => normalizeStatus(o.status) === "confirmed").length,
      processing: orders.filter((o) => normalizeStatus(o.status) === "processing").length,
      shipped: orders.filter((o) => normalizeStatus(o.status) === "shipped").length,
      completed: orders.filter((o) => normalizeStatus(o.status) === "completed" && new Date(o.created_at).toDateString() === todayStr).length,
      revenue: orders.filter((o) => normalizeStatus(o.status) === "completed" && new Date(o.created_at).toDateString() === todayStr).reduce((sum, o) => {
        const total = Number(o.total_amount || o.total || 0);
        return sum + (Number.isFinite(total) ? total : 0);
      }, 0)
    };
    await logAdminAction(context.env, check.session, "admin_orders_list", null, {
      count: orders.length,
      status_filter: statusFilter || "all"
    });
    return jsonResponse4({ success: true, orders, stats, total: orders.length });
  } catch (error) {
    console.error("Orders GET Error:", error);
    return jsonResponse4({ error: "Failed to fetch orders", message: error.message }, 500);
  }
}
async function onRequestPost2(context) {
  try {
    const check = await requireAdminSession(context);
    if (check.error) return check.error;
    const { DB } = context.env;
    const orderData = await context.request.json();
    if (!Array.isArray(orderData.items) || orderData.items.length === 0) {
      return jsonResponse4({ error: "Order must include at least one item" }, 400);
    }
    const requiredFields = ["customer_name", "customer_phone", "delivery_method"];
    for (const field of requiredFields) {
      if (!orderData[field]) {
        return jsonResponse4({ error: `Missing required field: ${field}` }, 400);
      }
    }
    const deliveryMethod = orderData.delivery_method;
    if (!["collection", "delivery"].includes(deliveryMethod)) {
      return jsonResponse4({ error: "delivery_method must be collection or delivery" }, 400);
    }
    const orderNumber = createOrderNumber();
    const deliveryFee = Number.isFinite(Number(orderData.delivery_fee)) ? Number(orderData.delivery_fee) : deliveryMethod === "delivery" ? 5 : 0;
    const itemsSubtotal = orderData.items.reduce((sum, item) => {
      const price = Number(item.price) || 0;
      const qty = Number(item.quantity) || 1;
      return sum + price * qty;
    }, 0);
    const providedSubtotal = Number(orderData.subtotal);
    const providedTotal = Number(orderData.total);
    const subtotal = Number.isFinite(providedSubtotal) ? providedSubtotal : itemsSubtotal;
    const total = Number.isFinite(providedTotal) ? providedTotal : subtotal + deliveryFee;
    const itemsJson = JSON.stringify(orderData.items);
    const orderInsert = await DB.prepare(`
            INSERT INTO orders (
                order_number,
                user_id,
                customer_name,
                customer_phone,
                customer_email,
                items_json,
                delivery_method,
                delivery_fee,
                delivery_address,
                delivery_city,
                delivery_eircode,
                subtotal,
                total,
                status,
                created_at,
                updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', datetime('now'), datetime('now'))
        `).bind(
      orderNumber,
      orderData.user_id || null,
      orderData.customer_name,
      orderData.customer_phone,
      orderData.customer_email || null,
      itemsJson,
      deliveryMethod,
      deliveryFee,
      orderData.delivery_address || null,
      orderData.delivery_city || null,
      orderData.delivery_eircode || null,
      subtotal,
      total
    ).run();
    const createdOrder = await fetchOrderWithItems(DB, orderNumber);
    if (createdOrder) {
      const orderEmail = deriveOrderEmail(createdOrder);
      if (orderEmail) {
        try {
          const notificationService = new notification_service_default(context.env);
          const notificationResult = await notificationService.sendOrderConfirmation(
            { ...createdOrder, email: orderEmail, user_email: orderEmail },
            mapItemsForNotification(orderData.items)
          );
          if (!notificationResult.success) {
            console.warn("Order confirmation email not sent:", notificationResult.reason || notificationResult.error);
          }
        } catch (notificationError) {
          console.error("Order confirmation notification failed:", notificationError);
        }
      }
    }
    await logAdminAction(context.env, check.session, "admin_order_created", `order_${orderNumber}`, {
      delivery_method: deliveryMethod,
      items: orderData.items.length,
      has_email: Boolean(orderData.customer_email)
    });
    return jsonResponse4({
      success: true,
      order_number: orderNumber,
      order: createdOrder,
      message: "Order created successfully"
    }, 201);
  } catch (error) {
    console.error("Orders POST Error:", error);
    return jsonResponse4({ error: "Failed to create order", message: error.message }, 500);
  }
}
async function onRequestPut(context) {
  try {
    const check = await requireAdminSession(context);
    if (check.error) return check.error;
    const { DB } = context.env;
    const body = await context.request.json();
    const orderNumber = body.order_number;
    const newStatus = normalizeStatus(body.status);
    const adminNotes = body.admin_notes;
    if (!orderNumber) {
      return jsonResponse4({ error: "order_number is required" }, 400);
    }
    const validStatuses = ["pending", "confirmed", "processing", "shipped", "completed", "cancelled"];
    if (!validStatuses.includes(newStatus)) {
      return jsonResponse4({
        error: "Invalid status value",
        valid_statuses: validStatuses
      }, 400);
    }
    const existingOrder = await DB.prepare(`
            SELECT * FROM orders WHERE order_number = ?
        `).bind(orderNumber).first();
    if (!existingOrder) {
      return jsonResponse4({ error: "Order not found" }, 404);
    }
    await DB.prepare(`
            UPDATE orders
            SET status = ?,
                admin_notes = COALESCE(?, admin_notes),
                updated_at = datetime('now'),
                completed_at = CASE WHEN ? = 'completed' THEN datetime('now') ELSE completed_at END
            WHERE order_number = ?
        `).bind(newStatus, adminNotes, newStatus, orderNumber).run();
    const updatedOrder = await fetchOrderWithItems(DB, orderNumber) || existingOrder;
    const orderEmail = deriveOrderEmail(updatedOrder);
    if (orderEmail) {
      try {
        const notificationService = new notification_service_default(context.env);
        const notificationResult = await notificationService.sendOrderStatusUpdate(
          { ...updatedOrder, email: orderEmail, user_email: orderEmail },
          newStatus
        );
        if (!notificationResult.success) {
          console.warn("Status notification not delivered:", notificationResult.reason || notificationResult.error);
        }
      } catch (notificationError) {
        console.error("Status notification error:", notificationError);
      }
    }
    await logAdminAction(context.env, check.session, "admin_order_status_update", `order_${orderNumber}`, {
      old_status: existingOrder.status,
      new_status: newStatus
    });
    return jsonResponse4({
      success: true,
      message: `Order ${orderNumber} status updated to ${newStatus}`,
      order: updatedOrder
    });
  } catch (error) {
    console.error("Orders PUT Error:", error);
    return jsonResponse4({ error: "Failed to update order", message: error.message }, 500);
  }
}
async function onRequestDelete2(context) {
  try {
    const check = await requireAdminSession(context);
    if (check.error) return check.error;
    const { DB } = context.env;
    const url = new URL(context.request.url);
    const orderNumber = url.searchParams.get("order_number");
    if (!orderNumber) {
      return jsonResponse4({ error: "Missing order_number parameter" }, 400);
    }
    const existingOrder = await DB.prepare(`
            SELECT order_number FROM orders WHERE order_number = ?
        `).bind(orderNumber).first();
    if (!existingOrder) {
      return jsonResponse4({ error: "Order not found" }, 404);
    }
    await DB.prepare(`
            DELETE FROM orders WHERE order_number = ?
        `).bind(orderNumber).run();
    await logAdminAction(context.env, check.session, "admin_order_deleted", `order_${orderNumber}`);
    return jsonResponse4({
      success: true,
      message: `Order ${orderNumber} deleted successfully`
    });
  } catch (error) {
    console.error("Orders DELETE Error:", error);
    return jsonResponse4({ error: "Failed to delete order", message: error.message }, 500);
  }
}
var BASE_HEADERS;
var init_orders = __esm({
  "api/admin/orders.js"() {
    init_functionsRoutes_0_5646645567038772();
    init_notification_service();
    init_admin();
    init_security();
    BASE_HEADERS = {
      "Content-Type": "application/json",
      "Cache-Control": "no-cache"
    };
    __name(jsonResponse4, "jsonResponse");
    __name(requireAdminSession, "requireAdminSession");
    __name(fetchOrderWithItems, "fetchOrderWithItems");
    __name(attachItemsToOrders, "attachItemsToOrders");
    __name(deriveOrderEmail, "deriveOrderEmail");
    __name(mapItemsForNotification, "mapItemsForNotification");
    __name(normalizeStatus, "normalizeStatus");
    __name(createOrderNumber, "createOrderNumber");
    __name(onRequestGet4, "onRequestGet");
    __name(onRequestPost2, "onRequestPost");
    __name(onRequestPut, "onRequestPut");
    __name(onRequestDelete2, "onRequestDelete");
  }
});

// api/admin/products.js
function jsonResponse5(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization"
    }
  });
}
async function onRequestGet5(context) {
  const { request, env } = context;
  const url = new URL(request.url);
  try {
    const session = await verifyAdminAuth(request, env);
    if (!session) {
      return jsonResponse5({
        success: false,
        error: "Unauthorized - Admin access required"
      }, 401);
    }
    const category = url.searchParams.get("category");
    const status = url.searchParams.get("status") || "available";
    const search = url.searchParams.get("search");
    const sortBy = url.searchParams.get("sort") || "created_at";
    const sortOrder = url.searchParams.get("order") || "DESC";
    const limit = parseInt(url.searchParams.get("limit")) || 100;
    const offset = parseInt(url.searchParams.get("offset")) || 0;
    let query = `
            SELECT
                id,
                category,
                size,
                brand,
                description,
                condition,
                price,
                original_price,
                image_url,
                cloudflare_image_id,
                status,
                featured,
                sku,
                tags,
                created_at,
                updated_at,
                sold_at
            FROM products
            WHERE 1=1
        `;
    const params = [];
    if (category && category !== "all") {
      query += " AND category = ?";
      params.push(category);
    }
    if (status && status !== "all") {
      query += " AND status = ?";
      params.push(status);
    }
    if (search) {
      query += " AND (brand LIKE ? OR description LIKE ? OR sku LIKE ?)";
      const searchTerm = `%${search}%`;
      params.push(searchTerm, searchTerm, searchTerm);
    }
    const allowedSorts = ["created_at", "updated_at", "price", "brand", "category"];
    const sortColumn = allowedSorts.includes(sortBy) ? sortBy : "created_at";
    const sortDir = sortOrder.toUpperCase() === "ASC" ? "ASC" : "DESC";
    query += ` ORDER BY ${sortColumn} ${sortDir}`;
    query += " LIMIT ? OFFSET ?";
    params.push(limit, offset);
    const stmt = params.length > 0 ? env.DB.prepare(query).bind(...params) : env.DB.prepare(query);
    const products = await stmt.all();
    let countQuery = "SELECT COUNT(*) as total FROM products WHERE 1=1";
    const countParams = [];
    if (category && category !== "all") {
      countQuery += " AND category = ?";
      countParams.push(category);
    }
    if (status && status !== "all") {
      countQuery += " AND status = ?";
      countParams.push(status);
    }
    if (search) {
      countQuery += " AND (brand LIKE ? OR description LIKE ? OR sku LIKE ?)";
      const searchTerm = `%${search}%`;
      countParams.push(searchTerm, searchTerm, searchTerm);
    }
    const countStmt = countParams.length > 0 ? env.DB.prepare(countQuery).bind(...countParams) : env.DB.prepare(countQuery);
    const countResult = await countStmt.first();
    await logAdminAction(env, session, "products_list_view", null, {
      filters: { category, status, search },
      result_count: products.results?.length || 0
    });
    return jsonResponse5({
      success: true,
      data: {
        products: products.results || [],
        pagination: {
          total: countResult?.total || 0,
          limit,
          offset,
          has_more: offset + limit < (countResult?.total || 0)
        }
      }
    });
  } catch (error) {
    console.error("\u274C Error fetching products:", error);
    return jsonResponse5({
      success: false,
      error: "Failed to fetch products",
      details: error.message
    }, 500);
  }
}
async function onRequestPost3(context) {
  const { request, env } = context;
  try {
    const session = await verifyAdminAuth(request, env);
    if (!session) {
      return jsonResponse5({
        success: false,
        error: "Unauthorized - Admin access required"
      }, 401);
    }
    const body = await request.json();
    const required = ["category", "size", "brand", "price"];
    for (const field of required) {
      if (!body[field]) {
        return jsonResponse5({
          success: false,
          error: `Missing required field: ${field}`
        }, 400);
      }
    }
    const validCategories = ["BN-CLOTHES", "BN-SHOES", "PO-CLOTHES", "PO-SHOES"];
    if (!validCategories.includes(body.category)) {
      return jsonResponse5({
        success: false,
        error: "Invalid category. Must be one of: " + validCategories.join(", ")
      }, 400);
    }
    const validConditions = ["new", "excellent", "good"];
    const condition = body.condition || "new";
    if (!validConditions.includes(condition)) {
      return jsonResponse5({
        success: false,
        error: "Invalid condition. Must be one of: " + validConditions.join(", ")
      }, 400);
    }
    const sku = body.sku || generateSKU(body.category, body.brand);
    const result = await env.DB.prepare(`
            INSERT INTO products (
                category, size, brand, description, condition,
                price, original_price, image_url, cloudflare_image_id,
                status, featured, sku, tags, created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
        `).bind(
      body.category,
      body.size,
      body.brand,
      body.description || null,
      condition,
      body.price,
      body.original_price || null,
      body.image_url || null,
      body.cloudflare_image_id || null,
      body.status || "available",
      body.featured ? 1 : 0,
      sku,
      body.tags ? JSON.stringify(body.tags) : null
    ).run();
    const productId = result.meta?.last_row_id;
    const product = await env.DB.prepare(
      "SELECT * FROM products WHERE id = ?"
    ).bind(productId).first();
    await logAdminAction(env, session, "product_create", `product_${productId}`, {
      product_id: productId,
      category: body.category,
      brand: body.brand,
      price: body.price
    });
    console.log(`\u2705 Product created: ${productId} - ${body.brand} ${body.category}`);
    return jsonResponse5({
      success: true,
      message: "Product created successfully",
      data: { product }
    }, 201);
  } catch (error) {
    console.error("\u274C Error creating product:", error);
    return jsonResponse5({
      success: false,
      error: "Failed to create product",
      details: error.message
    }, 500);
  }
}
async function onRequestPut2(context) {
  const { request, env } = context;
  const url = new URL(request.url);
  try {
    const session = await verifyAdminAuth(request, env);
    if (!session) {
      return jsonResponse5({
        success: false,
        error: "Unauthorized - Admin access required"
      }, 401);
    }
    const pathParts = url.pathname.split("/");
    const productId = pathParts[pathParts.length - 1];
    if (!productId || isNaN(productId)) {
      return jsonResponse5({
        success: false,
        error: "Invalid product ID"
      }, 400);
    }
    const existingProduct = await env.DB.prepare(
      "SELECT * FROM products WHERE id = ?"
    ).bind(productId).first();
    if (!existingProduct) {
      return jsonResponse5({
        success: false,
        error: "Product not found"
      }, 404);
    }
    const body = await request.json();
    const updates = [];
    const params = [];
    const allowedFields = [
      "category",
      "size",
      "brand",
      "description",
      "condition",
      "price",
      "original_price",
      "image_url",
      "cloudflare_image_id",
      "status",
      "featured",
      "sku",
      "tags"
    ];
    for (const field of allowedFields) {
      if (body[field] !== void 0) {
        updates.push(`${field} = ?`);
        if (field === "featured") {
          params.push(body[field] ? 1 : 0);
        } else if (field === "tags" && typeof body[field] === "object") {
          params.push(JSON.stringify(body[field]));
        } else {
          params.push(body[field]);
        }
      }
    }
    if (updates.length === 0) {
      return jsonResponse5({
        success: false,
        error: "No valid fields to update"
      }, 400);
    }
    updates.push('updated_at = datetime("now")');
    if (body.status === "sold" && existingProduct.status !== "sold") {
      updates.push('sold_at = datetime("now")');
    }
    params.push(productId);
    await env.DB.prepare(`
            UPDATE products
            SET ${updates.join(", ")}
            WHERE id = ?
        `).bind(...params).run();
    const updatedProduct = await env.DB.prepare(
      "SELECT * FROM products WHERE id = ?"
    ).bind(productId).first();
    await logAdminAction(env, session, "product_update", `product_${productId}`, {
      product_id: productId,
      updated_fields: Object.keys(body),
      previous_status: existingProduct.status,
      new_status: body.status || existingProduct.status
    });
    console.log(`\u2705 Product updated: ${productId}`);
    return jsonResponse5({
      success: true,
      message: "Product updated successfully",
      data: { product: updatedProduct }
    });
  } catch (error) {
    console.error("\u274C Error updating product:", error);
    return jsonResponse5({
      success: false,
      error: "Failed to update product",
      details: error.message
    }, 500);
  }
}
async function onRequestDelete3(context) {
  const { request, env } = context;
  const url = new URL(request.url);
  try {
    const session = await verifyAdminAuth(request, env);
    if (!session) {
      return jsonResponse5({
        success: false,
        error: "Unauthorized - Admin access required"
      }, 401);
    }
    const pathParts = url.pathname.split("/");
    const productId = pathParts[pathParts.length - 1];
    if (!productId || isNaN(productId)) {
      return jsonResponse5({
        success: false,
        error: "Invalid product ID"
      }, 400);
    }
    const product = await env.DB.prepare(
      "SELECT * FROM products WHERE id = ?"
    ).bind(productId).first();
    if (!product) {
      return jsonResponse5({
        success: false,
        error: "Product not found"
      }, 404);
    }
    await env.DB.prepare(`
            UPDATE products
            SET status = 'removed', updated_at = datetime('now')
            WHERE id = ?
        `).bind(productId).run();
    await logAdminAction(env, session, "product_delete", `product_${productId}`, {
      product_id: productId,
      brand: product.brand,
      category: product.category,
      sku: product.sku
    });
    console.log(`\u2705 Product deleted (soft): ${productId} - ${product.brand}`);
    return jsonResponse5({
      success: true,
      message: "Product deleted successfully"
    });
  } catch (error) {
    console.error("\u274C Error deleting product:", error);
    return jsonResponse5({
      success: false,
      error: "Failed to delete product",
      details: error.message
    }, 500);
  }
}
async function onRequestOptions3(context) {
  return jsonResponse5(null, 204);
}
function generateSKU(category, brand) {
  const prefix = category.substring(0, 2);
  const brandPrefix = brand.substring(0, 3).toUpperCase();
  const timestamp = Date.now().toString(36).toUpperCase().slice(-6);
  return `${prefix}-${brandPrefix}-${timestamp}`;
}
var init_products = __esm({
  "api/admin/products.js"() {
    init_functionsRoutes_0_5646645567038772();
    init_admin();
    __name(jsonResponse5, "jsonResponse");
    __name(onRequestGet5, "onRequestGet");
    __name(onRequestPost3, "onRequestPost");
    __name(onRequestPut2, "onRequestPut");
    __name(onRequestDelete3, "onRequestDelete");
    __name(onRequestOptions3, "onRequestOptions");
    __name(generateSKU, "generateSKU");
  }
});

// api/admin/update-image-metadata.js
async function sha256b642(text) {
  const encoder = new TextEncoder();
  const data = encoder.encode(text);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = new Uint8Array(hashBuffer);
  return btoa(String.fromCharCode(...hashArray));
}
async function onRequestPatch({ request, env }) {
  const cookie = request.headers.get("Cookie") || "";
  const sessionId = cookie.split("sbs_session=")[1]?.split(";")[0];
  if (!sessionId) {
    return new Response(JSON.stringify({
      success: false,
      error: "Not authenticated"
    }), {
      status: 401,
      headers: { "Content-Type": "application/json" }
    });
  }
  try {
    const sessionHash = await sha256b642(sessionId);
    const sessionResult = await env.DB.prepare(
      "SELECT user_id, expires_at FROM sessions WHERE token = ? AND invalidated_at IS NULL"
    ).bind(sessionHash).first();
    if (!sessionResult) {
      return new Response(JSON.stringify({
        success: false,
        error: "Session not found. Please log in again."
      }), {
        status: 401,
        headers: { "Content-Type": "application/json" }
      });
    }
    const now = (/* @__PURE__ */ new Date()).toISOString();
    if (sessionResult.expires_at < now) {
      return new Response(JSON.stringify({
        success: false,
        error: "Session expired. Please log in again."
      }), {
        status: 401,
        headers: { "Content-Type": "application/json" }
      });
    }
    const userResult = await env.DB.prepare(
      "SELECT role FROM users WHERE id = ?"
    ).bind(sessionResult.user_id).first();
    if (!userResult || userResult.role !== "admin") {
      return new Response(JSON.stringify({
        success: false,
        error: "Admin access required"
      }), {
        status: 403,
        headers: { "Content-Type": "application/json" }
      });
    }
    const { imageId, metadata } = await request.json();
    if (!imageId || !metadata) {
      return new Response(JSON.stringify({
        success: false,
        error: "Missing imageId or metadata"
      }), {
        status: 400,
        headers: { "Content-Type": "application/json" }
      });
    }
    const accountId = env.CLOUDFLARE_ACCOUNT_ID;
    const apiToken = env.CLOUDFLARE_IMAGES_API_TOKEN || env.CLOUDFLARE_API_TOKEN;
    if (!accountId || !apiToken) {
      return new Response(JSON.stringify({
        success: false,
        error: "Missing Cloudflare credentials"
      }), {
        status: 500,
        headers: { "Content-Type": "application/json" }
      });
    }
    const updateUrl = `https://api.cloudflare.com/client/v4/accounts/${accountId}/images/v1/${imageId}`;
    const updateResponse = await fetch(updateUrl, {
      method: "PATCH",
      headers: {
        "Authorization": `Bearer ${apiToken}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ metadata })
    });
    const updateResult = await updateResponse.json();
    if (!updateResponse.ok || !updateResult.success) {
      console.error("CF Images update failed:", updateResult);
      return new Response(JSON.stringify({
        success: false,
        error: updateResult.errors?.[0]?.message || "Failed to update image metadata"
      }), {
        status: updateResponse.status,
        headers: { "Content-Type": "application/json" }
      });
    }
    return new Response(JSON.stringify({
      success: true,
      message: "Metadata updated successfully",
      imageId
    }), {
      status: 200,
      headers: { "Content-Type": "application/json" }
    });
  } catch (error) {
    console.error("Update metadata error:", error);
    return new Response(JSON.stringify({
      success: false,
      error: error.message || "Internal server error"
    }), {
      status: 500,
      headers: { "Content-Type": "application/json" }
    });
  }
}
var init_update_image_metadata = __esm({
  "api/admin/update-image-metadata.js"() {
    init_functionsRoutes_0_5646645567038772();
    __name(sha256b642, "sha256b64");
    __name(onRequestPatch, "onRequestPatch");
  }
});

// api/admin/upload-image.js
async function sha256b643(text) {
  const encoder = new TextEncoder();
  const data = encoder.encode(text);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = new Uint8Array(hashBuffer);
  return btoa(String.fromCharCode(...hashArray));
}
async function onRequestPost4({ request, env }) {
  const cookie = request.headers.get("Cookie") || "";
  const sessionId = cookie.split("sbs_session=")[1]?.split(";")[0];
  if (!sessionId) {
    return new Response(JSON.stringify({
      success: false,
      error: "Not authenticated"
    }), {
      status: 401,
      headers: { "Content-Type": "application/json" }
    });
  }
  try {
    const sessionHash = await sha256b643(sessionId);
    const sessionResult = await env.DB.prepare(
      "SELECT user_id, expires_at FROM sessions WHERE token = ? AND invalidated_at IS NULL"
    ).bind(sessionHash).first();
    if (!sessionResult) {
      return new Response(JSON.stringify({
        success: false,
        error: "Session not found. Please log in again."
      }), {
        status: 401,
        headers: { "Content-Type": "application/json" }
      });
    }
    const now = (/* @__PURE__ */ new Date()).toISOString();
    if (sessionResult.expires_at < now) {
      return new Response(JSON.stringify({
        success: false,
        error: "Session expired. Please log in again."
      }), {
        status: 401,
        headers: { "Content-Type": "application/json" }
      });
    }
    const userResult = await env.DB.prepare(
      "SELECT role FROM users WHERE id = ?"
    ).bind(sessionResult.user_id).first();
    if (!userResult) {
      return new Response(JSON.stringify({
        success: false,
        error: "User not found."
      }), {
        status: 401,
        headers: { "Content-Type": "application/json" }
      });
    }
    if (userResult.role !== "admin") {
      return new Response(JSON.stringify({
        success: false,
        error: "Admin access required. Your account role is: " + (userResult.role || "user")
      }), {
        status: 403,
        headers: { "Content-Type": "application/json" }
      });
    }
    const formData = await request.formData();
    const file = formData.get("file");
    const filename = formData.get("filename");
    const metadataJson = formData.get("metadata");
    if (!file) {
      return new Response(JSON.stringify({
        success: false,
        error: "No file provided"
      }), {
        status: 400,
        headers: { "Content-Type": "application/json" }
      });
    }
    let uploadMetadata = {};
    if (metadataJson) {
      try {
        uploadMetadata = JSON.parse(metadataJson);
      } catch (e) {
        console.warn("Failed to parse metadata:", e);
      }
    }
    const accountId = env.CLOUDFLARE_ACCOUNT_ID;
    const apiToken = env.CLOUDFLARE_IMAGES_API_TOKEN || env.CLOUDFLARE_API_TOKEN;
    if (!accountId || !apiToken) {
      return new Response(JSON.stringify({
        success: false,
        error: "Missing Cloudflare credentials"
      }), {
        status: 500,
        headers: { "Content-Type": "application/json" }
      });
    }
    const cleanFilename = filename || file.name || "untitled";
    let productName = cleanFilename.replace(/\.(jpg|jpeg|png|webp|gif)$/i, "").replace(/DESC-([^-]+)-CAT/i, "$1").replace(/CAT-[^-]+-SIZE-[^-]+-/gi, "").replace(/DATE-\d+-/gi, "").replace(/TIME-\d+-/gi, "").replace(/BATCH-[^-]+-/gi, "").replace(/ITEM-\d+/gi, "").replace(/[-_]/g, " ").trim();
    if (!productName || productName.length < 3) {
      const category = uploadMetadata.category || "Unknown";
      const size = uploadMetadata.size || "";
      productName = `${category.replace("-", " ")} ${size}`.trim();
    }
    productName = productName.split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(" ");
    const cfMetadata = {
      // Product Info - what shop reads
      name: uploadMetadata.description || productName,
      // Use description as name if provided
      category: uploadMetadata.category || "",
      // BN-CLOTHES, BN-SHOES, etc.
      size: uploadMetadata.size || "",
      brand: "",
      // Can be set later via edit
      // Inventory status
      status: "active",
      // active, hidden, sold
      stock: "1",
      // String format for CF Images
      // Additional Info
      description: uploadMetadata.description || productName,
      sku: "",
      // Auto-generated by products.js
      featured: "false",
      // Tracking (optional)
      batch: uploadMetadata.batch || "",
      item: uploadMetadata.item || "",
      originalName: uploadMetadata.originalName || file.name
    };
    const uploadFormData = new FormData();
    uploadFormData.append("file", file);
    uploadFormData.append("metadata", JSON.stringify(cfMetadata));
    const uploadUrl = `https://api.cloudflare.com/client/v4/accounts/${accountId}/images/v1`;
    const uploadResponse = await fetch(uploadUrl, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${apiToken}`
      },
      body: uploadFormData
    });
    const uploadResult = await uploadResponse.json();
    if (!uploadResponse.ok || !uploadResult.success) {
      console.error("CF Images upload failed:", uploadResult);
      return new Response(JSON.stringify({
        success: false,
        error: uploadResult.errors?.[0]?.message || "Failed to upload image to Cloudflare"
      }), {
        status: uploadResponse.status,
        headers: { "Content-Type": "application/json" }
      });
    }
    const imageId = uploadResult.result.id;
    try {
      await env.DB.prepare(`
                INSERT INTO products (
                    image_id, category, size, condition, 
                    status, quantity_total, quantity_available,
                    created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
            `).bind(
        imageId,
        cfMetadata.category || "BN-CLOTHES",
        cfMetadata.size || null,
        uploadMetadata.category?.includes("BN") ? "Brand New" : "Pre-Owned",
        cfMetadata.status || "active",
        1,
        // quantity_total
        1
        // quantity_available
      ).run();
      console.log(`\u2705 Product ${imageId} synced to D1 inventory`);
    } catch (dbError) {
      console.warn("\u26A0\uFE0F D1 sync failed (non-critical):", dbError.message);
    }
    return new Response(JSON.stringify({
      success: true,
      message: "Image uploaded successfully with metadata and synced to smart inventory",
      uploadedId: imageId,
      filename: cleanFilename,
      metadata: cfMetadata,
      productName: cfMetadata.name,
      d1_synced: true
    }), {
      status: 200,
      headers: { "Content-Type": "application/json" }
    });
  } catch (error) {
    console.error("Upload error:", error);
    return new Response(JSON.stringify({
      success: false,
      error: error.message || "Internal server error"
    }), {
      status: 500,
      headers: { "Content-Type": "application/json" }
    });
  }
}
var init_upload_image = __esm({
  "api/admin/upload-image.js"() {
    init_functionsRoutes_0_5646645567038772();
    __name(sha256b643, "sha256b64");
    __name(onRequestPost4, "onRequestPost");
  }
});

// api/analytics/sync.js
async function onRequestPost5(context) {
  const { request, env } = context;
  try {
    const authHeader = request.headers.get("Authorization");
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return jsonResponse6({ success: false, error: "Unauthorized" }, 401);
    }
    const token = authHeader.substring(7);
    const session = await env.DB.prepare(`
            SELECT user_id FROM admin_sessions 
            WHERE token = ? AND datetime(expires_at) > datetime('now')
        `).bind(token).first();
    if (!session) {
      return jsonResponse6({ success: false, error: "Invalid session" }, 401);
    }
    const startTime = Date.now();
    const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    console.log(`\u{1F4CA} Starting analytics sync for ${today}`);
    const summary = await env.DB.prepare(`
            SELECT 
                COUNT(DISTINCT session_id) as unique_visitors,
                COUNT(*) FILTER (WHERE event_type = 'page_view') as page_views,
                COUNT(*) FILTER (WHERE event_type = 'product_view') as products_viewed,
                COUNT(DISTINCT product_id) FILTER (WHERE event_type = 'product_view' AND product_id IS NOT NULL) as unique_products_viewed,
                COUNT(*) FILTER (WHERE event_type = 'add_to_cart') as cart_adds,
                COUNT(*) FILTER (WHERE event_type = 'checkout_initiated') as checkouts_initiated,
                COUNT(*) FILTER (WHERE event_type = 'purchase') as orders_completed,
                SUM(value) FILTER (WHERE event_type = 'purchase') as revenue,
                SUM(quantity) FILTER (WHERE event_type = 'purchase') as items_sold,
                COUNT(*) FILTER (WHERE event_type = 'search') as total_searches,
                COUNT(DISTINCT json_extract(metadata, '$.search_term')) FILTER (WHERE event_type = 'search') as unique_search_terms
            FROM analytics_events
            WHERE DATE(created_at) = ?
        `).bind(today).first();
    const conversionRate = summary.unique_visitors > 0 ? (summary.orders_completed / summary.unique_visitors * 100).toFixed(2) : 0;
    const cartAbandonmentRate = summary.cart_adds > 0 ? ((summary.cart_adds - summary.orders_completed) / summary.cart_adds * 100).toFixed(2) : 0;
    const addToCartRate = summary.products_viewed > 0 ? (summary.cart_adds / summary.products_viewed * 100).toFixed(2) : 0;
    const avgOrderValue = summary.orders_completed > 0 ? (summary.revenue / summary.orders_completed).toFixed(2) : 0;
    const topProduct = await env.DB.prepare(`
            SELECT product_id, COUNT(*) as view_count
            FROM analytics_events
            WHERE DATE(created_at) = ? AND event_type = 'product_view' AND product_id IS NOT NULL
            GROUP BY product_id
            ORDER BY view_count DESC
            LIMIT 1
        `).bind(today).first();
    const topCategory = await env.DB.prepare(`
            SELECT category, COUNT(*) as count
            FROM analytics_events
            WHERE DATE(created_at) = ? AND category IS NOT NULL
            GROUP BY category
            ORDER BY count DESC
            LIMIT 1
        `).bind(today).first();
    const topBrand = await env.DB.prepare(`
            SELECT brand, COUNT(*) as count
            FROM analytics_events
            WHERE DATE(created_at) = ? AND brand IS NOT NULL
            GROUP BY brand
            ORDER BY count DESC
            LIMIT 1
        `).bind(today).first();
    const topSearch = await env.DB.prepare(`
            SELECT json_extract(metadata, '$.search_term') as search_term, COUNT(*) as count
            FROM analytics_events
            WHERE DATE(created_at) = ? AND event_type = 'search'
            GROUP BY search_term
            ORDER BY count DESC
            LIMIT 1
        `).bind(today).first();
    await env.DB.prepare(`
            INSERT INTO analytics_daily_summary 
            (date, unique_visitors, page_views, products_viewed, unique_products_viewed,
             cart_adds, checkouts_initiated, orders_completed, revenue, avg_order_value,
             items_sold, conversion_rate, cart_abandonment_rate, add_to_cart_rate,
             top_product_id, top_product_views, top_category, top_brand, total_searches,
             unique_search_terms, top_search_term, synced_at, updated_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ON CONFLICT(date) DO UPDATE SET
                unique_visitors = excluded.unique_visitors,
                page_views = excluded.page_views,
                products_viewed = excluded.products_viewed,
                unique_products_viewed = excluded.unique_products_viewed,
                cart_adds = excluded.cart_adds,
                checkouts_initiated = excluded.checkouts_initiated,
                orders_completed = excluded.orders_completed,
                revenue = excluded.revenue,
                avg_order_value = excluded.avg_order_value,
                items_sold = excluded.items_sold,
                conversion_rate = excluded.conversion_rate,
                cart_abandonment_rate = excluded.cart_abandonment_rate,
                add_to_cart_rate = excluded.add_to_cart_rate,
                top_product_id = excluded.top_product_id,
                top_product_views = excluded.top_product_views,
                top_category = excluded.top_category,
                top_brand = excluded.top_brand,
                total_searches = excluded.total_searches,
                unique_search_terms = excluded.unique_search_terms,
                top_search_term = excluded.top_search_term,
                synced_at = excluded.synced_at,
                updated_at = excluded.updated_at
        `).bind(
      today,
      summary.unique_visitors,
      summary.page_views,
      summary.products_viewed,
      summary.unique_products_viewed,
      summary.cart_adds,
      summary.checkouts_initiated,
      summary.orders_completed,
      summary.revenue || 0,
      avgOrderValue,
      summary.items_sold || 0,
      conversionRate,
      cartAbandonmentRate,
      addToCartRate,
      topProduct?.product_id || null,
      topProduct?.view_count || 0,
      topCategory?.category || null,
      topBrand?.brand || null,
      summary.total_searches,
      summary.unique_search_terms,
      topSearch?.search_term || null,
      (/* @__PURE__ */ new Date()).toISOString(),
      (/* @__PURE__ */ new Date()).toISOString()
    ).run();
    const productStats = await env.DB.prepare(`
            SELECT 
                product_id,
                json_extract(metadata, '$.product_name') as product_name,
                json_extract(metadata, '$.category') as category,
                json_extract(metadata, '$.brand') as brand,
                json_extract(metadata, '$.price') as price,
                COUNT(*) FILTER (WHERE event_type = 'product_view') as views,
                COUNT(DISTINCT session_id) FILTER (WHERE event_type = 'product_view') as unique_viewers,
                COUNT(*) FILTER (WHERE event_type = 'add_to_cart') as cart_adds,
                COUNT(*) FILTER (WHERE event_type = 'purchase') as purchases,
                SUM(value) FILTER (WHERE event_type = 'purchase') as revenue,
                SUM(quantity) FILTER (WHERE event_type = 'purchase') as units_sold
            FROM analytics_events
            WHERE DATE(created_at) = ? AND product_id IS NOT NULL
            GROUP BY product_id
        `).bind(today).all();
    for (const product of productStats.results || []) {
      const viewToCartRate = product.views > 0 ? (product.cart_adds / product.views * 100).toFixed(2) : 0;
      const cartToPurchaseRate = product.cart_adds > 0 ? (product.purchases / product.cart_adds * 100).toFixed(2) : 0;
      const overallConversionRate = product.views > 0 ? (product.purchases / product.views * 100).toFixed(2) : 0;
      await env.DB.prepare(`
                INSERT INTO analytics_product_performance
                (product_id, date, views, unique_viewers, cart_adds, purchases,
                 revenue, units_sold, view_to_cart_rate, cart_to_purchase_rate,
                 overall_conversion_rate, product_name, category, brand, price, synced_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ON CONFLICT(product_id, date) DO UPDATE SET
                    views = excluded.views,
                    unique_viewers = excluded.unique_viewers,
                    cart_adds = excluded.cart_adds,
                    purchases = excluded.purchases,
                    revenue = excluded.revenue,
                    units_sold = excluded.units_sold,
                    view_to_cart_rate = excluded.view_to_cart_rate,
                    cart_to_purchase_rate = excluded.cart_to_purchase_rate,
                    overall_conversion_rate = excluded.overall_conversion_rate,
                    synced_at = excluded.synced_at
            `).bind(
        product.product_id,
        today,
        product.views,
        product.unique_viewers,
        product.cart_adds,
        product.purchases,
        product.revenue || 0,
        product.units_sold || 0,
        viewToCartRate,
        cartToPurchaseRate,
        overallConversionRate,
        product.product_name,
        product.category,
        product.brand,
        product.price,
        (/* @__PURE__ */ new Date()).toISOString()
      ).run();
    }
    const duration = Date.now() - startTime;
    await env.DB.prepare(`
            INSERT INTO analytics_sync_log
            (sync_type, sync_date, status, events_processed, records_updated, duration_ms, started_at, completed_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `).bind(
      "daily_summary",
      today,
      "success",
      summary.page_views || 0,
      1 + (productStats.results?.length || 0),
      duration,
      new Date(startTime).toISOString(),
      (/* @__PURE__ */ new Date()).toISOString()
    ).run();
    console.log(`\u2705 Analytics sync completed in ${duration}ms`);
    return jsonResponse6({
      success: true,
      sync_date: today,
      summary: {
        unique_visitors: summary.unique_visitors,
        page_views: summary.page_views,
        orders_completed: summary.orders_completed,
        revenue: summary.revenue || 0,
        conversion_rate: conversionRate,
        products_synced: productStats.results?.length || 0
      },
      duration_ms: duration
    });
  } catch (error) {
    console.error("\u274C Analytics sync error:", error);
    return jsonResponse6({
      success: false,
      error: error.message
    }, 500);
  }
}
function jsonResponse6(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*"
    }
  });
}
var init_sync = __esm({
  "api/analytics/sync.js"() {
    init_functionsRoutes_0_5646645567038772();
    __name(onRequestPost5, "onRequestPost");
    __name(jsonResponse6, "jsonResponse");
  }
});

// api/analytics/track.js
async function onRequestPost6(context) {
  const { request, env } = context;
  const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "POST, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type",
    "Content-Type": "application/json"
  };
  if (request.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }
  try {
    const body = await request.json();
    const events = body?.events;
    if (!Array.isArray(events) || events.length === 0) {
      return new Response(JSON.stringify({
        success: false,
        error: "Invalid events payload"
      }), { status: 400, headers: corsHeaders });
    }
    const ip = request.headers.get("CF-Connecting-IP") || (request.headers.get("X-Forwarded-For") || "").split(",")[0] || "unknown";
    const userAgent = request.headers.get("User-Agent") || "unknown";
    let successCount = 0;
    const errors = [];
    for (const rawEvent of events) {
      try {
        const eventType = rawEvent?.type || rawEvent?.event_type || "unknown";
        const eventPath = rawEvent?.path || rawEvent?.page_url || null;
        const sessionId = rawEvent?.session_id || rawEvent?.sessionId || body?.sessionId || null;
        const userId = rawEvent?.user_id || rawEvent?.userId || null;
        const serializedEvent = JSON.stringify(rawEvent?.data ?? rawEvent ?? {});
        await env.DB.prepare(`
                    INSERT INTO analytics_events (event_type, event_data, user_id, session_id, ip_address, user_agent, path)
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                `).bind(
          eventType,
          serializedEvent,
          userId,
          sessionId,
          ip,
          userAgent,
          eventPath
        ).run();
        successCount++;
      } catch (insertError) {
        console.error("\u274C Analytics insert failure:", insertError);
        errors.push({
          type: rawEvent?.type || rawEvent?.event_type,
          message: insertError.message
        });
      }
    }
    const responsePayload = {
      success: errors.length === 0,
      tracked: successCount,
      failed: errors.length,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
    if (errors.length > 0) {
      responsePayload.errors = errors.slice(0, 3);
    }
    return new Response(JSON.stringify(responsePayload), {
      status: errors.length === 0 ? 200 : 207,
      headers: corsHeaders
    });
  } catch (error) {
    console.error("\u274C Analytics tracking error:", error);
    return new Response(JSON.stringify({
      success: false,
      error: error.message || "Failed to track analytics"
    }), { status: 500, headers: corsHeaders });
  }
}
var init_track = __esm({
  "api/analytics/track.js"() {
    init_functionsRoutes_0_5646645567038772();
    __name(onRequestPost6, "onRequestPost");
  }
});

// api/cases/submit.js
async function onRequestPost7(context) {
  const { request, env } = context;
  try {
    const data = await request.json();
    const required = ["category", "brand", "condition", "price", "address", "city", "phone", "socialChannel", "socialHandle"];
    for (const field of required) {
      if (!data[field]) {
        return Response.json({ error: `Missing required field: ${field}` }, { status: 400 });
      }
    }
    const authHeader = request.headers.get("Authorization");
    const token = authHeader?.replace("Bearer ", "");
    let userId = null;
    if (token) {
      const session = await env.DB.prepare(
        'SELECT user_id FROM sessions WHERE token = ? AND expires_at > datetime("now")'
      ).bind(token).first();
      if (session) {
        userId = session.user_id;
      }
    }
    const year = (/* @__PURE__ */ new Date()).getFullYear();
    const caseNumber = await getNextCaseNumber(env.DB, year);
    const caseId = `CASE-${year}-${String(caseNumber).padStart(3, "0")}`;
    const insertResult = await env.DB.prepare(`
            INSERT INTO sell_cases (
                case_id, user_id, category, brand, condition, size, price,
                address, city, eircode, defects,
                phone, preferred_contact, social_handle, email,
                photo_count, save_profile
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `).bind(
      caseId,
      userId,
      // Will be NULL if not logged in, integer if logged in
      data.category,
      data.brand,
      data.condition,
      data.size || null,
      data.price,
      data.address,
      data.city,
      data.eircode || null,
      data.defects || null,
      data.phone,
      data.socialChannel,
      data.socialHandle,
      data.email || null,
      data.uploadedFiles ? data.uploadedFiles.length : 0,
      data.saveProfile ? 1 : 0
    ).run();
    if (data.uploadedFiles && data.uploadedFiles.length > 0) {
      for (const file of data.uploadedFiles) {
        const newKey = `cases/${caseId}/${file.filename}`;
        const tempObject = await env.USER_UPLOADS.get(file.r2Key);
        if (tempObject) {
          await env.USER_UPLOADS.put(newKey, tempObject.body, {
            httpMetadata: {
              contentType: file.mimeType
            },
            customMetadata: {
              caseId,
              originalName: file.filename,
              uploadedAt: (/* @__PURE__ */ new Date()).toISOString()
            }
          });
          await env.USER_UPLOADS.delete(file.r2Key);
          await env.DB.prepare(`
                        INSERT INTO case_photos (case_id, filename, r2_key, file_size, mime_type)
                        VALUES (?, ?, ?, ?, ?)
                    `).bind(caseId, file.filename, newKey, file.size, file.mimeType).run();
        }
      }
    }
    if (data.saveProfile && data.email) {
      const emailResult = await sendRegistrationEmail(env, {
        caseId,
        email: data.email,
        socialHandle: data.socialHandle,
        socialChannel: data.socialChannel,
        city: data.city
      });
      if (emailResult.sent) {
        await env.DB.prepare(`
                    UPDATE sell_cases SET registration_email_sent = 1 WHERE case_id = ?
                `).bind(caseId).run();
      } else {
        console.warn(`\u26A0\uFE0F Registration email skipped for case ${caseId}:`, emailResult.reason);
      }
    }
    return Response.json({
      success: true,
      caseId,
      message: "Case submitted successfully",
      photosUploaded: data.uploadedFiles ? data.uploadedFiles.length : 0
    });
  } catch (error) {
    console.error("Case submission error:", error);
    return Response.json({
      error: "Submission failed",
      details: error.message
    }, { status: 500 });
  }
}
async function getNextCaseNumber(db, year) {
  const result = await db.prepare(`
        SELECT MAX(CAST(SUBSTR(case_id, -3) AS INTEGER)) as max_num
        FROM sell_cases
        WHERE case_id LIKE ?
    `).bind(`CASE-${year}-%`).first();
  return (result?.max_num || 0) + 1;
}
async function sendRegistrationEmail(env, payload) {
  const apiKey = env.RESEND_API_KEY;
  if (!apiKey) {
    return { sent: false, reason: "RESEND_API_KEY not configured" };
  }
  try {
    const response = await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        from: "SBS Team <noreply@thesbsofficial.com>",
        to: [payload.email],
        subject: "\u{1F44B} Welcome to SBS \u2014 Let\u2019s get you set up",
        html: buildRegistrationEmailHtml(payload)
      })
    });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Resend error ${response.status}: ${errorText}`);
    }
    const result = await response.json();
    console.log(`\u2705 Registration email sent for case ${payload.caseId}:`, result.id);
    return { sent: true, id: result.id };
  } catch (error) {
    console.error("Registration email send failed:", error);
    return { sent: false, reason: error.message };
  }
}
function buildRegistrationEmailHtml({ caseId, socialHandle, socialChannel, city }) {
  const handle = socialHandle ? `@${socialHandle}` : "your profile";
  const channelLabel = socialChannel === "snapchat" ? "Snapchat" : "Instagram";
  const location = city ? ` in ${city}` : "";
  return `
        <div style="font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background:#0a0a0a; color:#fff; padding:32px;">
            <div style="max-width:560px; margin:0 auto; background:#141414; border:1px solid rgba(255,215,0,0.2); border-radius:18px; overflow:hidden;">
                <div style="padding:32px; text-align:center; background:linear-gradient(135deg, rgba(255,215,0,0.12), transparent);">
                    <h1 style="margin:0; font-size:28px; letter-spacing:1px; color:#ffd700;">Welcome to SBS</h1>
                    <p style="margin:12px 0 0; font-size:16px; color:#f5f5f5;">We received your sell request ${location}.</p>
                </div>
                <div style="padding:32px;">
                    <p style="margin:0 0 16px; font-size:16px; color:#f5f5f5;">
                        Thanks for trusting us with your drop! Your submission <strong>${caseId}</strong> is in the queue.
                    </p>
                    <div style="background:rgba(255,215,0,0.08); border-radius:12px; padding:20px; margin-bottom:20px;">
                        <p style="margin:0; font-size:15px; color:#ffd700; font-weight:600;">Submission Snapshot</p>
                        <ul style="margin:12px 0 0; padding-left:18px; color:#e5e5e5; font-size:14px; line-height:1.6;">
                            <li>Handle: <strong>${handle}</strong> (${channelLabel})</li>
                            <li>Status: Pending review by the SBS buying team</li>
                            <li>Response: We aim to reply within 60 minutes during service hours</li>
                        </ul>
                    </div>
                    <p style="margin:0 0 16px; font-size:15px; color:#d1d1d1;">
                        Want faster checkouts and same-day collection updates? Finish setting up your SBS seller profile and we\u2019ll keep everything synced automatically.
                    </p>
                    <div style="text-align:center; margin:32px 0;">
                        <a href="https://thesbsofficial.com/register" style="display:inline-block; padding:14px 28px; background:linear-gradient(135deg,#ffd700,#ffc400); color:#000; font-weight:700; border-radius:999px; text-decoration:none; letter-spacing:0.5px;">Complete Your Profile</a>
                    </div>
                    <p style="margin:0; font-size:13px; color:#888; text-align:center;">
                        Questions? Reply to this email or DM us on Instagram. We\u2019re here to help.
                    </p>
                </div>
            </div>
        </div>
    `;
}
var init_submit = __esm({
  "api/cases/submit.js"() {
    init_functionsRoutes_0_5646645567038772();
    __name(onRequestPost7, "onRequestPost");
    __name(getNextCaseNumber, "getNextCaseNumber");
    __name(sendRegistrationEmail, "sendRegistrationEmail");
    __name(buildRegistrationEmailHtml, "buildRegistrationEmailHtml");
  }
});

// api/cases/upload-photos.js
async function onRequestPost8(context) {
  const { request, env } = context;
  try {
    const formData = await request.formData();
    const photos = formData.getAll("photos");
    if (!photos || photos.length === 0) {
      return Response.json({ error: "No photos provided" }, { status: 400 });
    }
    if (photos.length > 5) {
      return Response.json({ error: "Maximum 5 photos allowed" }, { status: 400 });
    }
    const sessionId = crypto.randomUUID();
    const uploadedFiles = [];
    for (const photo of photos) {
      if (photo.size > 10 * 1024 * 1024) {
        return Response.json({
          error: `File ${photo.name} exceeds 10MB limit`
        }, { status: 400 });
      }
      if (!photo.type.startsWith("image/")) {
        return Response.json({
          error: `File ${photo.name} is not an image`
        }, { status: 400 });
      }
      const timestamp = Date.now();
      const filename = `${timestamp}-${photo.name}`;
      const r2Key = `temp/${sessionId}/${filename}`;
      await env.USER_UPLOADS.put(r2Key, photo.stream(), {
        httpMetadata: {
          contentType: photo.type
        },
        customMetadata: {
          originalName: photo.name,
          uploadedAt: (/* @__PURE__ */ new Date()).toISOString()
        }
      });
      uploadedFiles.push({
        filename,
        r2Key,
        size: photo.size,
        mimeType: photo.type
      });
    }
    return Response.json({
      success: true,
      sessionId,
      uploadedFiles,
      message: `${uploadedFiles.length} photo${uploadedFiles.length > 1 ? "s" : ""} uploaded successfully`
    });
  } catch (error) {
    console.error("Photo upload error:", error);
    return Response.json({
      error: "Upload failed",
      details: error.message
    }, { status: 500 });
  }
}
var init_upload_photos = __esm({
  "api/cases/upload-photos.js"() {
    init_functionsRoutes_0_5646645567038772();
    __name(onRequestPost8, "onRequestPost");
  }
});

// api/reservations/create.js
async function onRequestPost9(context) {
  const { request, env } = context;
  const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "POST, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type"
  };
  if (request.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }
  try {
    const { items, customer, order_number } = await request.json();
    if (!items || !Array.isArray(items) || items.length === 0) {
      return new Response(JSON.stringify({
        success: false,
        error: "No items to reserve"
      }), {
        status: 400,
        headers: { ...corsHeaders, "Content-Type": "application/json" }
      });
    }
    if (!customer || !customer.name || !customer.phone) {
      return new Response(JSON.stringify({
        success: false,
        error: "Customer information required"
      }), {
        status: 400,
        headers: { ...corsHeaders, "Content-Type": "application/json" }
      });
    }
    const db = env.DB;
    const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1e3).toISOString();
    const reservations = [];
    for (const item of items) {
      const product = await db.prepare(`
                SELECT id, title, status 
                FROM products 
                WHERE id = ?
            `).bind(item.id).first();
      if (!product) {
        console.warn(`Product ${item.id} not found`);
        continue;
      }
      if (product.status !== "available") {
        console.warn(`Product ${item.id} (${product.title}) is ${product.status}`);
        continue;
      }
      const result = await db.prepare(`
                INSERT INTO product_reservations (
                    product_id,
                    order_number,
                    customer_name,
                    customer_phone,
                    customer_email,
                    expires_at,
                    status
                ) VALUES (?, ?, ?, ?, ?, ?, 'pending')
            `).bind(
        item.id,
        order_number,
        customer.name,
        customer.phone,
        customer.email || null,
        expiresAt
      ).run();
      reservations.push({
        product_id: item.id,
        product_title: product.title,
        reservation_id: result.meta.last_row_id
      });
    }
    if (reservations.length === 0) {
      return new Response(JSON.stringify({
        success: false,
        error: "No products could be reserved (already reserved or sold)"
      }), {
        status: 400,
        headers: { ...corsHeaders, "Content-Type": "application/json" }
      });
    }
    return new Response(JSON.stringify({
      success: true,
      message: `${reservations.length} item(s) reserved successfully`,
      reservations,
      expires_at: expiresAt
    }), {
      status: 200,
      headers: { ...corsHeaders, "Content-Type": "application/json" }
    });
  } catch (error) {
    console.error("Reservation error:", error);
    return new Response(JSON.stringify({
      success: false,
      error: error.message || "Failed to create reservations"
    }), {
      status: 500,
      headers: { ...corsHeaders, "Content-Type": "application/json" }
    });
  }
}
var init_create = __esm({
  "api/reservations/create.js"() {
    init_functionsRoutes_0_5646645567038772();
    __name(onRequestPost9, "onRequestPost");
  }
});

// api/admin/reservations.js
async function onRequest(context) {
  const { request, env } = context;
  const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, Authorization"
  };
  if (request.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }
  try {
    const db = env.DB;
    if (request.method === "GET") {
      const reservations = await db.prepare(`
                SELECT 
                    r.*,
                    p.title as product_title,
                    p.brand as product_brand,
                    p.price as product_price,
                    p.image_url as product_image,
                    p.status as product_status
                FROM product_reservations r
                LEFT JOIN products p ON r.product_id = p.id
                WHERE r.status = 'pending'
                ORDER BY r.created_at DESC
            `).all();
      return new Response(JSON.stringify({
        success: true,
        reservations: reservations.results || []
      }), {
        status: 200,
        headers: { ...corsHeaders, "Content-Type": "application/json" }
      });
    }
    if (request.method === "POST") {
      const { reservation_id, action, admin_notes } = await request.json();
      if (!reservation_id || !action) {
        return new Response(JSON.stringify({
          success: false,
          error: "reservation_id and action required"
        }), {
          status: 400,
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
      const validActions = ["confirm", "cancel"];
      if (!validActions.includes(action)) {
        return new Response(JSON.stringify({
          success: false,
          error: "Invalid action. Use: confirm or cancel"
        }), {
          status: 400,
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
      const newStatus = action === "confirm" ? "confirmed" : "cancelled";
      await db.prepare(`
                UPDATE product_reservations
                SET status = ?,
                    admin_notes = ?,
                    reviewed_at = CURRENT_TIMESTAMP,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = ?
            `).bind(newStatus, admin_notes || null, reservation_id).run();
      const reservation = await db.prepare(`
                SELECT 
                    r.*,
                    p.title as product_title,
                    p.status as product_status
                FROM product_reservations r
                LEFT JOIN products p ON r.product_id = p.id
                WHERE r.id = ?
            `).bind(reservation_id).first();
      return new Response(JSON.stringify({
        success: true,
        message: `Reservation ${action}ed successfully`,
        reservation
      }), {
        status: 200,
        headers: { ...corsHeaders, "Content-Type": "application/json" }
      });
    }
    return new Response(JSON.stringify({
      success: false,
      error: "Method not allowed"
    }), {
      status: 405,
      headers: { ...corsHeaders, "Content-Type": "application/json" }
    });
  } catch (error) {
    console.error("Admin reservations error:", error);
    return new Response(JSON.stringify({
      success: false,
      error: error.message || "Failed to manage reservations"
    }), {
      status: 500,
      headers: { ...corsHeaders, "Content-Type": "application/json" }
    });
  }
}
var init_reservations = __esm({
  "api/admin/reservations.js"() {
    init_functionsRoutes_0_5646645567038772();
    __name(onRequest, "onRequest");
  }
});

// api/admin/sell-requests.js
function jsonResponse7(data, status = 200, headers = {}) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      ...headers
    }
  });
}
async function onRequest2(context) {
  const { request, env } = context;
  const url = new URL(request.url);
  const pathParts = url.pathname.split("/").filter(Boolean);
  const session = await verifyAdminAuth(request, env);
  if (!session) {
    return jsonResponse7({
      success: false,
      error: "Unauthorized"
    }, 401);
  }
  const method = request.method;
  const submissionId = pathParts[pathParts.length - 1];
  const isIdRequest = !isNaN(parseInt(submissionId));
  try {
    if (method === "GET" && !isIdRequest) {
      return await handleGetSubmissions(context, session);
    } else if (method === "GET" && isIdRequest) {
      return await handleGetSubmissionDetails(context, submissionId, session);
    } else if (method === "PUT" && isIdRequest) {
      return await handleUpdateSubmission(context, submissionId, session);
    } else if (method === "DELETE" && isIdRequest) {
      return await handleDeleteSubmission(context, submissionId, session);
    } else {
      return jsonResponse7({
        success: false,
        error: "Method not allowed"
      }, 405);
    }
  } catch (error) {
    console.error("\u274C Sell requests API error:", error);
    return jsonResponse7({
      success: false,
      error: "Internal server error",
      details: error.message,
      stack: error.stack
    }, 500);
  }
}
async function handleGetSubmissions(context, session) {
  const { request, env } = context;
  const url = new URL(request.url);
  const status = url.searchParams.get("status");
  const batchId = url.searchParams.get("batch_id");
  const search = url.searchParams.get("search");
  const page = parseInt(url.searchParams.get("page")) || 1;
  const limit = parseInt(url.searchParams.get("limit")) || 50;
  const offset = (page - 1) * limit;
  try {
    let conditions = [];
    let params = [];
    if (status) {
      conditions.push("status = ?");
      params.push(status);
    }
    if (batchId) {
      conditions.push("batch_id = ?");
      params.push(batchId);
    }
    if (search) {
      conditions.push(
        "(contact_phone LIKE ? OR contact_email LIKE ? OR contact_handle LIKE ? OR batch_id LIKE ?)"
      );
      const searchTerm = `%${search}%`;
      params.push(searchTerm, searchTerm, searchTerm, searchTerm);
    }
    const whereClause = conditions.length > 0 ? "WHERE " + conditions.join(" AND ") : "";
    const query = `
            SELECT
                id,
                batch_id,
                user_id,
                status,
                items_json,
                item_count,
                contact_name,
                contact_phone,
                contact_channel,
                contact_handle,
                contact_email,
                address,
                city,
                eircode,
                notes,
                admin_notes,
                estimated_value,
                offered_price,
                final_price,
                seller_price,
                seller_message,
                total_offer,
                reviewed_at,
                reviewed_by,
                created_at,
                updated_at
            FROM sell_submissions
            ${whereClause}
            ORDER BY created_at DESC
            LIMIT ? OFFSET ?
        `;
    const result = await env.DB.prepare(query).bind(...params, limit, offset).all();
    const countQuery = `
            SELECT COUNT(*) as total
            FROM sell_submissions
            ${whereClause}
        `;
    const countResult = await env.DB.prepare(countQuery).bind(...params).first();
    const submissions = result.results.map((sub) => {
      let items = [];
      try {
        const raw = sub.items_json || "[]";
        const parsed = JSON.parse(raw);
        items = Array.isArray(parsed) ? parsed.filter(Boolean) : [];
      } catch (e) {
        console.warn("Malformed items_json for submission", sub.id, e?.message);
        items = [];
      }
      const derivedCount = Number.isFinite(sub.item_count) && sub.item_count >= 0 ? sub.item_count : items.length;
      return {
        ...sub,
        items,
        item_count: derivedCount,
        items_json: void 0
      };
    });
    const statusSummary = await env.DB.prepare(`
            SELECT
                status,
                COUNT(*) as count,
                SUM(item_count) as total_items
            FROM sell_submissions
            GROUP BY status
        `).all();
    await logAdminAction(env, session, "view_sell_requests", null, {
      filters: { status, batchId, search },
      results_count: submissions.length
    });
    return jsonResponse7({
      success: true,
      submissions,
      pagination: {
        page,
        limit,
        total: countResult.total,
        total_pages: Math.ceil(countResult.total / limit)
      },
      summary: statusSummary?.results || []
    });
  } catch (error) {
    console.error("\u274C Get submissions error:", error);
    throw error;
  }
}
async function handleGetSubmissionDetails(context, submissionId, session) {
  const { env } = context;
  try {
    const submission = await env.DB.prepare(`
            SELECT
                s.*,
                COALESCE(NULLIF(TRIM(u.first_name || ' ' || u.last_name), ''), u.email, u.social_handle) AS user_name,
                u.email AS user_email,
                COALESCE(NULLIF(TRIM(r.first_name || ' ' || r.last_name), ''), r.email, r.social_handle) AS reviewer_name
            FROM sell_submissions s
            LEFT JOIN users u ON s.user_id = u.id
            LEFT JOIN users r ON s.reviewed_by = r.id
            WHERE s.id = ?
        `).bind(submissionId).first();
    if (!submission) {
      return jsonResponse7({
        success: false,
        error: "Submission not found"
      }, 404);
    }
    try {
      const parsed = JSON.parse(submission.items_json || "[]");
      submission.items = Array.isArray(parsed) ? parsed.filter(Boolean) : [];
    } catch (error) {
      console.warn("Malformed items_json for submission", submissionId, error?.message);
      submission.items = [];
    }
    delete submission.items_json;
    const history = await env.DB.prepare(`
            SELECT
                action,
                COALESCE(metadata_json, metadata) AS metadata_json,
                created_at,
                COALESCE(NULLIF(TRIM(u.first_name || ' ' || u.last_name), ''), u.email, u.social_handle) as admin_name
            FROM admin_audit_logs a
            LEFT JOIN users u ON a.admin_id = u.id
            WHERE a.action LIKE '%sell_request%'
                AND json_extract(COALESCE(a.metadata_json, a.metadata), '$.submission_id') = ?
            ORDER BY a.created_at DESC
        `).bind(submissionId).all();
    await logAdminAction(env, session, "view_sell_request_details", submissionId, {
      batch_id: submission.batch_id
    });
    const historyEntries = history.results.map((entry) => {
      let metadata = null;
      if (entry.metadata_json) {
        try {
          metadata = JSON.parse(entry.metadata_json);
        } catch (error) {
          metadata = entry.metadata_json;
        }
      }
      return {
        action: entry.action,
        created_at: entry.created_at,
        admin_name: entry.admin_name,
        metadata
      };
    });
    return jsonResponse7({
      success: true,
      submission,
      history: historyEntries
    });
  } catch (error) {
    console.error("\u274C Get submission details error:", error);
    throw error;
  }
}
async function handleUpdateSubmission(context, submissionId, session) {
  const { request, env } = context;
  const updates = await request.json();
  try {
    const current = await env.DB.prepare(
      "SELECT * FROM sell_submissions WHERE id = ?"
    ).bind(submissionId).first();
    if (!current) {
      return jsonResponse7({
        success: false,
        error: "Submission not found"
      }, 404);
    }
    const allowedFields = [
      "status",
      "admin_notes",
      "estimated_value",
      "offered_price",
      "final_price",
      "reviewed_by",
      "reviewed_at"
    ];
    const updateFields = [];
    const params = [];
    Object.keys(updates).forEach((key) => {
      if (allowedFields.includes(key)) {
        updateFields.push(`${key} = ?`);
        params.push(updates[key]);
      }
    });
    if (updates.status && updates.status !== current.status) {
      if (!updateFields.includes("reviewed_by = ?")) {
        updateFields.push("reviewed_by = ?");
        params.push(session.user_id);
      }
      if (!updateFields.includes("reviewed_at = ?")) {
        updateFields.push("reviewed_at = CURRENT_TIMESTAMP");
      }
    }
    updateFields.push("updated_at = CURRENT_TIMESTAMP");
    if (updateFields.length === 0) {
      return jsonResponse7({
        success: false,
        error: "No valid fields to update"
      }, 400);
    }
    params.push(submissionId);
    const query = `
            UPDATE sell_submissions
            SET ${updateFields.join(", ")}
            WHERE id = ?
        `;
    await env.DB.prepare(query).bind(...params).run();
    const updated = await env.DB.prepare(
      "SELECT * FROM sell_submissions WHERE id = ?"
    ).bind(submissionId).first();
    updated.items = JSON.parse(updated.items_json || "[]");
    delete updated.items_json;
    await logAdminAction(env, session, "update_sell_request", submissionId, {
      batch_id: updated.batch_id,
      updates,
      old_status: current.status,
      new_status: updated.status
    });
    return jsonResponse7({
      success: true,
      submission: updated,
      message: "Submission updated successfully"
    });
  } catch (error) {
    console.error("\u274C Update submission error:", error);
    throw error;
  }
}
async function handleDeleteSubmission(context, submissionId, session) {
  const { env } = context;
  try {
    const submission = await env.DB.prepare(
      "SELECT batch_id, status FROM sell_submissions WHERE id = ?"
    ).bind(submissionId).first();
    if (!submission) {
      return jsonResponse7({
        success: false,
        error: "Submission not found"
      }, 404);
    }
    await env.DB.prepare(
      "DELETE FROM sell_submissions WHERE id = ?"
    ).bind(submissionId).run();
    await logAdminAction(env, session, "delete_sell_request", submissionId, {
      batch_id: submission.batch_id,
      status: submission.status
    });
    return jsonResponse7({
      success: true,
      message: "Submission deleted successfully"
    });
  } catch (error) {
    console.error("\u274C Delete submission error:", error);
    throw error;
  }
}
var init_sell_requests = __esm({
  "api/admin/sell-requests.js"() {
    init_functionsRoutes_0_5646645567038772();
    init_admin();
    __name(jsonResponse7, "jsonResponse");
    __name(onRequest2, "onRequest");
    __name(handleGetSubmissions, "handleGetSubmissions");
    __name(handleGetSubmissionDetails, "handleGetSubmissionDetails");
    __name(handleUpdateSubmission, "handleUpdateSubmission");
    __name(handleDeleteSubmission, "handleDeleteSubmission");
  }
});

// api/sell-submissions.js
async function onRequestPost10(context) {
  const { request, env } = context;
  try {
    const data = await request.json();
    const sessionToken = extractSessionToken(request);
    if (sessionToken) {
      const session = await validateSession(env, sessionToken);
      if (session?.user_id) {
        data.user_id = session.user_id;
      }
    }
    if (!data.items || !Array.isArray(data.items) || data.items.length === 0) {
      return Response.json({
        success: false,
        error: "At least one item is required"
      }, { status: 400 });
    }
    if (!data.contact_phone || !data.contact_channel || !data.contact_handle) {
      return Response.json({
        success: false,
        error: "Contact details are required"
      }, { status: 400 });
    }
    const batchId = await generateBatchId(env.DB);
    const itemsJson = JSON.stringify(data.items);
    const itemCount = Array.isArray(data.items) ? data.items.length : 0;
    const sellerPrice = typeof data.seller_price === "number" && !Number.isNaN(data.seller_price) ? Number(data.seller_price) : null;
    const sellerMessage = typeof data.seller_message === "string" && data.seller_message.trim().length > 0 ? data.seller_message.trim() : null;
    const result = await env.DB.prepare(`
            INSERT INTO sell_submissions (
                batch_id,
                user_id,
                status,
                items_json,
                item_count,
                contact_phone,
                contact_channel,
                contact_handle,
                contact_email,
                address,
                city,
                eircode,
                notes,
                seller_price,
                seller_message,
                created_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
        `).bind(
      batchId,
      data.user_id || null,
      "pending",
      itemsJson,
      itemCount,
      data.contact_phone,
      data.contact_channel,
      data.contact_handle,
      data.contact_email || null,
      data.address || null,
      data.city || null,
      data.eircode || null,
      data.notes || null,
      sellerPrice,
      sellerMessage
    ).run();
    return Response.json({
      success: true,
      batch_id: batchId,
      submission_id: result.meta.last_row_id,
      message: `Submission received! Batch ID: ${batchId}`,
      items_count: itemCount
    }, { status: 201 });
  } catch (error) {
    console.error("Sell submission error:", error);
    return Response.json({
      success: false,
      error: "Submission failed. Please try again.",
      details: error.message
    }, { status: 500 });
  }
}
async function generateBatchId(db) {
  const date = /* @__PURE__ */ new Date();
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  const dateStr = `${year}${month}${day}`;
  const random = Math.floor(1e4 + Math.random() * 9e4);
  const batchId = `BATCH-${dateStr}-${random}`;
  const existing = await db.prepare(
    "SELECT batch_id FROM sell_submissions WHERE batch_id = ?"
  ).bind(batchId).first();
  if (existing) {
    return generateBatchId(db);
  }
  return batchId;
}
async function onRequestGet6(context) {
  const { request, env } = context;
  const url = new URL(request.url);
  const statusFilter = url.searchParams.get("status");
  const batchId = url.searchParams.get("batch_id");
  const limitParam = parseInt(url.searchParams.get("limit"), 10);
  const offsetParam = parseInt(url.searchParams.get("offset"), 10);
  const maxLimit = 1500;
  const limit = Number.isFinite(limitParam) ? Math.min(Math.max(limitParam, 10), maxLimit) : 200;
  const offset = Number.isFinite(offsetParam) && offsetParam >= 0 ? offsetParam : 0;
  try {
    const sessionToken = extractSessionToken(request);
    const session = sessionToken ? await validateSession(env, sessionToken) : null;
    const isAdminContext = session?.role === "admin" && session?.is_allowlisted === 1;
    if (!session) {
      return Response.json({
        success: false,
        error: "Unauthorized"
      }, { status: 401 });
    }
    const filters = [];
    const bindings = [];
    if (!isAdminContext) {
      const identityClauses = [];
      const identityBindings = [];
      if (session.user_id) {
        identityClauses.push("user_id = ?");
        identityBindings.push(session.user_id);
      }
      if (session.social_handle) {
        identityClauses.push("LOWER(REPLACE(contact_handle, '@', '')) = ?");
        identityBindings.push(normalizeHandle(session.social_handle));
      }
      if (session.instagram) {
        identityClauses.push("LOWER(REPLACE(contact_handle, '@', '')) = ?");
        identityBindings.push(normalizeHandle(session.instagram));
      }
      if (session.snapchat) {
        identityClauses.push("LOWER(REPLACE(contact_handle, '@', '')) = ?");
        identityBindings.push(normalizeHandle(session.snapchat));
      }
      if (session.email) {
        identityClauses.push("LOWER(contact_email) = LOWER(?)");
        identityBindings.push(session.email.toLowerCase());
      }
      if (session.phone) {
        identityClauses.push(`REPLACE(REPLACE(REPLACE(contact_phone, ' ', ''), '-', ''), '+', '') = REPLACE(REPLACE(REPLACE(?, ' ', ''), '-', ''), '+', '')`);
        identityBindings.push(normalizePhone(session.phone));
      }
      if (identityClauses.length === 0) {
        return Response.json({
          success: true,
          submissions: [],
          summary: [],
          total: 0,
          count: 0,
          pagination: {
            page: 1,
            limit,
            total_pages: 0
          }
        });
      }
      filters.push(`(${identityClauses.join(" OR ")})`);
      bindings.push(...identityBindings);
    }
    if (isAdminContext) {
      const userIdFilter = url.searchParams.get("user_id");
      const handleFilter = url.searchParams.get("handle");
      const phoneFilter = url.searchParams.get("phone");
      if (userIdFilter) {
        filters.push("user_id = ?");
        bindings.push(Number(userIdFilter));
      }
      if (handleFilter) {
        filters.push("LOWER(REPLACE(contact_handle, '@', '')) = ?");
        bindings.push(normalizeHandle(handleFilter));
      }
      if (phoneFilter) {
        filters.push(`REPLACE(REPLACE(REPLACE(contact_phone, ' ', ''), '-', ''), '+', '') = REPLACE(REPLACE(REPLACE(?, ' ', ''), '-', ''), '+', '')`);
        bindings.push(normalizePhone(phoneFilter));
      }
    }
    if (statusFilter) {
      filters.push("status = ?");
      bindings.push(statusFilter);
    }
    if (batchId) {
      filters.push("batch_id = ?");
      bindings.push(batchId);
    }
    const whereClause = filters.length ? `WHERE ${filters.join(" AND ")}` : "";
    const query = `
            SELECT
                id,
                batch_id,
                user_id,
                status,
                items_json,
                item_count,
                contact_phone,
                contact_channel,
                contact_handle,
                contact_email,
                address,
                city,
                eircode,
                notes,
                seller_price,
                seller_message,
                estimated_value,
                offered_price,
                offer_message,
                offer_sent_at,
                offer_expires_at,
                seller_response,
                seller_response_message,
                seller_response_at,
                final_price,
                admin_notes,
                created_at,
                updated_at
            FROM sell_submissions
            ${whereClause}
            ORDER BY datetime(created_at) DESC
            LIMIT ? OFFSET ?
        `;
    const submissionsResult = await env.DB.prepare(query).bind(...bindings, limit, offset).all();
    const countQuery = `
            SELECT
                COUNT(*) as total,
                COALESCE(SUM(json_array_length(items_json)), 0) as total_items
            FROM sell_submissions
            ${whereClause}
        `;
    const countResult = await env.DB.prepare(countQuery).bind(...bindings).first();
    const summaryQuery = `
            SELECT
                status,
                COUNT(*) as count,
                COALESCE(SUM(json_array_length(items_json)), 0) as items
            FROM sell_submissions
            ${whereClause}
            GROUP BY status
        `;
    const summaryResult = await env.DB.prepare(summaryQuery).bind(...bindings).all();
    const submissions = submissionsResult.results.map((row) => {
      const { items_json, item_count, ...rest } = row;
      const items = parseItems(items_json);
      const normalizedCount = Number.isFinite(Number(item_count)) ? Number(item_count) : items.length;
      return {
        ...rest,
        item_count: normalizedCount,
        items
      };
    });
    const total = Number(countResult?.total || 0);
    const page = Math.floor(offset / limit) + 1;
    const totalPages = total === 0 ? 0 : Math.ceil(total / limit);
    const summary = summaryResult.results.map((row) => ({
      status: row.status,
      count: Number(row.count || 0),
      items: Number(row.items || 0),
      total_items: Number(row.items || 0)
    }));
    return Response.json({
      success: true,
      submissions,
      total,
      count: submissions.length,
      total_items: Number(countResult?.total_items || 0),
      summary,
      pagination: {
        page,
        limit,
        offset,
        total_pages: totalPages
      }
    });
  } catch (error) {
    console.error("Fetch submissions error:", error);
    return Response.json({
      success: false,
      error: "Failed to fetch submissions"
    }, { status: 500 });
  }
}
function parseItems(itemsJson) {
  if (!itemsJson) return [];
  try {
    const parsed = JSON.parse(itemsJson);
    return Array.isArray(parsed) ? parsed : [];
  } catch (error) {
    console.warn("Failed to parse items_json:", error);
    return [];
  }
}
function normalizeHandle(handle) {
  if (!handle) return handle;
  return handle.toLowerCase().replace(/^@+/, "").trim();
}
function normalizePhone(phone) {
  if (!phone) return phone;
  return String(phone).replace(/[^0-9+]/g, "");
}
var init_sell_submissions = __esm({
  "api/sell-submissions.js"() {
    init_functionsRoutes_0_5646645567038772();
    init_sessions();
    __name(onRequestPost10, "onRequestPost");
    __name(generateBatchId, "generateBatchId");
    __name(onRequestGet6, "onRequestGet");
    __name(parseItems, "parseItems");
    __name(normalizeHandle, "normalizeHandle");
    __name(normalizePhone, "normalizePhone");
  }
});

// api/analytics-v2.js
async function onRequest3(context) {
  const { env, request } = context;
  const url = new URL(request.url);
  const period = url.searchParams.get("period") || "week";
  const view = url.searchParams.get("view") || "overview";
  const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "GET, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type",
    "Content-Type": "application/json"
  };
  if (request.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }
  try {
    const db = env.DB;
    const now = /* @__PURE__ */ new Date();
    let startDate;
    switch (period) {
      case "day":
        startDate = new Date(now.setDate(now.getDate() - 1));
        break;
      case "week":
        startDate = new Date(now.setDate(now.getDate() - 7));
        break;
      case "month":
        startDate = new Date(now.setMonth(now.getMonth() - 1));
        break;
      default:
        startDate = /* @__PURE__ */ new Date("2024-01-01");
    }
    let analytics;
    switch (view) {
      case "products":
        analytics = await getProductAnalytics(db, startDate);
        break;
      case "customers":
        analytics = await getCustomerAnalytics(db, startDate);
        break;
      case "sellers":
        analytics = await getSellerAnalytics(db, startDate);
        break;
      default:
        analytics = await getOverviewAnalytics(db, startDate);
    }
    return new Response(JSON.stringify({
      success: true,
      view,
      period,
      date_range: {
        start: startDate.toISOString(),
        end: (/* @__PURE__ */ new Date()).toISOString()
      },
      ...analytics,
      generated_at: (/* @__PURE__ */ new Date()).toISOString()
    }), {
      status: 200,
      headers: corsHeaders
    });
  } catch (error) {
    console.error("\u274C Analytics error:", error);
    return new Response(JSON.stringify({
      success: false,
      error: error.message,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    }), {
      status: 500,
      headers: corsHeaders
    });
  }
}
async function getOverviewAnalytics(db, startDate) {
  const [products, customers, orders] = await Promise.all([
    db.prepare('SELECT COUNT(*) as count FROM products WHERE status = "active"').first(),
    db.prepare("SELECT COUNT(*) as count FROM users WHERE is_active = 1").first(),
    db.prepare("SELECT COUNT(*) as count FROM orders WHERE created_at >= ?").bind(startDate.toISOString()).first()
  ]);
  return {
    summary: {
      active_products: products?.count || 0,
      total_customers: customers?.count || 0,
      recent_orders: orders?.count || 0
    },
    quick_insights: [
      { metric: "Active Inventory", value: products?.count || 0, icon: "\u{1F4E6}", trend: "stable" },
      { metric: "Registered Customers", value: customers?.count || 0, icon: "\u{1F465}", trend: "growing" },
      { metric: "Recent Orders", value: orders?.count || 0, icon: "\u{1F6D2}", trend: "active" }
    ],
    upgrade_available: {
      products: "Detailed product trends",
      customers: "Top customers & behavior",
      sellers: "Seller performance tracking"
    }
  };
}
async function getProductAnalytics(db, startDate) {
  const total = await db.prepare("SELECT COUNT(*) as count FROM products").first();
  const statusBreakdown = await db.prepare(`
        SELECT
            status,
            COUNT(*) as count
        FROM products
        GROUP BY status
    `).all();
  const categoryStats = await db.prepare(`
        SELECT
            category,
            COUNT(*) as total,
            SUM(CASE WHEN status = 'active' THEN 1 ELSE 0 END) as active,
            SUM(CASE WHEN status = 'sold' THEN 1 ELSE 0 END) as sold,
            SUM(views_count) as total_views
        FROM products
        WHERE created_at >= ?
        GROUP BY category
        ORDER BY sold DESC
    `).bind(startDate.toISOString()).all();
  const hotProducts = await db.prepare(`
        SELECT
            image_id,
            category,
            size,
            views_count,
            created_at
        FROM products
        WHERE status = 'active' AND views_count > 0
        ORDER BY views_count DESC
        LIMIT 5
    `).all();
  const fastMovers = await db.prepare(`
        SELECT
            image_id,
            category,
            size,
            days_to_sell,
            sold_at
        FROM products
        WHERE status = 'sold'
            AND days_to_sell IS NOT NULL
            AND sold_at >= ?
        ORDER BY days_to_sell ASC
        LIMIT 5
    `).bind(startDate.toISOString()).all();
  return {
    summary: {
      total_products: total?.count || 0,
      by_status: statusBreakdown.results
    },
    category_performance: categoryStats.results,
    hot_products: hotProducts.results,
    fast_movers: fastMovers.results,
    insights: generateProductInsights(categoryStats.results, hotProducts.results)
  };
}
async function getCustomerAnalytics(db, startDate) {
  const topCustomers = await db.prepare(`
        SELECT
            u.id,
            u.email,
            u.first_name,
            u.last_name,
            u.city,
            u.preferred_contact,
            COUNT(o.id) as order_count,
            MAX(o.created_at) as last_order,
            MIN(o.created_at) as first_order
        FROM users u
        JOIN orders o ON u.id = o.user_id
        WHERE o.created_at >= ?
        GROUP BY u.id
        ORDER BY order_count DESC
        LIMIT 10
    `).bind(startDate.toISOString()).all();
  const locations = await db.prepare(`
        SELECT
            city,
            COUNT(*) as customer_count
        FROM users
        WHERE is_active = 1 AND city IS NOT NULL
        GROUP BY city
        ORDER BY customer_count DESC
        LIMIT 10
    `).all();
  const contactPrefs = await db.prepare(`
        SELECT
            preferred_contact,
            COUNT(*) as count
        FROM users
        WHERE is_active = 1
        GROUP BY preferred_contact
    `).all();
  const customerTypes = await db.prepare(`
        SELECT
            CASE
                WHEN order_count = 1 THEN 'new'
                ELSE 'returning'
            END as type,
            COUNT(*) as count
        FROM (
            SELECT user_id, COUNT(*) as order_count
            FROM orders
            WHERE created_at >= ?
            GROUP BY user_id
        )
        GROUP BY type
    `).bind(startDate.toISOString()).all();
  return {
    summary: {
      top_customers: topCustomers.results.slice(0, 5),
      total_active: topCustomers.results.length
    },
    locations: locations.results,
    contact_preferences: contactPrefs.results,
    customer_types: customerTypes.results,
    insights: generateCustomerInsights(topCustomers.results, locations.results)
  };
}
async function getSellerAnalytics(db, startDate) {
  const since = startDate.toISOString();
  const submissionsResult = await db.prepare(`
        SELECT
            id,
            batch_id,
            status,
            contact_channel,
            contact_handle,
            contact_phone,
            city,
            created_at,
            reviewed_at,
            reviewed_by,
            items_json
        FROM sell_submissions
        WHERE datetime(created_at) >= datetime(?)
        ORDER BY datetime(created_at) DESC
    `).bind(since).all();
  const submissions = submissionsResult.results || [];
  if (submissions.length === 0) {
    return {
      summary: {
        total_submissions: 0,
        pending: 0,
        processed: 0,
        avg_items_per_submission: 0,
        avg_response_time_minutes: 0
      },
      breakdowns: {
        by_status: [],
        by_channel: [],
        by_city: []
      },
      trends: {
        top_categories: [],
        top_brands: [],
        submissions_over_time: []
      },
      recent_submissions: [],
      insights: ["No seller submissions recorded for the selected period"]
    };
  }
  const statusCounter = /* @__PURE__ */ new Map();
  const channelCounter = /* @__PURE__ */ new Map();
  const cityCounter = /* @__PURE__ */ new Map();
  const categoryCounter = /* @__PURE__ */ new Map();
  const brandCounter = /* @__PURE__ */ new Map();
  const submissionsOverTime = /* @__PURE__ */ new Map();
  let totalItems = 0;
  let totalPhotos = 0;
  let responseTotalMinutes = 0;
  let responseSamples = 0;
  const parsedSubmissions = submissions.map((sub) => {
    statusCounter.set(sub.status, (statusCounter.get(sub.status) || 0) + 1);
    channelCounter.set(sub.contact_channel, (channelCounter.get(sub.contact_channel) || 0) + 1);
    if (sub.city) {
      cityCounter.set(sub.city, (cityCounter.get(sub.city) || 0) + 1);
    }
    const submissionDate = new Date(sub.created_at);
    const dateKey = submissionDate.toISOString().split("T")[0];
    submissionsOverTime.set(dateKey, (submissionsOverTime.get(dateKey) || 0) + 1);
    let items = [];
    try {
      const parsed = JSON.parse(sub.items_json || "[]");
      if (Array.isArray(parsed)) {
        items = parsed;
      }
    } catch (parseError) {
      console.warn(`\u26A0\uFE0F Failed to parse items for sell submission ${sub.batch_id}:`, parseError.message);
    }
    items.forEach((item) => {
      if (item?.category) {
        categoryCounter.set(item.category, (categoryCounter.get(item.category) || 0) + 1);
      }
      if (item?.brand) {
        brandCounter.set(item.brand, (brandCounter.get(item.brand) || 0) + 1);
      }
      if (typeof item?.photoCount === "number") {
        totalPhotos += item.photoCount;
      }
    });
    totalItems += items.length;
    if (sub.reviewed_at) {
      const reviewed = new Date(sub.reviewed_at);
      const diffMinutes = Math.max(0, (reviewed.getTime() - submissionDate.getTime()) / (1e3 * 60));
      responseTotalMinutes += diffMinutes;
      responseSamples += 1;
    }
    return {
      ...sub,
      items,
      items_count: items.length
    };
  });
  const totalSubmissions = submissions.length;
  const pendingCount = statusCounter.get("pending") || 0;
  const processedCount = totalSubmissions - pendingCount;
  const avgItems = totalItems > 0 ? totalItems / totalSubmissions : 0;
  const avgPhotos = totalPhotos > 0 ? totalPhotos / totalSubmissions : 0;
  const avgResponseMinutes = responseSamples > 0 ? responseTotalMinutes / responseSamples : 0;
  const toSortedArray = /* @__PURE__ */ __name((map) => Array.from(map.entries()).map(([key, value]) => ({ key, value })).sort((a, b) => b.value - a.value), "toSortedArray");
  const insights = [];
  const topChannel = toSortedArray(channelCounter)[0];
  if (topChannel) {
    insights.push(`${topChannel.key} delivers the most seller leads (${topChannel.value} submissions).`);
  }
  const topCategory = toSortedArray(categoryCounter)[0];
  if (topCategory) {
    insights.push(`${topCategory.key} is the most submitted category this period.`);
  }
  if (avgResponseMinutes > 0) {
    insights.push(`Average review response time is ${avgResponseMinutes.toFixed(1)} minutes.`);
  } else {
    insights.push("Submissions are awaiting review; no response-time data yet.");
  }
  if (avgPhotos > 0) {
    insights.push(`Sellers include an average of ${avgPhotos.toFixed(1)} photo(s) per submission.`);
  }
  return {
    summary: {
      total_submissions: totalSubmissions,
      pending: pendingCount,
      processed: processedCount,
      processed_rate: totalSubmissions > 0 ? (processedCount / totalSubmissions * 100).toFixed(1) : "0.0",
      avg_items_per_submission: Number(avgItems.toFixed(2)),
      avg_photos_per_submission: Number(avgPhotos.toFixed(2)),
      avg_response_time_minutes: Number(avgResponseMinutes.toFixed(1))
    },
    breakdowns: {
      by_status: toSortedArray(statusCounter),
      by_channel: toSortedArray(channelCounter),
      by_city: toSortedArray(cityCounter)
    },
    trends: {
      top_categories: toSortedArray(categoryCounter).slice(0, 5),
      top_brands: toSortedArray(brandCounter).slice(0, 5),
      submissions_over_time: Array.from(submissionsOverTime.entries()).map(([date, count]) => ({ date, count })).sort((a, b) => a.date.localeCompare(b.date))
    },
    recent_submissions: parsedSubmissions.slice(0, 5).map((sub) => ({
      batch_id: sub.batch_id,
      status: sub.status,
      items_count: sub.items_count,
      contact_channel: sub.contact_channel,
      contact_handle: sub.contact_handle,
      city: sub.city,
      submitted_at: sub.created_at,
      reviewed_at: sub.reviewed_at
    })),
    insights
  };
}
function generateProductInsights(categories, hotProducts) {
  const insights = [];
  if (categories.length > 0) {
    const topCategory = categories[0];
    insights.push(`${topCategory.category} is your best performing category with ${topCategory.sold} sales`);
  }
  if (hotProducts.length > 0) {
    insights.push(`${hotProducts.length} products are getting high views - potential hot sellers`);
  }
  return insights;
}
function generateCustomerInsights(topCustomers, locations) {
  const insights = [];
  if (topCustomers.length > 0) {
    const vip = topCustomers[0];
    insights.push(`Top customer has placed ${vip.order_count} orders`);
  }
  if (locations.length > 0) {
    const topLocation = locations[0];
    insights.push(`${topLocation.city} has the most customers (${topLocation.customer_count})`);
  }
  return insights;
}
var init_analytics_v2 = __esm({
  "api/analytics-v2.js"() {
    init_functionsRoutes_0_5646645567038772();
    __name(onRequest3, "onRequest");
    __name(getOverviewAnalytics, "getOverviewAnalytics");
    __name(getProductAnalytics, "getProductAnalytics");
    __name(getCustomerAnalytics, "getCustomerAnalytics");
    __name(getSellerAnalytics, "getSellerAnalytics");
    __name(generateProductInsights, "generateProductInsights");
    __name(generateCustomerInsights, "generateCustomerInsights");
  }
});

// api/eircode-proxy.js
async function onRequest4(context) {
  const { request } = context;
  const url = new URL(request.url);
  const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type"
  };
  if (request.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }
  try {
    const action = url.searchParams.get("action") || "identity";
    if (action === "identity") {
      const response = await fetch("https://api-finder.eircode.ie/Latest/findergetidentity", {
        headers: {
          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
          "Referer": "https://finder.eircode.ie/",
          "Origin": "https://finder.eircode.ie"
        }
      });
      const data = await response.json();
      return new Response(JSON.stringify(data), {
        status: 200,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json"
        }
      });
    } else if (action === "search") {
      const key = url.searchParams.get("key");
      const address = url.searchParams.get("address");
      const language = url.searchParams.get("language") || "en";
      const geographicAddress = url.searchParams.get("geographicAddress") || "true";
      const clientVersion = url.searchParams.get("clientVersion") || "e98fe302";
      if (!key || !address) {
        return new Response(JSON.stringify({
          error: { code: 400, text: "Missing key or address parameter" }
        }), {
          status: 400,
          headers: {
            ...corsHeaders,
            "Content-Type": "application/json"
          }
        });
      }
      const apiUrl = `https://api-finder.eircode.ie/Latest/finderfindaddress?key=${key}&address=${encodeURIComponent(address)}&language=${language}&geographicAddress=${geographicAddress}&clientVersion=${clientVersion}`;
      const response = await fetch(apiUrl, {
        headers: {
          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
          "Referer": "https://finder.eircode.ie/",
          "Origin": "https://finder.eircode.ie"
        }
      });
      const data = await response.json();
      return new Response(JSON.stringify(data), {
        status: response.status,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json"
        }
      });
    }
    return new Response(JSON.stringify({
      error: { code: 400, text: "Invalid action. Use action=identity or action=search" }
    }), {
      status: 400,
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json"
      }
    });
  } catch (error) {
    return new Response(JSON.stringify({
      error: {
        code: 500,
        text: error.message
      }
    }), {
      status: 500,
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json"
      }
    });
  }
}
var init_eircode_proxy = __esm({
  "api/eircode-proxy.js"() {
    init_functionsRoutes_0_5646645567038772();
    __name(onRequest4, "onRequest");
  }
});

// ../public/js/taxonomy.js
function getSizesForCategory(category) {
  return SIZES[category] || [];
}
var SIZES;
var init_taxonomy = __esm({
  "../public/js/taxonomy.js"() {
    init_functionsRoutes_0_5646645567038772();
    SIZES = {
      "BN-CLOTHES": [
        "XS",
        "S",
        "M",
        "L",
        "XL"
      ],
      "PO-CLOTHES": [
        // Standard sizes
        "XS",
        "S",
        "M",
        "L",
        "XL",
        // Mixed top/bottom (±1 size difference only)
        "XS-TOP-S-BOTTOM",
        "S-TOP-XS-BOTTOM",
        "S-TOP-M-BOTTOM",
        "M-TOP-S-BOTTOM",
        "M-TOP-L-BOTTOM",
        "L-TOP-M-BOTTOM",
        "L-TOP-XL-BOTTOM",
        "XL-TOP-L-BOTTOM"
      ],
      "BN-SHOES": [
        "UK-6",
        "UK-6-5",
        "UK-7",
        "UK-7-5",
        "UK-8",
        "UK-8-5",
        "UK-9",
        "UK-9-5",
        "UK-10",
        "UK-10-5",
        "UK-11",
        "UK-11-5",
        "UK-12"
      ],
      "PO-SHOES": [
        "UK-6",
        "UK-6-5",
        "UK-7",
        "UK-7-5",
        "UK-8",
        "UK-8-5",
        "UK-9",
        "UK-9-5",
        "UK-10",
        "UK-10-5",
        "UK-11",
        "UK-11-5",
        "UK-12"
      ]
    };
    __name(getSizesForCategory, "getSizesForCategory");
  }
});

// api/products.js
async function onRequest5(context) {
  const { env, request } = context;
  const url = new URL(request.url);
  const debugMode = url.searchParams.has("debug");
  const includeHidden = url.searchParams.has("includeHidden");
  const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "GET, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type",
    "Content-Type": "application/json"
  };
  if (context.request.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }
  try {
    const accountId = env.CLOUDFLARE_ACCOUNT_ID;
    const apiToken = env.CLOUDFLARE_API_TOKEN || env.CLOUDFLARE_IMAGES_API_TOKEN;
    const deliveryHash = env.CLOUDFLARE_IMAGES_HASH || env.CLOUDFLARE_DELIVERY_HASH || env.IMAGES_DELIVERY_HASH;
    if (!accountId || !apiToken) {
      const missing = [
        !accountId && "CLOUDFLARE_ACCOUNT_ID",
        !apiToken && "CLOUDFLARE_API_TOKEN or CLOUDFLARE_IMAGES_API_TOKEN"
      ].filter(Boolean).join(", ");
      console.warn("\u26A0\uFE0F CF Images credentials not configured:", missing);
      return new Response(JSON.stringify({
        success: true,
        products: [],
        message: `CF Images not configured yet. Missing: ${missing}`,
        total: 0,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      }), {
        status: 200,
        headers: corsHeaders
      });
    }
    const apiUrl = `https://api.cloudflare.com/client/v4/accounts/${accountId}/images/v1`;
    const response = await fetch(apiUrl, {
      headers: {
        "Authorization": `Bearer ${apiToken}`,
        "Content-Type": "application/json"
      }
    });
    if (!response.ok) {
      throw new Error(`Cloudflare API error: ${response.status}`);
    }
    const data = await response.json();
    if (!data.success || !data.result) {
      throw new Error("Cloudflare API error");
    }
    let images = [];
    if (Array.isArray(data.result)) {
      images = data.result;
    } else if (data.result.images && Array.isArray(data.result.images)) {
      images = data.result.images;
    }
    let dbStatusMap = {};
    try {
      if (env.DB) {
        const dbProducts = await env.DB.prepare("SELECT cloudflare_image_id, status FROM products").all();
        if (dbProducts.success && dbProducts.results) {
          dbProducts.results.forEach((p) => {
            if (p.cloudflare_image_id) {
              dbStatusMap[p.cloudflare_image_id] = p.status;
            }
          });
        }
      }
    } catch (dbError) {
      console.warn("\u26A0\uFE0F Could not fetch statuses from D1:", dbError.message);
    }
    const products = images.map((image) => {
      try {
        const meta = image.meta || image.metadata || {};
        const filename = image.filename || "";
        let status = dbStatusMap[image.id] || (meta.status || "active").toLowerCase();
        if (!includeHidden && (status === "hidden" || status === "sold")) {
          return null;
        }
        let name = meta.name || meta.title || filename.replace(/\.[^/.]+$/, "").replace(/[-_]/g, " ");
        name = name.replace(/\d{8,}/g, "").trim();
        name = name.charAt(0).toUpperCase() + name.slice(1) || `SBS Item ${image.id.slice(0, 8)}`;
        let category = (meta.category || "").toUpperCase();
        if (!["BN-CLOTHES", "BN-SHOES", "PO-CLOTHES", "PO-SHOES"].includes(category)) {
          const lowerName = name.toLowerCase();
          if (lowerName.includes("shoe") || lowerName.includes("sneaker") || lowerName.includes("boot")) {
            category = "BN-SHOES";
          } else {
            category = "BN-CLOTHES";
          }
        }
        const condition = category.includes("BN") ? "Brand New" : "Pre-Owned";
        const sizes = getSizesForCategory(category);
        const stock = parseInt(meta.stock || meta.quantity || "1", 10);
        const inStock = stock > 0;
        const variants = image.variants || [];
        let imageUrl = variants.find((v) => v.includes("/public")) || variants.find((v) => v.includes("/standard")) || variants[0];
        let thumbUrl = variants.find((v) => v.includes("/thumb")) || variants[0];
        if (!imageUrl && deliveryHash) {
          imageUrl = `https://imagedelivery.net/${deliveryHash}/${image.id}/public`;
        }
        if (!thumbUrl && deliveryHash) {
          thumbUrl = `https://imagedelivery.net/${deliveryHash}/${image.id}/thumb`;
        }
        return {
          id: image.id,
          name,
          category,
          condition,
          brand: meta.brand || null,
          size: meta.size || null,
          status,
          sku: meta.sku || `SBS-${image.id.slice(0, 8)}`,
          imageUrl,
          image: imageUrl,
          thumbnail: thumbUrl,
          description: meta.description || `${condition} ${name}`,
          sizes,
          inStock,
          stock,
          featured: meta.featured === "true" || meta.featured === "1",
          uploaded: image.uploaded,
          uploadedAt: image.uploaded,
          ...debugMode && {
            rawMeta: meta,
            rawFilename: filename,
            variants
          }
        };
      } catch (err) {
        console.error(`Error parsing image ${image.id}:`, err);
        return null;
      }
    }).filter((p) => p !== null);
    const result = {
      success: true,
      products,
      total: products.length,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      source: "Cloudflare Images",
      note: "Edit products in Cloudflare Images Dashboard > Image > Metadata",
      ...debugMode && {
        deliveryHashUsed: Boolean(deliveryHash),
        imagesRetrieved: images.length,
        metadataFields: [
          "name - Product name",
          "price - Price (45.99 or 4599 cents)",
          "category - BN-CLOTHES, BN-SHOES, PO-CLOTHES, PO-SHOES",
          "brand - Brand name",
          "size - Size (M, L, UK-9, etc)",
          "condition - BN or PO",
          "status - active, hidden, sold",
          "sku - SKU code",
          "stock - Stock quantity",
          "featured - true/false",
          "description - Product description"
        ]
      }
    };
    return new Response(JSON.stringify(result), {
      headers: corsHeaders,
      status: 200
    });
  } catch (error) {
    console.error("\u274C SBS API Error:", error);
    console.error("\u274C Error stack:", error.stack);
    return new Response(JSON.stringify({
      success: false,
      error: "Products temporarily unavailable",
      message: error.message,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    }), {
      headers: corsHeaders,
      status: 500
    });
  }
}
var init_products2 = __esm({
  "api/products.js"() {
    init_functionsRoutes_0_5646645567038772();
    init_taxonomy();
    __name(onRequest5, "onRequest");
  }
});

// api/products-smart.js
async function onRequest6(context) {
  const { env, request } = context;
  const url = new URL(request.url);
  const useD1 = url.searchParams.has("smart") || true;
  const includeHidden = url.searchParams.has("includeHidden");
  const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "GET, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type",
    "Content-Type": "application/json"
  };
  if (request.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }
  try {
    console.log("\u{1F680} SBS API: Fetching smart inventory from D1...");
    const db = env.DB;
    const statusFilter = includeHidden ? "status IN ('active', 'hidden')" : "status = 'active'";
    const dbProducts = await db.prepare(`
            SELECT
                id,
                image_id,
                category,
                size,
                condition,
                status,
                quantity_available,
                quantity_sold,
                views_count,
                created_at,
                sold_at,
                days_to_sell,
                notes
            FROM products
            WHERE ${statusFilter}
            ORDER BY created_at DESC
        `).all();
    if (!dbProducts.results || dbProducts.results.length === 0) {
      console.log("\u26A0\uFE0F No products in D1, falling back to CF Images discovery...");
      return await discoverFromCloudflare(env, corsHeaders, includeHidden);
    }
    console.log(`\u2705 Found ${dbProducts.results.length} products in D1`);
    const accountId = env.CLOUDFLARE_ACCOUNT_ID;
    const apiToken = env.CLOUDFLARE_API_TOKEN || env.CLOUDFLARE_IMAGES_API_TOKEN;
    const deliveryHash = env.CLOUDFLARE_IMAGES_HASH || env.CLOUDFLARE_DELIVERY_HASH;
    let cfImagesMap = {};
    if (accountId && apiToken) {
      const apiUrl = `https://api.cloudflare.com/client/v4/accounts/${accountId}/images/v1`;
      const response = await fetch(apiUrl, {
        headers: {
          "Authorization": `Bearer ${apiToken}`,
          "Content-Type": "application/json"
        }
      });
      if (response.ok) {
        const data = await response.json();
        const images = Array.isArray(data.result) ? data.result : data.result?.images || [];
        images.forEach((img) => {
          cfImagesMap[img.id] = img;
        });
      }
    }
    const enrichedProducts = dbProducts.results.map((product) => {
      const cfImage = cfImagesMap[product.image_id];
      const meta = cfImage?.meta || cfImage?.metadata || {};
      const variants = cfImage?.variants || [];
      let imageUrl = variants.find((v) => v.includes("/public")) || variants[0];
      let thumbUrl = variants.find((v) => v.includes("/thumb")) || variants[0];
      if (!imageUrl && deliveryHash) {
        imageUrl = `https://imagedelivery.net/${deliveryHash}/${product.image_id}/public`;
        thumbUrl = `https://imagedelivery.net/${deliveryHash}/${product.image_id}/thumb`;
      }
      return {
        id: product.image_id,
        name: meta.name || "SBS Product",
        category: product.category,
        condition: product.condition,
        size: product.size,
        brand: meta.brand || null,
        status: product.status,
        inStock: product.quantity_available > 0,
        stock: product.quantity_available,
        sold_count: product.quantity_sold,
        views: product.views_count,
        imageUrl,
        image: imageUrl,
        thumbnail: thumbUrl,
        uploaded: product.created_at,
        // Analytics insights
        days_listed: product.sold_at ? product.days_to_sell : Math.floor((Date.now() - new Date(product.created_at).getTime()) / (1e3 * 60 * 60 * 24)),
        is_hot: product.views_count > 20 && !product.sold_at,
        is_fast_mover: product.days_to_sell && product.days_to_sell < 7,
        notes: product.notes
      };
    });
    return new Response(JSON.stringify({
      success: true,
      products: enrichedProducts,
      total: enrichedProducts.length,
      source: "D1 Smart Inventory",
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    }), {
      status: 200,
      headers: corsHeaders
    });
  } catch (error) {
    console.error("\u274C Products API error:", error);
    return new Response(JSON.stringify({
      success: false,
      error: error.message,
      products: [],
      total: 0,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    }), {
      status: 500,
      headers: corsHeaders
    });
  }
}
async function discoverFromCloudflare(env, corsHeaders, includeHidden) {
  const accountId = env.CLOUDFLARE_ACCOUNT_ID;
  const apiToken = env.CLOUDFLARE_API_TOKEN || env.CLOUDFLARE_IMAGES_API_TOKEN;
  const deliveryHash = env.CLOUDFLARE_IMAGES_HASH || env.CLOUDFLARE_DELIVERY_HASH;
  if (!accountId || !apiToken) {
    return new Response(JSON.stringify({
      success: true,
      products: [],
      message: "No products in D1, and CF Images not configured",
      total: 0,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    }), {
      status: 200,
      headers: corsHeaders
    });
  }
  const apiUrl = `https://api.cloudflare.com/client/v4/accounts/${accountId}/images/v1`;
  const response = await fetch(apiUrl, {
    headers: {
      "Authorization": `Bearer ${apiToken}`,
      "Content-Type": "application/json"
    }
  });
  if (!response.ok) {
    throw new Error(`Cloudflare API error: ${response.status}`);
  }
  const data = await response.json();
  const images = Array.isArray(data.result) ? data.result : data.result?.images || [];
  console.log(`\u{1F50D} Discovered ${images.length} images from CF, will auto-sync to D1...`);
  const products = images.map((image) => {
    const meta = image.meta || image.metadata || {};
    const variants = image.variants || [];
    let imageUrl = variants.find((v) => v.includes("/public")) || variants[0];
    let thumbUrl = variants.find((v) => v.includes("/thumb")) || variants[0];
    if (!imageUrl && deliveryHash) {
      imageUrl = `https://imagedelivery.net/${deliveryHash}/${image.id}/public`;
      thumbUrl = `https://imagedelivery.net/${deliveryHash}/${image.id}/thumb`;
    }
    const status = meta.status || "active";
    const showImage = includeHidden || status === "active";
    return showImage ? {
      id: image.id,
      name: meta.name || "SBS Product",
      category: meta.category || "BN-CLOTHES",
      condition: meta.condition || "Brand New",
      size: meta.size || null,
      brand: meta.brand || null,
      status,
      inStock: true,
      stock: parseInt(meta.stock || "1"),
      imageUrl,
      image: imageUrl,
      thumbnail: thumbUrl,
      uploaded: image.uploaded,
      source: "CF Images Discovery"
    } : null;
  }).filter(Boolean);
  let syncSummary = {
    upserted: 0,
    skipped: 0,
    errors: 0
  };
  if (products.length > 0 && env.DB) {
    const db = env.DB;
    for (const product of products) {
      try {
        const result = await db.prepare(`
                    INSERT INTO products (
                        image_id,
                        category,
                        size,
                        condition,
                        status,
                        quantity_total,
                        quantity_available,
                        created_at,
                        updated_at
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
                    ON CONFLICT(image_id) DO UPDATE SET
                        category = excluded.category,
                        size = excluded.size,
                        condition = excluded.condition,
                        status = excluded.status,
                        quantity_total = excluded.quantity_total,
                        quantity_available = excluded.quantity_available,
                        updated_at = datetime('now')
                `).bind(
          product.id,
          product.category,
          product.size,
          product.condition,
          product.status,
          product.stock || 1,
          product.inStock ? product.stock || 1 : 0
        ).run();
        if (result.meta.changes > 0) {
          syncSummary.upserted += 1;
        } else {
          syncSummary.skipped += 1;
        }
      } catch (syncError) {
        syncSummary.errors += 1;
        console.warn(`\u26A0\uFE0F Failed to sync product ${product.id} to D1:`, syncError.message);
      }
    }
  }
  return new Response(JSON.stringify({
    success: true,
    products,
    total: products.length,
    message: syncSummary.upserted > 0 ? `Discovered from CF Images and synced ${syncSummary.upserted} item(s) to D1` : "Discovered from CF Images (no D1 sync performed)",
    d1_sync: syncSummary,
    timestamp: (/* @__PURE__ */ new Date()).toISOString()
  }), {
    status: 200,
    headers: corsHeaders
  });
}
var init_products_smart = __esm({
  "api/products-smart.js"() {
    init_functionsRoutes_0_5646645567038772();
    init_taxonomy();
    __name(onRequest6, "onRequest");
    __name(discoverFromCloudflare, "discoverFromCloudflare");
  }
});

// (disabled):crypto
var require_crypto = __commonJS({
  "(disabled):crypto"() {
    init_functionsRoutes_0_5646645567038772();
  }
});

// ../node_modules/bcryptjs/index.js
function randomBytes(len) {
  try {
    return crypto.getRandomValues(new Uint8Array(len));
  } catch {
  }
  try {
    return import_crypto.default.randomBytes(len);
  } catch {
  }
  if (!randomFallback) {
    throw Error(
      "Neither WebCryptoAPI nor a crypto module is available. Use bcrypt.setRandomFallback to set an alternative"
    );
  }
  return randomFallback(len);
}
function setRandomFallback(random) {
  randomFallback = random;
}
function genSaltSync(rounds, seed_length) {
  rounds = rounds || GENSALT_DEFAULT_LOG2_ROUNDS;
  if (typeof rounds !== "number")
    throw Error(
      "Illegal arguments: " + typeof rounds + ", " + typeof seed_length
    );
  if (rounds < 4) rounds = 4;
  else if (rounds > 31) rounds = 31;
  var salt = [];
  salt.push("$2b$");
  if (rounds < 10) salt.push("0");
  salt.push(rounds.toString());
  salt.push("$");
  salt.push(base64_encode(randomBytes(BCRYPT_SALT_LEN), BCRYPT_SALT_LEN));
  return salt.join("");
}
function genSalt(rounds, seed_length, callback) {
  if (typeof seed_length === "function")
    callback = seed_length, seed_length = void 0;
  if (typeof rounds === "function") callback = rounds, rounds = void 0;
  if (typeof rounds === "undefined") rounds = GENSALT_DEFAULT_LOG2_ROUNDS;
  else if (typeof rounds !== "number")
    throw Error("illegal arguments: " + typeof rounds);
  function _async(callback2) {
    nextTick(function() {
      try {
        callback2(null, genSaltSync(rounds));
      } catch (err) {
        callback2(err);
      }
    });
  }
  __name(_async, "_async");
  if (callback) {
    if (typeof callback !== "function")
      throw Error("Illegal callback: " + typeof callback);
    _async(callback);
  } else
    return new Promise(function(resolve, reject) {
      _async(function(err, res) {
        if (err) {
          reject(err);
          return;
        }
        resolve(res);
      });
    });
}
function hashSync(password, salt) {
  if (typeof salt === "undefined") salt = GENSALT_DEFAULT_LOG2_ROUNDS;
  if (typeof salt === "number") salt = genSaltSync(salt);
  if (typeof password !== "string" || typeof salt !== "string")
    throw Error("Illegal arguments: " + typeof password + ", " + typeof salt);
  return _hash(password, salt);
}
function hash(password, salt, callback, progressCallback) {
  function _async(callback2) {
    if (typeof password === "string" && typeof salt === "number")
      genSalt(salt, function(err, salt2) {
        _hash(password, salt2, callback2, progressCallback);
      });
    else if (typeof password === "string" && typeof salt === "string")
      _hash(password, salt, callback2, progressCallback);
    else
      nextTick(
        callback2.bind(
          this,
          Error("Illegal arguments: " + typeof password + ", " + typeof salt)
        )
      );
  }
  __name(_async, "_async");
  if (callback) {
    if (typeof callback !== "function")
      throw Error("Illegal callback: " + typeof callback);
    _async(callback);
  } else
    return new Promise(function(resolve, reject) {
      _async(function(err, res) {
        if (err) {
          reject(err);
          return;
        }
        resolve(res);
      });
    });
}
function safeStringCompare(known, unknown) {
  var diff = known.length ^ unknown.length;
  for (var i = 0; i < known.length; ++i) {
    diff |= known.charCodeAt(i) ^ unknown.charCodeAt(i);
  }
  return diff === 0;
}
function compareSync(password, hash2) {
  if (typeof password !== "string" || typeof hash2 !== "string")
    throw Error("Illegal arguments: " + typeof password + ", " + typeof hash2);
  if (hash2.length !== 60) return false;
  return safeStringCompare(
    hashSync(password, hash2.substring(0, hash2.length - 31)),
    hash2
  );
}
function compare(password, hashValue, callback, progressCallback) {
  function _async(callback2) {
    if (typeof password !== "string" || typeof hashValue !== "string") {
      nextTick(
        callback2.bind(
          this,
          Error(
            "Illegal arguments: " + typeof password + ", " + typeof hashValue
          )
        )
      );
      return;
    }
    if (hashValue.length !== 60) {
      nextTick(callback2.bind(this, null, false));
      return;
    }
    hash(
      password,
      hashValue.substring(0, 29),
      function(err, comp) {
        if (err) callback2(err);
        else callback2(null, safeStringCompare(comp, hashValue));
      },
      progressCallback
    );
  }
  __name(_async, "_async");
  if (callback) {
    if (typeof callback !== "function")
      throw Error("Illegal callback: " + typeof callback);
    _async(callback);
  } else
    return new Promise(function(resolve, reject) {
      _async(function(err, res) {
        if (err) {
          reject(err);
          return;
        }
        resolve(res);
      });
    });
}
function getRounds(hash2) {
  if (typeof hash2 !== "string")
    throw Error("Illegal arguments: " + typeof hash2);
  return parseInt(hash2.split("$")[2], 10);
}
function getSalt(hash2) {
  if (typeof hash2 !== "string")
    throw Error("Illegal arguments: " + typeof hash2);
  if (hash2.length !== 60)
    throw Error("Illegal hash length: " + hash2.length + " != 60");
  return hash2.substring(0, 29);
}
function truncates(password) {
  if (typeof password !== "string")
    throw Error("Illegal arguments: " + typeof password);
  return utf8Length(password) > 72;
}
function utf8Length(string) {
  var len = 0, c = 0;
  for (var i = 0; i < string.length; ++i) {
    c = string.charCodeAt(i);
    if (c < 128) len += 1;
    else if (c < 2048) len += 2;
    else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
      ++i;
      len += 4;
    } else len += 3;
  }
  return len;
}
function utf8Array(string) {
  var offset = 0, c1, c2;
  var buffer = new Array(utf8Length(string));
  for (var i = 0, k = string.length; i < k; ++i) {
    c1 = string.charCodeAt(i);
    if (c1 < 128) {
      buffer[offset++] = c1;
    } else if (c1 < 2048) {
      buffer[offset++] = c1 >> 6 | 192;
      buffer[offset++] = c1 & 63 | 128;
    } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
      c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
      ++i;
      buffer[offset++] = c1 >> 18 | 240;
      buffer[offset++] = c1 >> 12 & 63 | 128;
      buffer[offset++] = c1 >> 6 & 63 | 128;
      buffer[offset++] = c1 & 63 | 128;
    } else {
      buffer[offset++] = c1 >> 12 | 224;
      buffer[offset++] = c1 >> 6 & 63 | 128;
      buffer[offset++] = c1 & 63 | 128;
    }
  }
  return buffer;
}
function base64_encode(b, len) {
  var off = 0, rs = [], c1, c2;
  if (len <= 0 || len > b.length) throw Error("Illegal len: " + len);
  while (off < len) {
    c1 = b[off++] & 255;
    rs.push(BASE64_CODE[c1 >> 2 & 63]);
    c1 = (c1 & 3) << 4;
    if (off >= len) {
      rs.push(BASE64_CODE[c1 & 63]);
      break;
    }
    c2 = b[off++] & 255;
    c1 |= c2 >> 4 & 15;
    rs.push(BASE64_CODE[c1 & 63]);
    c1 = (c2 & 15) << 2;
    if (off >= len) {
      rs.push(BASE64_CODE[c1 & 63]);
      break;
    }
    c2 = b[off++] & 255;
    c1 |= c2 >> 6 & 3;
    rs.push(BASE64_CODE[c1 & 63]);
    rs.push(BASE64_CODE[c2 & 63]);
  }
  return rs.join("");
}
function base64_decode(s, len) {
  var off = 0, slen = s.length, olen = 0, rs = [], c1, c2, c3, c4, o, code;
  if (len <= 0) throw Error("Illegal len: " + len);
  while (off < slen - 1 && olen < len) {
    code = s.charCodeAt(off++);
    c1 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    code = s.charCodeAt(off++);
    c2 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    if (c1 == -1 || c2 == -1) break;
    o = c1 << 2 >>> 0;
    o |= (c2 & 48) >> 4;
    rs.push(String.fromCharCode(o));
    if (++olen >= len || off >= slen) break;
    code = s.charCodeAt(off++);
    c3 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    if (c3 == -1) break;
    o = (c2 & 15) << 4 >>> 0;
    o |= (c3 & 60) >> 2;
    rs.push(String.fromCharCode(o));
    if (++olen >= len || off >= slen) break;
    code = s.charCodeAt(off++);
    c4 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    o = (c3 & 3) << 6 >>> 0;
    o |= c4;
    rs.push(String.fromCharCode(o));
    ++olen;
  }
  var res = [];
  for (off = 0; off < olen; off++) res.push(rs[off].charCodeAt(0));
  return res;
}
function _encipher(lr, off, P, S) {
  var n, l = lr[off], r = lr[off + 1];
  l ^= P[0];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[1];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[2];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[3];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[4];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[5];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[6];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[7];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[8];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[9];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[10];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[11];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[12];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[13];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[14];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[15];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[16];
  lr[off] = r ^ P[BLOWFISH_NUM_ROUNDS + 1];
  lr[off + 1] = l;
  return lr;
}
function _streamtoword(data, offp) {
  for (var i = 0, word = 0; i < 4; ++i)
    word = word << 8 | data[offp] & 255, offp = (offp + 1) % data.length;
  return { key: word, offp };
}
function _key(key, P, S) {
  var offset = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
  for (var i = 0; i < plen; i++)
    sw = _streamtoword(key, offset), offset = sw.offp, P[i] = P[i] ^ sw.key;
  for (i = 0; i < plen; i += 2)
    lr = _encipher(lr, 0, P, S), P[i] = lr[0], P[i + 1] = lr[1];
  for (i = 0; i < slen; i += 2)
    lr = _encipher(lr, 0, P, S), S[i] = lr[0], S[i + 1] = lr[1];
}
function _ekskey(data, key, P, S) {
  var offp = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
  for (var i = 0; i < plen; i++)
    sw = _streamtoword(key, offp), offp = sw.offp, P[i] = P[i] ^ sw.key;
  offp = 0;
  for (i = 0; i < plen; i += 2)
    sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), P[i] = lr[0], P[i + 1] = lr[1];
  for (i = 0; i < slen; i += 2)
    sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), S[i] = lr[0], S[i + 1] = lr[1];
}
function _crypt(b, salt, rounds, callback, progressCallback) {
  var cdata = C_ORIG.slice(), clen = cdata.length, err;
  if (rounds < 4 || rounds > 31) {
    err = Error("Illegal number of rounds (4-31): " + rounds);
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else throw err;
  }
  if (salt.length !== BCRYPT_SALT_LEN) {
    err = Error(
      "Illegal salt length: " + salt.length + " != " + BCRYPT_SALT_LEN
    );
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else throw err;
  }
  rounds = 1 << rounds >>> 0;
  var P, S, i = 0, j;
  if (typeof Int32Array === "function") {
    P = new Int32Array(P_ORIG);
    S = new Int32Array(S_ORIG);
  } else {
    P = P_ORIG.slice();
    S = S_ORIG.slice();
  }
  _ekskey(salt, b, P, S);
  function next() {
    if (progressCallback) progressCallback(i / rounds);
    if (i < rounds) {
      var start = Date.now();
      for (; i < rounds; ) {
        i = i + 1;
        _key(b, P, S);
        _key(salt, P, S);
        if (Date.now() - start > MAX_EXECUTION_TIME) break;
      }
    } else {
      for (i = 0; i < 64; i++)
        for (j = 0; j < clen >> 1; j++) _encipher(cdata, j << 1, P, S);
      var ret = [];
      for (i = 0; i < clen; i++)
        ret.push((cdata[i] >> 24 & 255) >>> 0), ret.push((cdata[i] >> 16 & 255) >>> 0), ret.push((cdata[i] >> 8 & 255) >>> 0), ret.push((cdata[i] & 255) >>> 0);
      if (callback) {
        callback(null, ret);
        return;
      } else return ret;
    }
    if (callback) nextTick(next);
  }
  __name(next, "next");
  if (typeof callback !== "undefined") {
    next();
  } else {
    var res;
    while (true) if (typeof (res = next()) !== "undefined") return res || [];
  }
}
function _hash(password, salt, callback, progressCallback) {
  var err;
  if (typeof password !== "string" || typeof salt !== "string") {
    err = Error("Invalid string / salt: Not a string");
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else throw err;
  }
  var minor, offset;
  if (salt.charAt(0) !== "$" || salt.charAt(1) !== "2") {
    err = Error("Invalid salt version: " + salt.substring(0, 2));
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else throw err;
  }
  if (salt.charAt(2) === "$") minor = String.fromCharCode(0), offset = 3;
  else {
    minor = salt.charAt(2);
    if (minor !== "a" && minor !== "b" && minor !== "y" || salt.charAt(3) !== "$") {
      err = Error("Invalid salt revision: " + salt.substring(2, 4));
      if (callback) {
        nextTick(callback.bind(this, err));
        return;
      } else throw err;
    }
    offset = 4;
  }
  if (salt.charAt(offset + 2) > "$") {
    err = Error("Missing salt rounds");
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else throw err;
  }
  var r1 = parseInt(salt.substring(offset, offset + 1), 10) * 10, r2 = parseInt(salt.substring(offset + 1, offset + 2), 10), rounds = r1 + r2, real_salt = salt.substring(offset + 3, offset + 25);
  password += minor >= "a" ? "\0" : "";
  var passwordb = utf8Array(password), saltb = base64_decode(real_salt, BCRYPT_SALT_LEN);
  function finish(bytes) {
    var res = [];
    res.push("$2");
    if (minor >= "a") res.push(minor);
    res.push("$");
    if (rounds < 10) res.push("0");
    res.push(rounds.toString());
    res.push("$");
    res.push(base64_encode(saltb, saltb.length));
    res.push(base64_encode(bytes, C_ORIG.length * 4 - 1));
    return res.join("");
  }
  __name(finish, "finish");
  if (typeof callback == "undefined")
    return finish(_crypt(passwordb, saltb, rounds));
  else {
    _crypt(
      passwordb,
      saltb,
      rounds,
      function(err2, bytes) {
        if (err2) callback(err2, null);
        else callback(null, finish(bytes));
      },
      progressCallback
    );
  }
}
function encodeBase64(bytes, length) {
  return base64_encode(bytes, length);
}
function decodeBase64(string, length) {
  return base64_decode(string, length);
}
var import_crypto, randomFallback, nextTick, BASE64_CODE, BASE64_INDEX, BCRYPT_SALT_LEN, GENSALT_DEFAULT_LOG2_ROUNDS, BLOWFISH_NUM_ROUNDS, MAX_EXECUTION_TIME, P_ORIG, S_ORIG, C_ORIG, bcryptjs_default;
var init_bcryptjs = __esm({
  "../node_modules/bcryptjs/index.js"() {
    init_functionsRoutes_0_5646645567038772();
    import_crypto = __toESM(require_crypto(), 1);
    randomFallback = null;
    __name(randomBytes, "randomBytes");
    __name(setRandomFallback, "setRandomFallback");
    __name(genSaltSync, "genSaltSync");
    __name(genSalt, "genSalt");
    __name(hashSync, "hashSync");
    __name(hash, "hash");
    __name(safeStringCompare, "safeStringCompare");
    __name(compareSync, "compareSync");
    __name(compare, "compare");
    __name(getRounds, "getRounds");
    __name(getSalt, "getSalt");
    __name(truncates, "truncates");
    nextTick = typeof process !== "undefined" && process && typeof process.nextTick === "function" ? typeof setImmediate === "function" ? setImmediate : process.nextTick : setTimeout;
    __name(utf8Length, "utf8Length");
    __name(utf8Array, "utf8Array");
    BASE64_CODE = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split("");
    BASE64_INDEX = [
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      0,
      1,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      -1,
      -1,
      -1,
      -1,
      -1
    ];
    __name(base64_encode, "base64_encode");
    __name(base64_decode, "base64_decode");
    BCRYPT_SALT_LEN = 16;
    GENSALT_DEFAULT_LOG2_ROUNDS = 10;
    BLOWFISH_NUM_ROUNDS = 16;
    MAX_EXECUTION_TIME = 100;
    P_ORIG = [
      608135816,
      2242054355,
      320440878,
      57701188,
      2752067618,
      698298832,
      137296536,
      3964562569,
      1160258022,
      953160567,
      3193202383,
      887688300,
      3232508343,
      3380367581,
      1065670069,
      3041331479,
      2450970073,
      2306472731
    ];
    S_ORIG = [
      3509652390,
      2564797868,
      805139163,
      3491422135,
      3101798381,
      1780907670,
      3128725573,
      4046225305,
      614570311,
      3012652279,
      134345442,
      2240740374,
      1667834072,
      1901547113,
      2757295779,
      4103290238,
      227898511,
      1921955416,
      1904987480,
      2182433518,
      2069144605,
      3260701109,
      2620446009,
      720527379,
      3318853667,
      677414384,
      3393288472,
      3101374703,
      2390351024,
      1614419982,
      1822297739,
      2954791486,
      3608508353,
      3174124327,
      2024746970,
      1432378464,
      3864339955,
      2857741204,
      1464375394,
      1676153920,
      1439316330,
      715854006,
      3033291828,
      289532110,
      2706671279,
      2087905683,
      3018724369,
      1668267050,
      732546397,
      1947742710,
      3462151702,
      2609353502,
      2950085171,
      1814351708,
      2050118529,
      680887927,
      999245976,
      1800124847,
      3300911131,
      1713906067,
      1641548236,
      4213287313,
      1216130144,
      1575780402,
      4018429277,
      3917837745,
      3693486850,
      3949271944,
      596196993,
      3549867205,
      258830323,
      2213823033,
      772490370,
      2760122372,
      1774776394,
      2652871518,
      566650946,
      4142492826,
      1728879713,
      2882767088,
      1783734482,
      3629395816,
      2517608232,
      2874225571,
      1861159788,
      326777828,
      3124490320,
      2130389656,
      2716951837,
      967770486,
      1724537150,
      2185432712,
      2364442137,
      1164943284,
      2105845187,
      998989502,
      3765401048,
      2244026483,
      1075463327,
      1455516326,
      1322494562,
      910128902,
      469688178,
      1117454909,
      936433444,
      3490320968,
      3675253459,
      1240580251,
      122909385,
      2157517691,
      634681816,
      4142456567,
      3825094682,
      3061402683,
      2540495037,
      79693498,
      3249098678,
      1084186820,
      1583128258,
      426386531,
      1761308591,
      1047286709,
      322548459,
      995290223,
      1845252383,
      2603652396,
      3431023940,
      2942221577,
      3202600964,
      3727903485,
      1712269319,
      422464435,
      3234572375,
      1170764815,
      3523960633,
      3117677531,
      1434042557,
      442511882,
      3600875718,
      1076654713,
      1738483198,
      4213154764,
      2393238008,
      3677496056,
      1014306527,
      4251020053,
      793779912,
      2902807211,
      842905082,
      4246964064,
      1395751752,
      1040244610,
      2656851899,
      3396308128,
      445077038,
      3742853595,
      3577915638,
      679411651,
      2892444358,
      2354009459,
      1767581616,
      3150600392,
      3791627101,
      3102740896,
      284835224,
      4246832056,
      1258075500,
      768725851,
      2589189241,
      3069724005,
      3532540348,
      1274779536,
      3789419226,
      2764799539,
      1660621633,
      3471099624,
      4011903706,
      913787905,
      3497959166,
      737222580,
      2514213453,
      2928710040,
      3937242737,
      1804850592,
      3499020752,
      2949064160,
      2386320175,
      2390070455,
      2415321851,
      4061277028,
      2290661394,
      2416832540,
      1336762016,
      1754252060,
      3520065937,
      3014181293,
      791618072,
      3188594551,
      3933548030,
      2332172193,
      3852520463,
      3043980520,
      413987798,
      3465142937,
      3030929376,
      4245938359,
      2093235073,
      3534596313,
      375366246,
      2157278981,
      2479649556,
      555357303,
      3870105701,
      2008414854,
      3344188149,
      4221384143,
      3956125452,
      2067696032,
      3594591187,
      2921233993,
      2428461,
      544322398,
      577241275,
      1471733935,
      610547355,
      4027169054,
      1432588573,
      1507829418,
      2025931657,
      3646575487,
      545086370,
      48609733,
      2200306550,
      1653985193,
      298326376,
      1316178497,
      3007786442,
      2064951626,
      458293330,
      2589141269,
      3591329599,
      3164325604,
      727753846,
      2179363840,
      146436021,
      1461446943,
      4069977195,
      705550613,
      3059967265,
      3887724982,
      4281599278,
      3313849956,
      1404054877,
      2845806497,
      146425753,
      1854211946,
      1266315497,
      3048417604,
      3681880366,
      3289982499,
      290971e4,
      1235738493,
      2632868024,
      2414719590,
      3970600049,
      1771706367,
      1449415276,
      3266420449,
      422970021,
      1963543593,
      2690192192,
      3826793022,
      1062508698,
      1531092325,
      1804592342,
      2583117782,
      2714934279,
      4024971509,
      1294809318,
      4028980673,
      1289560198,
      2221992742,
      1669523910,
      35572830,
      157838143,
      1052438473,
      1016535060,
      1802137761,
      1753167236,
      1386275462,
      3080475397,
      2857371447,
      1040679964,
      2145300060,
      2390574316,
      1461121720,
      2956646967,
      4031777805,
      4028374788,
      33600511,
      2920084762,
      1018524850,
      629373528,
      3691585981,
      3515945977,
      2091462646,
      2486323059,
      586499841,
      988145025,
      935516892,
      3367335476,
      2599673255,
      2839830854,
      265290510,
      3972581182,
      2759138881,
      3795373465,
      1005194799,
      847297441,
      406762289,
      1314163512,
      1332590856,
      1866599683,
      4127851711,
      750260880,
      613907577,
      1450815602,
      3165620655,
      3734664991,
      3650291728,
      3012275730,
      3704569646,
      1427272223,
      778793252,
      1343938022,
      2676280711,
      2052605720,
      1946737175,
      3164576444,
      3914038668,
      3967478842,
      3682934266,
      1661551462,
      3294938066,
      4011595847,
      840292616,
      3712170807,
      616741398,
      312560963,
      711312465,
      1351876610,
      322626781,
      1910503582,
      271666773,
      2175563734,
      1594956187,
      70604529,
      3617834859,
      1007753275,
      1495573769,
      4069517037,
      2549218298,
      2663038764,
      504708206,
      2263041392,
      3941167025,
      2249088522,
      1514023603,
      1998579484,
      1312622330,
      694541497,
      2582060303,
      2151582166,
      1382467621,
      776784248,
      2618340202,
      3323268794,
      2497899128,
      2784771155,
      503983604,
      4076293799,
      907881277,
      423175695,
      432175456,
      1378068232,
      4145222326,
      3954048622,
      3938656102,
      3820766613,
      2793130115,
      2977904593,
      26017576,
      3274890735,
      3194772133,
      1700274565,
      1756076034,
      4006520079,
      3677328699,
      720338349,
      1533947780,
      354530856,
      688349552,
      3973924725,
      1637815568,
      332179504,
      3949051286,
      53804574,
      2852348879,
      3044236432,
      1282449977,
      3583942155,
      3416972820,
      4006381244,
      1617046695,
      2628476075,
      3002303598,
      1686838959,
      431878346,
      2686675385,
      1700445008,
      1080580658,
      1009431731,
      832498133,
      3223435511,
      2605976345,
      2271191193,
      2516031870,
      1648197032,
      4164389018,
      2548247927,
      300782431,
      375919233,
      238389289,
      3353747414,
      2531188641,
      2019080857,
      1475708069,
      455242339,
      2609103871,
      448939670,
      3451063019,
      1395535956,
      2413381860,
      1841049896,
      1491858159,
      885456874,
      4264095073,
      4001119347,
      1565136089,
      3898914787,
      1108368660,
      540939232,
      1173283510,
      2745871338,
      3681308437,
      4207628240,
      3343053890,
      4016749493,
      1699691293,
      1103962373,
      3625875870,
      2256883143,
      3830138730,
      1031889488,
      3479347698,
      1535977030,
      4236805024,
      3251091107,
      2132092099,
      1774941330,
      1199868427,
      1452454533,
      157007616,
      2904115357,
      342012276,
      595725824,
      1480756522,
      206960106,
      497939518,
      591360097,
      863170706,
      2375253569,
      3596610801,
      1814182875,
      2094937945,
      3421402208,
      1082520231,
      3463918190,
      2785509508,
      435703966,
      3908032597,
      1641649973,
      2842273706,
      3305899714,
      1510255612,
      2148256476,
      2655287854,
      3276092548,
      4258621189,
      236887753,
      3681803219,
      274041037,
      1734335097,
      3815195456,
      3317970021,
      1899903192,
      1026095262,
      4050517792,
      356393447,
      2410691914,
      3873677099,
      3682840055,
      3913112168,
      2491498743,
      4132185628,
      2489919796,
      1091903735,
      1979897079,
      3170134830,
      3567386728,
      3557303409,
      857797738,
      1136121015,
      1342202287,
      507115054,
      2535736646,
      337727348,
      3213592640,
      1301675037,
      2528481711,
      1895095763,
      1721773893,
      3216771564,
      62756741,
      2142006736,
      835421444,
      2531993523,
      1442658625,
      3659876326,
      2882144922,
      676362277,
      1392781812,
      170690266,
      3921047035,
      1759253602,
      3611846912,
      1745797284,
      664899054,
      1329594018,
      3901205900,
      3045908486,
      2062866102,
      2865634940,
      3543621612,
      3464012697,
      1080764994,
      553557557,
      3656615353,
      3996768171,
      991055499,
      499776247,
      1265440854,
      648242737,
      3940784050,
      980351604,
      3713745714,
      1749149687,
      3396870395,
      4211799374,
      3640570775,
      1161844396,
      3125318951,
      1431517754,
      545492359,
      4268468663,
      3499529547,
      1437099964,
      2702547544,
      3433638243,
      2581715763,
      2787789398,
      1060185593,
      1593081372,
      2418618748,
      4260947970,
      69676912,
      2159744348,
      86519011,
      2512459080,
      3838209314,
      1220612927,
      3339683548,
      133810670,
      1090789135,
      1078426020,
      1569222167,
      845107691,
      3583754449,
      4072456591,
      1091646820,
      628848692,
      1613405280,
      3757631651,
      526609435,
      236106946,
      48312990,
      2942717905,
      3402727701,
      1797494240,
      859738849,
      992217954,
      4005476642,
      2243076622,
      3870952857,
      3732016268,
      765654824,
      3490871365,
      2511836413,
      1685915746,
      3888969200,
      1414112111,
      2273134842,
      3281911079,
      4080962846,
      172450625,
      2569994100,
      980381355,
      4109958455,
      2819808352,
      2716589560,
      2568741196,
      3681446669,
      3329971472,
      1835478071,
      660984891,
      3704678404,
      4045999559,
      3422617507,
      3040415634,
      1762651403,
      1719377915,
      3470491036,
      2693910283,
      3642056355,
      3138596744,
      1364962596,
      2073328063,
      1983633131,
      926494387,
      3423689081,
      2150032023,
      4096667949,
      1749200295,
      3328846651,
      309677260,
      2016342300,
      1779581495,
      3079819751,
      111262694,
      1274766160,
      443224088,
      298511866,
      1025883608,
      3806446537,
      1145181785,
      168956806,
      3641502830,
      3584813610,
      1689216846,
      3666258015,
      3200248200,
      1692713982,
      2646376535,
      4042768518,
      1618508792,
      1610833997,
      3523052358,
      4130873264,
      2001055236,
      3610705100,
      2202168115,
      4028541809,
      2961195399,
      1006657119,
      2006996926,
      3186142756,
      1430667929,
      3210227297,
      1314452623,
      4074634658,
      4101304120,
      2273951170,
      1399257539,
      3367210612,
      3027628629,
      1190975929,
      2062231137,
      2333990788,
      2221543033,
      2438960610,
      1181637006,
      548689776,
      2362791313,
      3372408396,
      3104550113,
      3145860560,
      296247880,
      1970579870,
      3078560182,
      3769228297,
      1714227617,
      3291629107,
      3898220290,
      166772364,
      1251581989,
      493813264,
      448347421,
      195405023,
      2709975567,
      677966185,
      3703036547,
      1463355134,
      2715995803,
      1338867538,
      1343315457,
      2802222074,
      2684532164,
      233230375,
      2599980071,
      2000651841,
      3277868038,
      1638401717,
      4028070440,
      3237316320,
      6314154,
      819756386,
      300326615,
      590932579,
      1405279636,
      3267499572,
      3150704214,
      2428286686,
      3959192993,
      3461946742,
      1862657033,
      1266418056,
      963775037,
      2089974820,
      2263052895,
      1917689273,
      448879540,
      3550394620,
      3981727096,
      150775221,
      3627908307,
      1303187396,
      508620638,
      2975983352,
      2726630617,
      1817252668,
      1876281319,
      1457606340,
      908771278,
      3720792119,
      3617206836,
      2455994898,
      1729034894,
      1080033504,
      976866871,
      3556439503,
      2881648439,
      1522871579,
      1555064734,
      1336096578,
      3548522304,
      2579274686,
      3574697629,
      3205460757,
      3593280638,
      3338716283,
      3079412587,
      564236357,
      2993598910,
      1781952180,
      1464380207,
      3163844217,
      3332601554,
      1699332808,
      1393555694,
      1183702653,
      3581086237,
      1288719814,
      691649499,
      2847557200,
      2895455976,
      3193889540,
      2717570544,
      1781354906,
      1676643554,
      2592534050,
      3230253752,
      1126444790,
      2770207658,
      2633158820,
      2210423226,
      2615765581,
      2414155088,
      3127139286,
      673620729,
      2805611233,
      1269405062,
      4015350505,
      3341807571,
      4149409754,
      1057255273,
      2012875353,
      2162469141,
      2276492801,
      2601117357,
      993977747,
      3918593370,
      2654263191,
      753973209,
      36408145,
      2530585658,
      25011837,
      3520020182,
      2088578344,
      530523599,
      2918365339,
      1524020338,
      1518925132,
      3760827505,
      3759777254,
      1202760957,
      3985898139,
      3906192525,
      674977740,
      4174734889,
      2031300136,
      2019492241,
      3983892565,
      4153806404,
      3822280332,
      352677332,
      2297720250,
      60907813,
      90501309,
      3286998549,
      1016092578,
      2535922412,
      2839152426,
      457141659,
      509813237,
      4120667899,
      652014361,
      1966332200,
      2975202805,
      55981186,
      2327461051,
      676427537,
      3255491064,
      2882294119,
      3433927263,
      1307055953,
      942726286,
      933058658,
      2468411793,
      3933900994,
      4215176142,
      1361170020,
      2001714738,
      2830558078,
      3274259782,
      1222529897,
      1679025792,
      2729314320,
      3714953764,
      1770335741,
      151462246,
      3013232138,
      1682292957,
      1483529935,
      471910574,
      1539241949,
      458788160,
      3436315007,
      1807016891,
      3718408830,
      978976581,
      1043663428,
      3165965781,
      1927990952,
      4200891579,
      2372276910,
      3208408903,
      3533431907,
      1412390302,
      2931980059,
      4132332400,
      1947078029,
      3881505623,
      4168226417,
      2941484381,
      1077988104,
      1320477388,
      886195818,
      18198404,
      3786409e3,
      2509781533,
      112762804,
      3463356488,
      1866414978,
      891333506,
      18488651,
      661792760,
      1628790961,
      3885187036,
      3141171499,
      876946877,
      2693282273,
      1372485963,
      791857591,
      2686433993,
      3759982718,
      3167212022,
      3472953795,
      2716379847,
      445679433,
      3561995674,
      3504004811,
      3574258232,
      54117162,
      3331405415,
      2381918588,
      3769707343,
      4154350007,
      1140177722,
      4074052095,
      668550556,
      3214352940,
      367459370,
      261225585,
      2610173221,
      4209349473,
      3468074219,
      3265815641,
      314222801,
      3066103646,
      3808782860,
      282218597,
      3406013506,
      3773591054,
      379116347,
      1285071038,
      846784868,
      2669647154,
      3771962079,
      3550491691,
      2305946142,
      453669953,
      1268987020,
      3317592352,
      3279303384,
      3744833421,
      2610507566,
      3859509063,
      266596637,
      3847019092,
      517658769,
      3462560207,
      3443424879,
      370717030,
      4247526661,
      2224018117,
      4143653529,
      4112773975,
      2788324899,
      2477274417,
      1456262402,
      2901442914,
      1517677493,
      1846949527,
      2295493580,
      3734397586,
      2176403920,
      1280348187,
      1908823572,
      3871786941,
      846861322,
      1172426758,
      3287448474,
      3383383037,
      1655181056,
      3139813346,
      901632758,
      1897031941,
      2986607138,
      3066810236,
      3447102507,
      1393639104,
      373351379,
      950779232,
      625454576,
      3124240540,
      4148612726,
      2007998917,
      544563296,
      2244738638,
      2330496472,
      2058025392,
      1291430526,
      424198748,
      50039436,
      29584100,
      3605783033,
      2429876329,
      2791104160,
      1057563949,
      3255363231,
      3075367218,
      3463963227,
      1469046755,
      985887462
    ];
    C_ORIG = [
      1332899944,
      1700884034,
      1701343084,
      1684370003,
      1668446532,
      1869963892
    ];
    __name(_encipher, "_encipher");
    __name(_streamtoword, "_streamtoword");
    __name(_key, "_key");
    __name(_ekskey, "_ekskey");
    __name(_crypt, "_crypt");
    __name(_hash, "_hash");
    __name(encodeBase64, "encodeBase64");
    __name(decodeBase64, "decodeBase64");
    bcryptjs_default = {
      setRandomFallback,
      genSaltSync,
      genSalt,
      hashSync,
      hash,
      compareSync,
      compare,
      getRounds,
      getSalt,
      truncates,
      encodeBase64,
      decodeBase64
    };
  }
});

// lib/email.js
var email_exports = {};
__export(email_exports, {
  cleanupExpiredTokens: () => cleanupExpiredTokens,
  createVerificationToken: () => createVerificationToken,
  sendVerificationEmail: () => sendVerificationEmail,
  verifyEmailToken: () => verifyEmailToken
});
function generateToken() {
  const bytes = crypto.getRandomValues(new Uint8Array(32));
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
async function hashToken3(token) {
  const data = enc.encode(token);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  return Array.from(new Uint8Array(hashBuffer)).map((b) => b.toString(16).padStart(2, "0")).join("");
}
async function sendVerificationEmail(email, token, siteUrl) {
  const verifyUrl = `${siteUrl}/verify-email.html?token=${token}`;
  const emailContent = {
    personalizations: [
      {
        to: [{ email }],
        dkim_domain: "thesbsofficial.com",
        dkim_selector: "mailchannels"
      }
    ],
    from: {
      email: "noreply@thesbsofficial.com",
      name: "SBS Unity"
    },
    subject: "\u2705 Verify Your SBS Account",
    content: [
      {
        type: "text/html",
        value: `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body style="margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; background: #0a0a0a; color: #ffffff;">
    <div style="max-width: 600px; margin: 0 auto; padding: 40px 20px;">
        <!-- Header -->
        <div style="text-align: center; margin-bottom: 40px;">
            <h1 style="color: #FFD700; font-size: 32px; font-weight: 900; margin: 0;">SBS</h1>
            <p style="color: #cccccc; margin: 8px 0 0 0;">Dublin's Premier Streetwear</p>
        </div>
        
        <!-- Main Content -->
        <div style="background: #1a1a1a; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 12px; padding: 32px;">
            <h2 style="color: #FFD700; font-size: 24px; margin: 0 0 16px 0;">Welcome to SBS Unity! \u{1F389}</h2>
            
            <p style="color: #ffffff; font-size: 16px; line-height: 1.6; margin: 0 0 24px 0;">
                Thanks for signing up! Please verify your email address to activate your account and start selling or shopping.
            </p>
            
            <!-- CTA Button -->
            <div style="text-align: center; margin: 32px 0;">
                <a href="${verifyUrl}" 
                   style="display: inline-block; background: #FFD700; color: #000000; padding: 16px 32px; border-radius: 8px; text-decoration: none; font-weight: 600; font-size: 16px;">
                    \u2705 Verify Email Address
                </a>
            </div>
            
            <p style="color: #cccccc; font-size: 14px; line-height: 1.6; margin: 24px 0 0 0;">
                Or copy and paste this link into your browser:
            </p>
            <div style="background: #0a0a0a; border: 1px solid rgba(255, 215, 0, 0.2); border-radius: 8px; padding: 12px; margin: 12px 0; word-break: break-all;">
                <code style="color: #FFD700; font-size: 14px;">${verifyUrl}</code>
            </div>
            
            <p style="color: #999999; font-size: 12px; line-height: 1.6; margin: 24px 0 0 0; border-top: 1px solid rgba(255, 255, 255, 0.1); padding-top: 16px;">
                \u23F0 This link expires in 24 hours.<br>
                \u{1F512} If you didn't create this account, you can safely ignore this email.
            </p>
        </div>
        
        <!-- Footer -->
        <div style="text-align: center; margin-top: 32px; color: #666666; font-size: 14px;">
            <p style="margin: 0 0 8px 0;">SBS Unity - Dublin's Premier Streetwear</p>
            <p style="margin: 0;">\u{1F4CD} Dublin, Ireland</p>
        </div>
    </div>
</body>
</html>
                `
      }
    ]
  };
  try {
    const response = await fetch("https://api.mailchannels.net/tx/v1/send", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(emailContent)
    });
    if (!response.ok) {
      const errorText = await response.text();
      console.error("MailChannels error:", errorText);
      console.error("MailChannels status:", response.status);
      throw new Error(`Email send failed: ${response.status} - ${errorText}`);
    }
    console.log("Email sent successfully via MailChannels");
    return { success: true };
  } catch (error) {
    console.error("Failed to send email:", error);
    console.error("Error details:", error.message);
    throw error;
  }
}
async function createVerificationToken(db, userId) {
  const token = generateToken();
  const tokenHash = await hashToken3(token);
  const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1e3).toISOString();
  await db.prepare(
    `INSERT INTO email_verification_tokens (user_id, token_hash, expires_at)
         VALUES (?, ?, ?)`
  ).bind(userId, tokenHash, expiresAt).run();
  return token;
}
async function verifyEmailToken(db, token) {
  const tokenHash = await hashToken3(token);
  const tokenRecord = await db.prepare(
    `SELECT * FROM email_verification_tokens 
         WHERE token_hash = ? AND used_at IS NULL AND expires_at > datetime('now')`
  ).bind(tokenHash).first();
  if (!tokenRecord) {
    return { success: false, error: "Invalid or expired token" };
  }
  await db.prepare(
    `UPDATE email_verification_tokens SET used_at = datetime('now')
         WHERE id = ?`
  ).bind(tokenRecord.id).run();
  await db.prepare(
    `UPDATE users SET email_verified = 1
         WHERE id = ?`
  ).bind(tokenRecord.user_id).run();
  const user = await db.prepare(
    `SELECT id, social_handle, email, first_name, last_name, email_verified
         FROM users WHERE id = ?`
  ).bind(tokenRecord.user_id).first();
  return { success: true, user };
}
async function cleanupExpiredTokens(db) {
  await db.prepare(
    `DELETE FROM email_verification_tokens 
         WHERE expires_at < datetime('now', '-7 days')`
  ).run();
}
var enc;
var init_email = __esm({
  "lib/email.js"() {
    init_functionsRoutes_0_5646645567038772();
    enc = new TextEncoder();
    __name(generateToken, "generateToken");
    __name(hashToken3, "hashToken");
    __name(sendVerificationEmail, "sendVerificationEmail");
    __name(createVerificationToken, "createVerificationToken");
    __name(verifyEmailToken, "verifyEmailToken");
    __name(cleanupExpiredTokens, "cleanupExpiredTokens");
  }
});

// lib/resend-wrapper.js
var resend_wrapper_exports = {};
__export(resend_wrapper_exports, {
  sendBeautifulVerificationEmail: () => sendBeautifulVerificationEmail
});
async function sendBeautifulVerificationEmail(apiKey, email, name, token, siteUrl) {
  const verifyUrl = `${siteUrl}/verify-email.html?token=${token}`;
  const firstName = name ? name.split(" ")[0] : "there";
  const html = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body style="margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);">
    <div style="max-width: 600px; margin: 0 auto; padding: 40px 20px;">
        <!-- Header -->
        <div style="text-align: center; margin-bottom: 40px;">
            <h1 style="color: #FFD700; font-size: 42px; font-weight: 900; margin: 0; text-shadow: 0 0 20px rgba(255, 215, 0, 0.3);">SBS</h1>
            <p style="color: #FFD700; margin: 8px 0 0 0; font-weight: 600; letter-spacing: 2px; font-size: 14px;">DUBLIN STREETWEAR</p>
        </div>
        
        <!-- Main Content -->
        <div style="background: rgba(26, 26, 26, 0.8); backdrop-filter: blur(10px); border: 2px solid rgba(255, 215, 0, 0.2); border-radius: 16px; padding: 40px; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);">
            <h2 style="color: #FFD700; font-size: 28px; margin: 0 0 20px 0; font-weight: 800;">Hey ${firstName}! \u{1F44B}</h2>
            
            <p style="color: #ffffff; font-size: 17px; line-height: 1.7; margin: 0 0 20px 0;">
                Welcome to the <strong style="color: #FFD700;">SBS crew</strong>! \u{1F680}
            </p>
            
            <p style="color: #ffffff; font-size: 17px; line-height: 1.7; margin: 0 0 30px 0;">
                We're stoked to have you. Just one quick step to unlock <strong style="color: #FFD700;">early drops</strong>, <strong style="color: #FFD700;">same-day Dublin</strong> delivery, and the best streetwear deals in Ireland.
            </p>
            
            <!-- CTA Button -->
            <div style="text-align: center; margin: 40px 0;">
                <a href="${verifyUrl}" 
                   style="display: inline-block; background: linear-gradient(135deg, #FFD700 0%, #FFC700 100%); color: #000000; padding: 18px 48px; border-radius: 30px; text-decoration: none; font-weight: 800; font-size: 18px; letter-spacing: 1px; box-shadow: 0 10px 30px rgba(255, 215, 0, 0.4); text-transform: uppercase; transition: all 0.3s ease;">
                    \u2705 VERIFY MY EMAIL
                </a>
            </p>
            
            <div style="background: rgba(10, 10, 10, 0.6); border-left: 4px solid #FFD700; border-radius: 8px; padding: 20px; margin: 30px 0;">
                <p style="color: #FFD700; font-size: 15px; margin: 0 0 12px 0; font-weight: 600;">
                    \u{1F517} Or copy this link:
                </p>
                <div style="background: #000000; border: 1px solid rgba(255, 215, 0, 0.3); border-radius: 8px; padding: 14px; word-break: break-all;">
                    <code style="color: #FFD700; font-size: 13px;">${verifyUrl}</code>
                </div>
            </div>
            
            <div style="border-top: 1px solid rgba(255, 215, 0, 0.2); margin-top: 32px; padding-top: 24px;">
                <p style="color: #999999; font-size: 14px; line-height: 1.6; margin: 0 0 12px 0;">
                    \u23F0 <strong>Link expires in 24 hours</strong> \u2014 verify soon!
                </p>
                <p style="color: #999999; font-size: 14px; line-height: 1.6; margin: 0;">
                    \u{1F512} Didn't sign up? No worries\u2014just ignore this email.
                </p>
            </div>
        </div>
        
        <!-- Footer -->
        <div style="text-align: center; margin-top: 40px; color: #666666; font-size: 14px; line-height: 1.6;">
            <p style="margin: 0 0 8px 0; font-weight: 600; color: #FFD700;">SBS</p>
            <p style="margin: 0 0 4px 0;">Dublin's Premier Streetwear Marketplace</p>
            <p style="margin: 0;">\u{1F4CD} Same-Day Dublin Delivery | \u{1F525} Authenticated Items</p>
        </div>
    </div>
</body>
</html>`;
  const response = await fetch("https://api.resend.com/emails", {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${apiKey}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      from: "SBS Team <noreply@thesbsofficial.com>",
      to: [email],
      subject: `Hey ${firstName}! Verify your email to unlock SBS \u{1F680}`,
      html
    })
  });
  if (!response.ok) {
    const error = await response.text();
    throw new Error(`Resend API error: ${response.status} - ${error}`);
  }
  return response.json();
}
var init_resend_wrapper = __esm({
  "lib/resend-wrapper.js"() {
    init_functionsRoutes_0_5646645567038772();
    __name(sendBeautifulVerificationEmail, "sendBeautifulVerificationEmail");
  }
});

// api/[[path]].js
function secHeaders(origin, env) {
  const allow = (env.ALLOWED_ORIGINS || "https://thesbsofficial.com,https://*.pages.dev").split(",").map((s) => s.trim());
  const allowed = allow.includes(origin) ? origin : allow[0];
  return {
    "Access-Control-Allow-Origin": allowed,
    "Access-Control-Allow-Credentials": "true",
    "Access-Control-Allow-Methods": "GET,POST,PUT,PATCH,DELETE,OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type,X-CSRF-Token",
    "X-Frame-Options": "DENY",
    "X-Content-Type-Options": "nosniff",
    "Referrer-Policy": "no-referrer",
    "Strict-Transport-Security": "max-age=31536000; includeSubDomains; preload",
    "Content-Security-Policy": "default-src 'self'; script-src 'self'; style-src 'self'; img-src 'self' data: blob:; connect-src 'self'; frame-ancestors 'none'"
  };
}
function getCookie(request, name) {
  const h = request.headers.get("Cookie") || "";
  const m = h.match(new RegExp(`(?:^|; )${name}=([^;]*)`));
  return m ? decodeURIComponent(m[1]) : null;
}
async function hashPassword(password, iterations = 1e5) {
  const salt = randB32();
  const key = await crypto.subtle.importKey("raw", enc2.encode(password), "PBKDF2", false, [
    "deriveBits"
  ]);
  const bits = await crypto.subtle.deriveBits(
    { name: "PBKDF2", hash: "SHA-256", salt, iterations },
    key,
    256
  );
  return {
    hash: b64(bits),
    salt: b64(salt),
    type: "pbkdf2",
    iterations
  };
}
async function verifyPassword2(password, user) {
  if (!user?.password_hash) return false;
  const hash2 = user.password_hash;
  const hashType = (user.password_hash_type || "").toLowerCase();
  if (hashType === "bcrypt" || hash2.startsWith("$2a$") || hash2.startsWith("$2b$") || hash2.startsWith("$2y$")) {
    try {
      return bcryptjs_default.compareSync(password, hash2);
    } catch (error) {
      console.error("Bcrypt verification failed:", error);
      return false;
    }
  }
  if (hashType === "sha256" || hexRegex.test(hash2) && !user.password_salt) {
    const digest = await crypto.subtle.digest("SHA-256", enc2.encode(password));
    const digestHex = Array.from(new Uint8Array(digest), (b) => b.toString(16).padStart(2, "0")).join("");
    return timingSafeEq(digestHex, hash2);
  }
  if (!user.password_salt) return false;
  const iters = Number(user.password_iterations || 1e5);
  const key = await crypto.subtle.importKey("raw", enc2.encode(password), "PBKDF2", false, [
    "deriveBits"
  ]);
  const bits = await crypto.subtle.deriveBits(
    { name: "PBKDF2", hash: "SHA-256", salt: b64toBuf(user.password_salt), iterations: iters },
    key,
    256
  );
  return timingSafeEq(b64(bits), hash2);
}
function issueCsrfSecret() {
  return b64(randB32());
}
async function csrfTokenFromSecret(secretB64) {
  const data = enc2.encode("csrf:" + secretB64);
  const digest = await crypto.subtle.digest("SHA-256", data);
  return b64(digest);
}
async function assertCsrf(request, session) {
  const hdr = request.headers.get("X-CSRF-Token");
  if (!hdr) return false;
  const expected = await csrfTokenFromSecret(session.csrf_secret);
  return timingSafeEq(expected, hdr);
}
async function createSession(env, userId, ip, ua) {
  const tokenRaw = b64(randB32());
  const csrfSecret = issueCsrfSecret();
  const now = /* @__PURE__ */ new Date();
  const exp = new Date(now.getTime() + 30 * 24 * 3600 * 1e3).toISOString();
  const tokenHash = await sha256b644(tokenRaw);
  let storedTokenValue = tokenHash;
  let hashedInserted = false;
  try {
    await env.DB.prepare(
      `INSERT INTO sessions (user_id, token, csrf_secret, expires_at, ip_address, user_agent)
       VALUES (?, ?, ?, ?, ?, ?)`
    ).bind(userId, tokenHash, csrfSecret, exp, ip || null, ua || null).run();
    hashedInserted = true;
  } catch (error) {
    storedTokenValue = tokenRaw;
    await env.DB.prepare(
      `INSERT INTO sessions (user_id, token, csrf_secret, expires_at, ip_address, user_agent)
       VALUES (?, ?, ?, ?, ?, ?)`
    ).bind(userId, storedTokenValue, csrfSecret, exp, ip || null, ua || null).run();
  }
  try {
    await env.DB.prepare(
      `INSERT INTO session_tokens (token_hash, user_id, expires_at) VALUES (?, ?, ?)`
    ).bind(tokenHash, userId, exp).run();
  } catch (err) {
    if (hashedInserted) {
      try {
        await env.DB.prepare(
          `UPDATE sessions SET token = ? WHERE user_id = ? AND token = ?`
        ).bind(tokenRaw, userId, storedTokenValue).run();
        storedTokenValue = tokenRaw;
      } catch (swapErr) {
        console.warn("Unable to swap hashed session token to plaintext:", swapErr);
      }
    }
  }
  return { token: tokenRaw, csrfSecret };
}
async function sha256b644(s) {
  const d = await crypto.subtle.digest("SHA-256", enc2.encode(s));
  return b64(d);
}
async function readSession(env, tokenRaw) {
  if (!tokenRaw) return null;
  try {
    const tokenHash = await sha256b644(tokenRaw);
    const tok = await env.DB.prepare(
      `SELECT user_id, expires_at FROM session_tokens WHERE token_hash = ? AND expires_at > datetime('now')`
    ).bind(tokenHash).first();
    if (tok?.user_id) {
      const row = await env.DB.prepare(
        `SELECT s.user_id, s.csrf_secret, s.expires_at, u.role, u.social_handle, u.first_name, u.last_name, u.email, u.is_allowlisted
           FROM sessions s
           JOIN users u ON u.id = s.user_id
          WHERE s.user_id = ? AND s.expires_at > datetime('now')
          ORDER BY s.created_at DESC LIMIT 1`
      ).bind(tok.user_id).first();
      if (row) return row;
    }
  } catch (error) {
    console.warn("Hashed session lookup unavailable, falling back to legacy schema:", error?.message || error);
  }
  try {
    const row = await env.DB.prepare(
      `SELECT s.user_id, s.csrf_secret, s.expires_at, u.role, u.social_handle, u.first_name, u.last_name, u.email,
              CASE
                WHEN EXISTS(SELECT 1 FROM admin_allowlist al WHERE al.user_id = u.id) THEN 1
                ELSE 0
              END AS is_allowlisted
         FROM sessions s
         JOIN users u ON u.id = s.user_id
        WHERE s.token = ? AND (s.expires_at IS NULL OR s.expires_at > datetime('now'))
        ORDER BY s.created_at DESC LIMIT 1`
    ).bind(tokenRaw).first();
    if (row) {
      return {
        ...row,
        csrf_secret: row.csrf_secret || tokenRaw
      };
    }
  } catch (legacyError) {
    console.error("Legacy session lookup failed:", legacyError);
  }
  return null;
}
async function destroySession(env, tokenRaw) {
  if (!tokenRaw) return;
  const tokenHash = await sha256b644(tokenRaw);
  try {
    await env.DB.prepare(`DELETE FROM session_tokens WHERE token_hash = ?`).bind(tokenHash).run();
  } catch (e) {
  }
  try {
    await env.DB.prepare(`DELETE FROM sessions WHERE token = ? OR token = ?`).bind(tokenRaw, tokenHash).run();
  } catch (err) {
    try {
      await env.DB.prepare(`DELETE FROM sessions WHERE token = ?`).bind(tokenRaw).run();
    } catch (legacyErr) {
      console.warn("Failed to remove session token:", legacyErr);
    }
  }
}
async function onRequest7(context) {
  const { request, env } = context;
  const { method } = request;
  const url = new URL(request.url);
  const path = url.pathname;
  const origin = request.headers.get("Origin") || "";
  const headers = secHeaders(origin, env);
  if (method === "OPTIONS") return new Response(null, { status: 204, headers });
  try {
    const sessionCookie = getCookie(request, COOKIE_NAME);
    const session = await readSession(env, sessionCookie);
    if (path === "/api/health" && method === "GET") {
      return json(
        { status: "healthy", ts: (/* @__PURE__ */ new Date()).toISOString(), service: "SBS Unity v3 API" },
        200,
        headers
      );
    }
    if (path === "/api/users/register" && method === "POST") {
      const body = await request.json();
      const allowed = [
        "social_handle",
        "email",
        "phone",
        "password",
        "first_name",
        "last_name",
        "address",
        "city",
        "eircode",
        "preferred_contact"
      ];
      for (const k of Object.keys(body)) {
        if (!allowed.includes(k)) return json({ success: false, error: `Unknown field: ${k}` }, 400, headers);
      }
      if (!body.social_handle || !body.password)
        return json({ success: false, error: "social_handle and password required" }, 400, headers);
      if (body.password.length < 6)
        return json({ success: false, error: "Password must be at least 6 characters" }, 400, headers);
      if (!/\d/.test(body.password))
        return json({ success: false, error: "Password must contain at least 1 number" }, 400, headers);
      const exists = await env.DB.prepare(
        "SELECT id FROM users WHERE social_handle = ? OR email = ?"
      ).bind(body.social_handle, body.email || null).first();
      if (exists) return json({ success: false, error: "User already exists" }, 409, headers);
      const { hash: hash2, salt, type, iterations } = await hashPassword(body.password);
      const emailVerified = body.email ? 0 : 1;
      const res = await env.DB.prepare(
        `INSERT INTO users
        (social_handle,email,phone,password_hash,password_salt,password_hash_type,password_iterations,
         first_name,last_name,address,city,eircode,preferred_contact,email_verified)
         VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)`
      ).bind(
        body.social_handle,
        body.email || null,
        body.phone || null,
        hash2,
        salt,
        type,
        iterations,
        body.first_name || null,
        body.last_name || null,
        body.address || null,
        body.city || null,
        body.eircode || null,
        body.preferred_contact || null,
        emailVerified
      ).run();
      const userId = res.meta?.last_row_id ?? null;
      if (body.email && userId) {
        try {
          const { createVerificationToken: createVerificationToken2, sendVerificationEmail: sendVerificationEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
          const token = await createVerificationToken2(env.DB, userId);
          const siteUrl = env.SITE_URL || "https://thesbsofficial.com";
          await sendVerificationEmail2(body.email, token, siteUrl);
          return json(
            {
              success: true,
              message: "Account created! Check your email to verify your account.",
              user_id: userId,
              email_sent: true
            },
            201,
            headers
          );
        } catch (emailError) {
          console.error("Failed to send verification email:", emailError);
          return json(
            {
              success: true,
              message: "Account created! Email verification will be sent shortly.",
              user_id: userId,
              email_sent: false
            },
            201,
            headers
          );
        }
      }
      return json(
        { success: true, message: "Account created successfully!", user_id: userId },
        201,
        headers
      );
    }
    if (path === "/api/users/login" && method === "POST") {
      const body = await request.json();
      const rawHandle = (body.social_handle || body.identifier || "").trim();
      const rawEmail = (body.email || "").trim().toLowerCase();
      const password = body.password;
      if (!rawHandle && !rawEmail || !password) {
        return json({ success: false, error: "Username/email and password required" }, 400, headers);
      }
      let user = null;
      if (rawEmail) {
        user = await env.DB.prepare("SELECT * FROM users WHERE LOWER(email) = LOWER(?)").bind(rawEmail).first();
      }
      if (!user && rawHandle) {
        const normalizedHandle = rawHandle.startsWith("@") ? rawHandle.slice(1) : rawHandle;
        user = await env.DB.prepare("SELECT * FROM users WHERE LOWER(social_handle) = LOWER(?)").bind(normalizedHandle).first();
      }
      if (!user) {
        return json({ success: false, error: "Invalid credentials" }, 401, headers);
      }
      if (!user || !await verifyPassword2(password, user))
        return json({ success: false, error: "Invalid credentials" }, 401, headers);
      if (user.email && user.email_verified === 0) {
        return json({
          success: false,
          error: "Please verify your email before logging in. Check your inbox for the verification link.",
          email_verification_required: true,
          email: user.email
        }, 403, headers);
      }
      const allowHandles = (env.ADMIN_ALLOWLIST_HANDLES || "").split(",").map((s) => s.trim());
      if (user.role !== "admin" && allowHandles.includes(user.social_handle)) {
        await env.DB.prepare("UPDATE users SET role='admin' WHERE id = ?").bind(user.id).run();
        user.role = "admin";
      }
      const ip = ipOf(request);
      const ua = request.headers.get("User-Agent") || "unknown";
      const { token, csrfSecret } = await createSession(env, user.id, ip, ua);
      const csrfToken = await csrfTokenFromSecret(csrfSecret);
      return json(
        {
          success: true,
          csrf_token: csrfToken,
          user: {
            id: user.id,
            social_handle: user.social_handle,
            email: user.email,
            role: user.role,
            first_name: user.first_name,
            last_name: user.last_name
          }
        },
        200,
        { ...headers, "Set-Cookie": setCookie(token) }
      );
    }
    if (path === "/api/users/logout" && method === "POST") {
      if (sessionCookie) await destroySession(env, sessionCookie);
      return json({ success: true }, 200, { ...headers, "Set-Cookie": clearCookie() });
    }
    if (path === "/api/verify-email" && method === "POST") {
      const body = await request.json();
      const { token } = body;
      if (!token) {
        return json({ success: false, error: "Token required" }, 400, headers);
      }
      try {
        const { verifyEmailToken: verifyEmailToken2 } = await Promise.resolve().then(() => (init_email(), email_exports));
        const result = await verifyEmailToken2(env.DB, token);
        if (!result.success) {
          return json({ success: false, error: result.error }, 400, headers);
        }
        return json({
          success: true,
          message: "Email verified successfully! You can now log in.",
          user: result.user
        }, 200, headers);
      } catch (error) {
        console.error("Email verification error:", error);
        return json({ success: false, error: "Verification failed" }, 500, headers);
      }
    }
    if (path === "/api/resend-verification" && method === "POST") {
      const body = await request.json();
      const { email } = body;
      if (!email) {
        return json({ success: false, error: "Email required" }, 400, headers);
      }
      const user = await env.DB.prepare(
        "SELECT id, email, email_verified, first_name FROM users WHERE email = ?"
      ).bind(email).first();
      if (!user) {
        return json({
          success: true,
          message: "If that email exists, a verification link has been sent."
        }, 200, headers);
      }
      if (user.email_verified === 1) {
        return json({
          success: false,
          error: "Email is already verified. You can log in now!"
        }, 400, headers);
      }
      try {
        const { createVerificationToken: createVerificationToken2 } = await Promise.resolve().then(() => (init_email(), email_exports));
        const { sendBeautifulVerificationEmail: sendBeautifulVerificationEmail2 } = await Promise.resolve().then(() => (init_resend_wrapper(), resend_wrapper_exports));
        const token = await createVerificationToken2(env.DB, user.id);
        const siteUrl = env.SITE_URL || "https://thesbsofficial.com";
        await sendBeautifulVerificationEmail2(
          env.RESEND_API_KEY,
          user.email,
          user.first_name || "there",
          token,
          siteUrl
        );
        return json({
          success: true,
          message: "Verification email sent! Check your inbox."
        }, 200, headers);
      } catch (error) {
        console.error("Resend verification error:", error);
        return json({
          success: false,
          error: "Failed to send verification email"
        }, 500, headers);
      }
    }
    if (path === "/api/test-email" && method === "POST") {
      const body = await request.json();
      const { email } = body;
      if (!email) {
        return json({ success: false, error: "Email required" }, 400, headers);
      }
      try {
        const { sendVerificationEmail: sendVerificationEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
        const testToken = "test-" + Math.random().toString(36).substring(2, 15);
        const siteUrl = env.SITE_URL || "https://thesbsofficial.com";
        const result = await sendVerificationEmail2(email, testToken, siteUrl);
        return json({
          success: true,
          message: `Test verification email sent to ${email}`,
          note: "This is a test email with a dummy token",
          mailChannelsResponse: result
        }, 200, headers);
      } catch (error) {
        console.error("Test email error:", error);
        console.error("Error stack:", error.stack);
        return json({
          success: false,
          error: "Failed to send test email",
          details: error.message,
          errorType: error.name,
          stack: error.stack
        }, 500, headers);
      }
    }
    if (path === "/api/products" && method === "GET") {
      try {
        return json(
          {
            success: true,
            products: [],
            message: "Products API ready - CF Images integration pending"
          },
          200,
          headers
        );
      } catch (error) {
        console.error("Products API error:", error);
        return json(
          {
            success: true,
            products: [],
            error: "Failed to fetch products"
          },
          200,
          headers
        );
      }
    }
    if (path === "/api/analytics/track" && method === "POST") {
      try {
        if (!env.DB) {
          console.error("Analytics: DB binding not available");
          return json({
            success: false,
            error: "Database not configured",
            hint: "DB binding missing in environment"
          }, 500, headers);
        }
        const body = await request.json();
        const events = body.events;
        if (!Array.isArray(events) || events.length === 0) {
          return json({ success: false, error: "No events to track" }, 400, headers);
        }
        console.log(`\u{1F4CA} Tracking ${events.length} events`);
        const ip = ipOf(request);
        const ua = request.headers.get("User-Agent") || "unknown";
        const userId = session?.user_id || null;
        const sessionId = session?.session_id || body.sessionId || null;
        let successCount = 0;
        const errors = [];
        for (const event of events) {
          try {
            const eventType = event.type || "unknown";
            const eventPath = event.path || null;
            const eventData = JSON.stringify(event.data || event || {});
            await env.DB.prepare(
              `INSERT INTO analytics_events (event_type, event_data, user_id, session_id, ip_address, user_agent, path)
               VALUES (?, ?, ?, ?, ?, ?, ?)`
            ).bind(
              eventType,
              eventData,
              userId,
              sessionId,
              ip,
              ua,
              eventPath
            ).run();
            successCount++;
          } catch (insertError) {
            console.error(`\u274C Failed to insert event ${event.type}:`, insertError.message);
            errors.push({
              event: event.type,
              error: insertError.message
            });
          }
        }
        if (successCount === events.length) {
          return json({ success: true, tracked: successCount }, 200, headers);
        } else {
          return json({
            success: true,
            tracked: successCount,
            failed: errors.length,
            errors: errors.slice(0, 3)
            // Only return first 3 errors
          }, 200, headers);
        }
      } catch (error) {
        console.error("\u274C Analytics tracking error:", error.message);
        return json({
          success: false,
          error: error.message || "Failed to track analytics"
        }, 500, headers);
      }
    }
    if (!session) return json({ success: false, error: "Unauthorized" }, 401, headers);
    if (path === "/api/users/me" && method === "GET") {
      const csrfToken = await csrfTokenFromSecret(session.csrf_secret);
      return json(
        {
          success: true,
          user: {
            id: session.user_id,
            social_handle: session.social_handle,
            email: session.email,
            role: session.role,
            first_name: session.first_name,
            last_name: session.last_name,
            is_allowlisted: session.is_allowlisted
          },
          csrf_token: csrfToken,
          is_admin: isAdmin(session)
        },
        200,
        headers
      );
    }
    if (path.startsWith("/api/admin/")) {
      if (!isAdmin(session)) return json({ success: false, error: "Forbidden" }, 403, headers);
      if (path === "/api/admin/menu" && method === "GET") {
        const html = `
          <section class="admin-menu">
            <h2>\u{1F39B}\uFE0F SBS Unity Admin</h2>
            <ul>
              <li><a href="/admin/" target="_blank">\u{1F3E0} Overview</a></li>
              <li><a href="/admin/inventory/" target="_blank">\u{1F4E6} Inventory</a></li>
              <li><a href="/admin/requests/" target="_blank">\u{1F4CB} Requests</a></li>
              <li><a href="/admin/customers/" target="_blank">\u{1F465} Customers</a></li>
              <li><a href="/admin/data/" target="_blank">\u{1F4BE} Data</a></li>
              <li><a href="/admin/analytics.html" target="_blank">\u{1F4CA} Logs & Analytics</a></li>
              <li><a href="/admin/security/" target="_blank">\u{1F512} Security</a></li>
              <li><a href="/admin/audit/" target="_blank">\u{1F4DC} Audit</a></li>
            </ul>
            <hr style="margin: 20px 0; border-color: #333;">
            <h3 style="font-size: 14px; color: #999; margin-bottom: 10px;">\u2699\uFE0F Utilities</h3>
            <ul>
              <li><a href="/admin/system-check.html" target="_blank">\u{1F50D} System Check</a></li>
              <li><a href="/admin/status.html" target="_blank">\uFFFD API Status</a></li>
              <li><a href="/admin/diagnostic.html" target="_blank">\u{1F6E0}\uFE0F Diagnostics</a></li>
              <li><button id="runBoard07" type="button">\u26A1 Quick Diagnostics</button></li>
            </ul>
          </section>`;
        return new Response(html, { status: 200, headers: { "Content-Type": "text/html", ...headers } });
      }
      if (path === "/api/admin/tests/board07" && method === "GET") {
        const tables = await env.DB.prepare(
          "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name"
        ).all();
        return json(
          {
            success: true,
            checks: [
              { name: "tables_present", passed: true, details: tables.results?.map((r) => r.name) || [] }
            ],
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          },
          200,
          headers
        );
      }
      if (path === "/api/admin/analytics-dashboard" && method === "GET") {
        try {
          const totalUsers = await env.DB.prepare("SELECT COUNT(*) as count FROM users").first();
          const activeUsers = await env.DB.prepare("SELECT COUNT(*) as count FROM users WHERE is_active = 1").first();
          const newUsersToday = await env.DB.prepare(
            "SELECT COUNT(*) as count FROM users WHERE DATE(created_at) = DATE('now')"
          ).first();
          const totalProducts = await env.DB.prepare("SELECT COUNT(*) as count FROM products").first();
          const activeProducts = await env.DB.prepare(
            "SELECT COUNT(*) as count FROM products WHERE status = 'active'"
          ).first();
          const soldProducts = await env.DB.prepare(
            "SELECT COUNT(*) as count FROM products WHERE status = 'sold'"
          ).first();
          const topProducts = await env.DB.prepare(
            "SELECT id, brand, category, size, views_count, price FROM products ORDER BY views_count DESC LIMIT 5"
          ).all();
          const totalOrders = await env.DB.prepare("SELECT COUNT(*) as count FROM orders").first();
          const pendingOrders = await env.DB.prepare(
            "SELECT COUNT(*) as count FROM orders WHERE status = 'pending'"
          ).first();
          const completedOrders = await env.DB.prepare(
            "SELECT COUNT(*) as count FROM orders WHERE status = 'completed'"
          ).first();
          const totalRevenue = await env.DB.prepare(
            "SELECT COALESCE(SUM(total), 0) as total FROM orders WHERE status = 'completed'"
          ).first();
          const recentOrders = await env.DB.prepare(
            "SELECT order_number, total, status, created_at FROM orders ORDER BY created_at DESC LIMIT 10"
          ).all();
          const totalSellCases = await env.DB.prepare("SELECT COUNT(*) as count FROM sell_cases").first();
          const pendingSellCases = await env.DB.prepare(
            "SELECT COUNT(*) as count FROM sell_cases WHERE status = 'pending'"
          ).first();
          let analyticsEvents = { results: [] };
          let eventCounts = {};
          try {
            analyticsEvents = await env.DB.prepare(
              "SELECT event_type, COUNT(*) as count FROM analytics_events GROUP BY event_type ORDER BY count DESC LIMIT 10"
            ).all();
            analyticsEvents.results.forEach((row) => {
              eventCounts[row.event_type] = row.count;
            });
          } catch (e) {
            console.log("Analytics events table not yet available:", e.message);
          }
          const categoryPerformance = await env.DB.prepare(`
            SELECT 
              category,
              COUNT(*) as total,
              SUM(CASE WHEN status = 'active' THEN 1 ELSE 0 END) as active,
              SUM(CASE WHEN status = 'sold' THEN 1 ELSE 0 END) as sold,
              COALESCE(SUM(views_count), 0) as total_views
            FROM products
            GROUP BY category
            ORDER BY total DESC
          `).all();
          return json({
            success: true,
            dashboard: {
              users: {
                total: totalUsers.count,
                active: activeUsers.count,
                new_today: newUsersToday.count
              },
              products: {
                total: totalProducts.count,
                active: activeProducts.count,
                sold: soldProducts.count,
                top_products: topProducts.results || []
              },
              orders: {
                total: totalOrders.count,
                pending: pendingOrders.count,
                completed: completedOrders.count,
                revenue: totalRevenue.total || 0,
                recent: recentOrders.results || []
              },
              sell_cases: {
                total: totalSellCases.count,
                pending: pendingSellCases.count
              },
              events: eventCounts,
              categories: categoryPerformance.results || []
            },
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          }, 200, headers);
        } catch (error) {
          console.error("Dashboard analytics error:", error);
          return json({
            success: false,
            error: "Failed to load dashboard analytics",
            details: error.message
          }, 500, headers);
        }
      }
      if (path === "/api/admin/analytics-events" && method === "GET") {
        try {
          const { results } = await env.DB.prepare(
            "SELECT id, event_type, path, user_id, timestamp, event_data FROM analytics_events ORDER BY timestamp DESC LIMIT 100"
          ).all();
          return json({ success: true, events: results || [] }, 200, headers);
        } catch (error) {
          return json({
            success: true,
            events: [],
            message: "Analytics events table not yet created. Events will appear after first deployment with schema."
          }, 200, headers);
        }
      }
      if (path === "/api/admin/users" && method === "GET") {
        try {
          const { results } = await env.DB.prepare(`
            SELECT 
              id,
              social_handle,
              email,
              email_verified,
              first_name,
              last_name,
              role,
              is_active,
              is_allowlisted,
              created_at,
              last_login
            FROM users
            ORDER BY created_at DESC
          `).all();
          const activeSessions = await env.DB.prepare(`
            SELECT user_id, COUNT(*) as session_count
            FROM sessions
            WHERE expires_at > datetime('now')
            GROUP BY user_id
          `).all();
          const sessionMap = {};
          activeSessions.results?.forEach((s) => {
            sessionMap[s.user_id] = s.session_count;
          });
          const users = results.map((user) => ({
            ...user,
            active_sessions: sessionMap[user.id] || 0,
            is_logged_in: (sessionMap[user.id] || 0) > 0,
            full_name: [user.first_name, user.last_name].filter(Boolean).join(" ") || "N/A"
          }));
          return json({
            success: true,
            users,
            total: users.length,
            active: users.filter((u) => u.is_active === 1).length,
            logged_in: users.filter((u) => u.is_logged_in).length,
            verified: users.filter((u) => u.email_verified === 1).length,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          }, 200, headers);
        } catch (error) {
          console.error("Users management error:", error);
          return json({
            success: false,
            error: "Failed to fetch users",
            details: error.message
          }, 500, headers);
        }
      }
      if (path === "/api/admin/health-check" && method === "GET") {
        const checks = [];
        let totalChecks = 0;
        let passedChecks = 0;
        totalChecks++;
        try {
          const tables = await env.DB.prepare(
            "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name"
          ).all();
          const requiredTables = ["users", "sessions", "session_tokens", "orders", "products", "sell_cases"];
          const foundTables = tables.results?.map((r) => r.name) || [];
          const missingTables = requiredTables.filter((t) => !foundTables.includes(t));
          if (missingTables.length === 0) {
            passedChecks++;
            checks.push({
              name: "D1 Database",
              status: "\u2713 PASS",
              details: `All ${requiredTables.length} required tables present`,
              tables: foundTables
            });
          } else {
            checks.push({
              name: "D1 Database",
              status: "\u2717 FAIL",
              details: `Missing tables: ${missingTables.join(", ")}`,
              tables: foundTables
            });
          }
        } catch (dbError) {
          checks.push({
            name: "D1 Database",
            status: "\u2717 FAIL",
            error: dbError.message
          });
        }
        const envChecks = [
          { name: "CLOUDFLARE_ACCOUNT_ID", value: env.CLOUDFLARE_ACCOUNT_ID },
          { name: "SITE_URL", value: env.SITE_URL },
          { name: "ADMIN_ALLOWLIST_HANDLES", value: env.ADMIN_ALLOWLIST_HANDLES }
        ];
        envChecks.forEach((check) => {
          totalChecks++;
          if (check.value) {
            passedChecks++;
            checks.push({
              name: check.name,
              status: "\u2713 PASS",
              details: "Configured",
              value: check.value
            });
          } else {
            checks.push({
              name: check.name,
              status: "\u2717 FAIL",
              details: "Not configured"
            });
          }
        });
        const secretChecks = [
          { name: "CLOUDFLARE_API_TOKEN", value: env.CLOUDFLARE_API_TOKEN },
          { name: "CLOUDFLARE_IMAGES_API_TOKEN", value: env.CLOUDFLARE_IMAGES_API_TOKEN },
          { name: "CLOUDFLARE_IMAGES_HASH", value: env.CLOUDFLARE_IMAGES_HASH }
        ];
        secretChecks.forEach((check) => {
          totalChecks++;
          if (check.value) {
            passedChecks++;
            checks.push({
              name: check.name,
              status: "\u2713 PASS",
              details: "Secret configured (encrypted)"
            });
          } else {
            checks.push({
              name: check.name,
              status: "\u26A0 WARN",
              details: "Not configured (optional)"
            });
          }
        });
        const bindingChecks = [
          { name: "DB (D1)", binding: env.DB, type: "D1 Database" },
          { name: "PRODUCT_IMAGES (R2)", binding: env.PRODUCT_IMAGES, type: "R2 Bucket" },
          { name: "USER_UPLOADS (R2)", binding: env.USER_UPLOADS, type: "R2 Bucket" }
        ];
        bindingChecks.forEach((check) => {
          totalChecks++;
          if (check.binding) {
            passedChecks++;
            checks.push({
              name: check.name,
              status: "\u2713 PASS",
              details: `${check.type} bound`,
              type: check.type
            });
          } else {
            checks.push({
              name: check.name,
              status: "\u2717 FAIL",
              details: `${check.type} not bound`
            });
          }
        });
        totalChecks++;
        const hasImagesConfig = env.CLOUDFLARE_ACCOUNT_ID && (env.CLOUDFLARE_API_TOKEN || env.CLOUDFLARE_IMAGES_API_TOKEN);
        if (hasImagesConfig) {
          passedChecks++;
          checks.push({
            name: "Cloudflare Images API",
            status: "\u2713 PASS",
            details: "Account ID and API token configured",
            ready: true
          });
        } else {
          checks.push({
            name: "Cloudflare Images API",
            status: "\u2717 FAIL",
            details: "Missing account ID or API token"
          });
        }
        const successRate = (passedChecks / totalChecks * 100).toFixed(1);
        const overallStatus = passedChecks === totalChecks ? "HEALTHY" : passedChecks >= totalChecks * 0.8 ? "DEGRADED" : "UNHEALTHY";
        return json({
          success: true,
          status: overallStatus,
          summary: {
            total_checks: totalChecks,
            passed: passedChecks,
            failed: totalChecks - passedChecks,
            success_rate: `${successRate}%`
          },
          checks,
          environment: {
            production_branch: "MAIN",
            compatibility_date: "2024-09-30",
            project: "unity-v3"
          },
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        }, 200, headers);
      }
      if (path === "/api/admin/upload-image" && method === "POST") {
        try {
          const accountId = env.CLOUDFLARE_ACCOUNT_ID;
          const apiToken = env.CLOUDFLARE_API_TOKEN || env.CLOUDFLARE_IMAGES_API_TOKEN;
          if (!accountId || !apiToken) {
            return json({ success: false, error: "Missing CF Images credentials" }, 500, headers);
          }
          let formData;
          try {
            formData = await request.formData();
          } catch (parseError) {
            return json({ success: false, error: "Invalid form data format" }, 400, headers);
          }
          const file = formData.get("file");
          const filename = formData.get("filename");
          const metadata = formData.get("metadata");
          if (!file) {
            return json({ success: false, error: "File is required" }, 400, headers);
          }
          if (!file.type || !file.type.startsWith("image/")) {
            return json({ success: false, error: "File must be an image" }, 400, headers);
          }
          const cfFormData = new FormData();
          cfFormData.append("file", file);
          if (metadata) {
            const meta = JSON.parse(metadata);
            cfFormData.append("metadata", JSON.stringify(meta));
          }
          if (filename) {
            const cleanFilename = filename.replace(/\.(jpeg|jpg|png|webp)$/i, "").toLowerCase();
            cfFormData.append("id", cleanFilename);
          }
          const uploadUrl = `https://api.cloudflare.com/client/v4/accounts/${accountId}/images/v1`;
          const uploadResponse = await fetch(uploadUrl, {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${apiToken}`
            },
            body: cfFormData
          });
          const result = await uploadResponse.json();
          if (!uploadResponse.ok || !result.success) {
            console.error("CF Images upload failed:", result);
            console.error("Attempted filename:", filename);
            return json({
              success: false,
              error: result.errors?.[0]?.message || "Upload failed",
              details: result,
              attemptedFilename: filename
            }, uploadResponse.status, headers);
          }
          return json({
            success: true,
            image: result.result,
            message: "Image uploaded successfully",
            uploadedId: result.result?.id,
            requestedFilename: filename
          }, 200, headers);
        } catch (err) {
          console.error("Upload error:", err);
          return json({
            success: false,
            error: "Upload failed",
            details: err.message
          }, 500, headers);
        }
      }
      if (path === "/api/admin/update-image-metadata" && method === "PATCH") {
        try {
          const accountId = env.CLOUDFLARE_ACCOUNT_ID;
          const apiToken = env.CLOUDFLARE_API_TOKEN || env.CLOUDFLARE_IMAGES_API_TOKEN;
          if (!accountId || !apiToken) {
            return json({ success: false, error: "Missing CF Images credentials" }, 500, headers);
          }
          const body = await request.json();
          const imageId = body.imageId || body.id;
          const metadata = body.metadata;
          if (!imageId) {
            return json({ success: false, error: "Image ID required" }, 400, headers);
          }
          if (!metadata) {
            return json({ success: false, error: "Metadata required" }, 400, headers);
          }
          const updateUrl = `https://api.cloudflare.com/client/v4/accounts/${accountId}/images/v1/${imageId}`;
          const updateResponse = await fetch(updateUrl, {
            method: "PATCH",
            headers: {
              "Authorization": `Bearer ${apiToken}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({ metadata })
          });
          const result = await updateResponse.json();
          if (!updateResponse.ok || !result.success) {
            console.error("CF Images metadata update failed:", result);
            return json({
              success: false,
              error: result.errors?.[0]?.message || "Metadata update failed",
              details: result
            }, updateResponse.status, headers);
          }
          return json({
            success: true,
            message: "Metadata updated successfully",
            imageId,
            metadata
          }, 200, headers);
        } catch (err) {
          console.error("Update metadata error:", err);
          return json({
            success: false,
            error: "Metadata update failed",
            details: err.message
          }, 500, headers);
        }
      }
      if (path === "/api/admin/delete-image" && (method === "DELETE" || method === "POST")) {
        try {
          const accountId = env.CLOUDFLARE_ACCOUNT_ID;
          const apiToken = env.CLOUDFLARE_API_TOKEN || env.CLOUDFLARE_IMAGES_API_TOKEN;
          if (!accountId || !apiToken) {
            return json({ success: false, error: "Missing CF Images credentials" }, 500, headers);
          }
          let body;
          try {
            body = await request.json();
          } catch (parseError) {
            return json({ success: false, error: "Invalid JSON format" }, 400, headers);
          }
          const imageId = body.imageId || body.id;
          if (!imageId) {
            return json({ success: false, error: "imageId is required" }, 400, headers);
          }
          if (typeof imageId !== "string" || imageId.trim().length === 0) {
            return json({ success: false, error: "imageId must be a non-empty string" }, 400, headers);
          }
          const deleteUrl = `https://api.cloudflare.com/client/v4/accounts/${accountId}/images/v1/${imageId}`;
          const deleteResponse = await fetch(deleteUrl, {
            method: "DELETE",
            headers: {
              "Authorization": `Bearer ${apiToken}`
            }
          });
          const result = await deleteResponse.json();
          if (!deleteResponse.ok || !result.success) {
            console.error("CF Images delete failed:", result);
            return json({
              success: false,
              error: result.errors?.[0]?.message || "Delete failed",
              details: result
            }, deleteResponse.status, headers);
          }
          return json({
            success: true,
            message: "Image deleted successfully",
            imageId
          }, 200, headers);
        } catch (err) {
          console.error("Delete error:", err);
          return json({
            success: false,
            error: "Delete failed",
            details: err.message
          }, 500, headers);
        }
      }
    }
    if (path === "/api/orders" && method === "POST") {
      if (!session?.user_id) return json({ success: false, error: "Authentication required" }, 401, headers);
      const ok = await assertCsrf(request, session);
      if (!ok) return json({ success: false, error: "Invalid CSRF token" }, 403, headers);
      const body = await request.json();
      if (!Array.isArray(body.items) || !body.items.length)
        return json({ success: false, error: "Items required" }, 400, headers);
      const user = await env.DB.prepare(
        `SELECT email, first_name, last_name, phone FROM users WHERE id=?`
      ).bind(session.user_id).first();
      const customerName = (body.customer_name || `${user?.first_name || ""} ${user?.last_name || ""}`.trim()).trim() || session.social_handle || "SBS Customer";
      const customerPhone = (body.customer_phone || user?.phone || "").trim() || "N/A";
      const deliveryMethod = body.delivery_method === "collection" ? "collection" : "delivery";
      const items = body.items.map((item) => ({
        product_id: item.product_id || null,
        product_name: item.product_name || item.name || item.category || "SBS Item",
        product_brand: item.product_brand || item.brand || "SBS",
        product_category: item.product_category || item.category || "General",
        product_size: item.product_size || item.size || "One Size",
        price: Number(item.price) || 0,
        quantity: Number(item.quantity) || 1,
        image_url: item.image_url || null
      }));
      const itemsSubtotal = items.reduce((sum, item) => sum + item.price * item.quantity, 0);
      const providedSubtotal = Number(body.subtotal);
      const providedTotal = Number(body.total ?? body.total_amount);
      const deliveryFee = Number.isFinite(Number(body.delivery_fee)) ? Number(body.delivery_fee) : deliveryMethod === "delivery" ? 5 : 0;
      const subtotal = Number.isFinite(providedSubtotal) ? providedSubtotal : itemsSubtotal;
      const total = Number.isFinite(providedTotal) ? providedTotal : subtotal + deliveryFee;
      const orderNo = `SBS-${crypto.randomUUID().slice(0, 8).toUpperCase()}`;
      const itemsJson = JSON.stringify(items);
      const res = await env.DB.prepare(
        `INSERT INTO orders (
            user_id,
            order_number,
            customer_name,
            customer_phone,
            customer_email,
            items_json,
            delivery_method,
            delivery_fee,
            delivery_address,
            delivery_city,
            delivery_eircode,
            subtotal,
            total,
            status,
            created_at,
            updated_at
         )
         VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,'pending',CURRENT_TIMESTAMP,CURRENT_TIMESTAMP)`
      ).bind(
        session.user_id,
        orderNo,
        customerName,
        customerPhone,
        user?.email || null,
        itemsJson,
        deliveryMethod,
        deliveryFee,
        body.delivery_address || null,
        body.delivery_city || null,
        body.delivery_eircode || null,
        subtotal,
        total
      ).run();
      const orderId = res.meta?.last_row_id ?? null;
      if (orderId) {
        for (const item of items) {
          await env.DB.prepare(
            `INSERT INTO order_items (
                order_id,
                product_id,
                product_name,
                product_brand,
                product_category,
                product_size,
                price,
                quantity,
                created_at
             ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)`
          ).bind(
            orderId,
            item.product_id,
            item.product_name,
            item.product_brand,
            item.product_category,
            item.product_size,
            item.price,
            item.quantity
          ).run();
        }
      }
      const newOrder = {
        id: orderId,
        order_number: orderNo,
        status: "pending",
        total,
        subtotal,
        delivery_method: deliveryMethod,
        user_email: user?.email || null,
        user_name: customerName,
        items
      };
      try {
        const notificationService = new notification_service_default(env);
        const notificationItems = items.map((item) => ({
          name: item.product_name,
          size: item.product_size,
          quantity: item.quantity,
          price: item.price
        }));
        const notificationResult = await notificationService.sendOrderConfirmation(newOrder, notificationItems);
        if (notificationResult.success) {
          console.log(`\u2705 Order confirmation sent for ${orderNo}`);
        } else {
          console.warn(`\u26A0\uFE0F  Order confirmation failed for ${orderNo}: ${notificationResult.reason}`);
        }
      } catch (notificationError) {
        console.error("\u274C Order confirmation error:", notificationError);
      }
      return json(
        { success: true, order: newOrder },
        201,
        headers
      );
    }
    if (path === "/api/orders" && method === "GET") {
      if (!session?.user_id) return json({ success: false, error: "Authentication required" }, 401, headers);
      const rows = await env.DB.prepare(
        `SELECT id, order_number, items_json, subtotal, total, status, delivery_method, delivery_fee,
                delivery_address, delivery_city, delivery_eircode, admin_notes, customer_notes,
                created_at, updated_at, completed_at
         FROM orders
         WHERE user_id=?
         ORDER BY created_at DESC`
      ).bind(session.user_id).all();
      const orders = (rows.results || []).map((row) => ({
        ...row,
        subtotal: Number(row.subtotal) || 0,
        total: Number(row.total) || 0,
        items: (() => {
          try {
            const parsed = JSON.parse(row.items_json || "[]");
            return Array.isArray(parsed) ? parsed : [];
          } catch (err) {
            console.warn("Failed to parse order items_json", err);
            return [];
          }
        })()
      }));
      return json({ success: true, orders }, 200, headers);
    }
    if (path === "/api/users/me" && method === "GET") {
      const user = await env.DB.prepare(
        `SELECT id, social_handle, email, phone, first_name, last_name, address, city, eircode,
         preferred_contact, role, created_at FROM users WHERE id=?`
      ).bind(session.user_id).first();
      if (!user) return json({ success: false, error: "User not found" }, 404, headers);
      return json({ success: true, user }, 200, headers);
    }
    if (path === "/api/users/me/orders" && method === "GET") {
      if (!session?.user_id) return json({ success: false, error: "Authentication required" }, 401, headers);
      const ordersStmt = await env.DB.prepare(
        `SELECT id, order_number, items_json, total_amount, delivery_address, delivery_city,
                delivery_eircode, delivery_method, delivery_phone, status, payment_status,
                created_at, updated_at
         FROM orders
         WHERE user_id=?
         ORDER BY created_at DESC`
      ).bind(session.user_id).all();
      const orders = (ordersStmt.results || []).map((row) => ({
        ...row,
        total: Number(row.total_amount) || 0,
        subtotal: Number(row.total_amount) || 0,
        delivery_fee: 0,
        admin_notes: "",
        customer_notes: "",
        completed_at: null,
        items: (() => {
          try {
            const parsed = JSON.parse(row.items_json || "[]");
            return Array.isArray(parsed) ? parsed : [];
          } catch (err) {
            console.warn("Failed to parse order items_json", err);
            return [];
          }
        })()
      }));
      return json({ success: true, orders }, 200, headers);
    }
    if (path === "/api/verify-email" && method === "POST") {
      const body = await request.json();
      const { token } = body;
      if (!token) {
        return json({ success: false, error: "Token required" }, 400, headers);
      }
      try {
        const { verifyEmailToken: verifyEmailToken2 } = await Promise.resolve().then(() => (init_email(), email_exports));
        const result = await verifyEmailToken2(env.DB, token);
        if (result.success) {
          return json({
            success: true,
            message: "Email verified successfully! You can now login.",
            user: result.user
          }, 200, headers);
        } else {
          return json({
            success: false,
            error: result.error || "Verification failed"
          }, 400, headers);
        }
      } catch (error) {
        console.error("Verification error:", error);
        return json({
          success: false,
          error: "Verification failed"
        }, 500, headers);
      }
    }
    if (path === "/api/resend-verification" && method === "POST") {
      const body = await request.json();
      const { email } = body;
      if (!email) {
        return json({ success: false, error: "Email required" }, 400, headers);
      }
      const user = await env.DB.prepare(
        `SELECT id, email, email_verified_at FROM users WHERE email = ?`
      ).bind(email).first();
      if (!user) {
        return json({ success: true, message: "If that email is registered, a verification link has been sent." }, 200, headers);
      }
      if (user.email_verified_at) {
        return json({ success: false, error: "Email already verified" }, 400, headers);
      }
      try {
        const { createVerificationToken: createVerificationToken2, sendVerificationEmail: sendVerificationEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
        const token = await createVerificationToken2(env.DB, user.id);
        const siteUrl = env.SITE_URL || "https://thesbsofficial.com";
        await sendVerificationEmail2(email, token, siteUrl);
        return json({
          success: true,
          message: "Verification email sent! Check your inbox."
        }, 200, headers);
      } catch (error) {
        console.error("Resend email error:", error);
        return json({
          success: false,
          error: "Failed to send email"
        }, 500, headers);
      }
    }
    if (path === "/api/users/me/sell-cases" && method === "GET") {
      const cases = await env.DB.prepare(
        `SELECT case_id, brand, category, size, color, condition_rating, price,
         offer_amount, status, created_at FROM sell_cases WHERE user_id=? ORDER BY created_at DESC`
      ).bind(session.user_id).all();
      return json({ success: true, cases: cases.results || [] }, 200, headers);
    }
    if (path === "/api/users/update-profile" && method === "PUT") {
      const ok = await assertCsrf(request, session);
      if (!ok) return json({ success: false, error: "Invalid CSRF token" }, 403, headers);
      const body = await request.json();
      const allowed = [
        "first_name",
        "last_name",
        "social_handle",
        "email",
        "phone",
        "address",
        "city",
        "eircode",
        "instagram",
        "snapchat",
        "preferred_contact",
        "current_password",
        "new_password"
      ];
      for (const k of Object.keys(body)) {
        if (!allowed.includes(k)) {
          return json({ success: false, error: `Unknown field: ${k}` }, 400, headers);
        }
      }
      if (body.new_password) {
        if (!body.current_password) {
          return json({ success: false, error: "Current password required" }, 400, headers);
        }
        const user = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(session.user_id).first();
        if (!user || !await verifyPassword2(body.current_password, user)) {
          return json({ success: false, error: "Current password incorrect" }, 401, headers);
        }
        const { hash: hash2, salt, type, iterations } = await hashPassword(body.new_password);
        await env.DB.prepare(
          `UPDATE users SET password_hash = ?, password_salt = ?, password_hash_type = ?,
           password_iterations = ? WHERE id = ?`
        ).bind(hash2, salt, type, iterations, session.user_id).run();
      }
      const updates = [];
      const values = [];
      if (body.first_name !== void 0) {
        updates.push("first_name = ?");
        values.push(body.first_name);
      }
      if (body.last_name !== void 0) {
        updates.push("last_name = ?");
        values.push(body.last_name);
      }
      if (body.social_handle !== void 0) {
        updates.push("social_handle = ?");
        values.push(body.social_handle);
      }
      if (body.email !== void 0) {
        updates.push("email = ?");
        values.push(body.email);
      }
      if (body.phone !== void 0) {
        updates.push("phone = ?");
        values.push(body.phone);
      }
      if (body.address !== void 0) {
        updates.push("address = ?");
        values.push(body.address);
      }
      if (body.city !== void 0) {
        updates.push("city = ?");
        values.push(body.city);
      }
      if (body.eircode !== void 0) {
        updates.push("eircode = ?");
        values.push(body.eircode);
      }
      if (body.instagram !== void 0) {
        updates.push("instagram = ?");
        values.push(body.instagram);
      }
      if (body.snapchat !== void 0) {
        updates.push("snapchat = ?");
        values.push(body.snapchat);
      }
      if (body.preferred_contact !== void 0) {
        updates.push("preferred_contact = ?");
        values.push(body.preferred_contact);
      }
      if (updates.length > 0) {
        updates.push("updated_at = CURRENT_TIMESTAMP");
        values.push(session.user_id);
        await env.DB.prepare(
          `UPDATE users SET ${updates.join(", ")} WHERE id = ?`
        ).bind(...values).run();
      }
      const updatedUser = await env.DB.prepare(
        `SELECT id, social_handle, email, phone, first_name, last_name, address, city,
         eircode, instagram, snapchat, preferred_contact, role FROM users WHERE id = ?`
      ).bind(session.user_id).first();
      return json({
        success: true,
        message: "Profile updated successfully",
        user: updatedUser
      }, 200, headers);
    }
    if (path === "/api/users/delete" && method === "DELETE") {
      const ok = await assertCsrf(request, session);
      if (!ok) return json({ success: false, error: "Invalid CSRF token" }, 403, headers);
      try {
        await env.DB.prepare(
          `UPDATE users SET
           is_active = 0,
           email = NULL,
           phone = NULL,
           address = NULL,
           city = NULL,
           eircode = NULL,
           social_handle = CONCAT('deleted_', id, '_', social_handle),
           updated_at = CURRENT_TIMESTAMP
           WHERE id = ?`
        ).bind(session.user_id).run();
        await env.DB.prepare("DELETE FROM sessions WHERE user_id = ?").bind(session.user_id).run();
        return json(
          {
            success: true,
            message: "Account deleted. Your purchase and sell history has been anonymized."
          },
          200,
          { ...headers, "Set-Cookie": clearCookie() }
        );
      } catch (err) {
        console.error("Delete user error:", err);
        return json({ success: false, error: "Failed to delete account" }, 500, headers);
      }
    }
    if (path === "/api/admin/login" && method === "POST") {
      const body = await request.json();
      const { email, password } = body;
      if (!email || !password) {
        return json({ success: false, error: "Email and password required" }, 400, headers);
      }
      const user = await env.DB.prepare(`
        SELECT id, email, password_hash, password_salt, password_hash_type,
               password_iterations, role, is_allowlisted, first_name, last_name
        FROM users
        WHERE email = ? AND role = 'admin'
      `).bind(email).first();
      if (!user || !await verifyPassword2(password, user)) {
        return json({ success: false, error: "Invalid credentials" }, 401, headers);
      }
      if (!user.is_allowlisted) {
        return json({ success: false, error: "Access denied" }, 403, headers);
      }
      const ip = ipOf(request);
      const ua = request.headers.get("User-Agent") || "unknown";
      const { token, csrfSecret } = await createSession(env, user.id, ip, ua);
      try {
        const { logAdminAction: logAdminAction2 } = await Promise.resolve().then(() => (init_admin(), admin_exports));
        const mockSession = { user_id: user.id, role: "admin", is_allowlisted: 1 };
        await logAdminAction2(env, mockSession, "admin_login", null, {
          email: user.email,
          ip_address: ip
        });
      } catch (e) {
        console.warn("Admin logging failed:", e);
      }
      return json({
        success: true,
        token,
        csrf_token: await csrfTokenFromSecret(csrfSecret),
        user: {
          id: user.id,
          email: user.email,
          role: user.role,
          name: `${user.first_name || ""} ${user.last_name || ""}`.trim() || "Admin"
        }
      }, 200, headers);
    }
    if (path === "/api/admin/logout" && method === "POST") {
      const authHeader = request.headers.get("Authorization");
      if (authHeader && authHeader.startsWith("Bearer ")) {
        const token = authHeader.substring(7);
        await destroySession(env, token);
      }
      return json({ success: true }, 200, headers);
    }
    if (path === "/api/admin/verify" && method === "GET") {
      const authHeader = request.headers.get("Authorization");
      if (!authHeader || !authHeader.startsWith("Bearer ")) {
        return json({ success: false, error: "No token provided" }, 401, headers);
      }
      const token = authHeader.substring(7);
      const adminSession = await readSession(env, token);
      if (!adminSession || !isAdmin(adminSession)) {
        return json({ success: false, error: "Invalid admin session" }, 401, headers);
      }
      return json({
        success: true,
        user: {
          id: adminSession.user_id,
          email: adminSession.email,
          role: adminSession.role,
          name: `${adminSession.first_name || ""} ${adminSession.last_name || ""}`.trim() || "Admin"
        },
        csrf_token: await csrfTokenFromSecret(adminSession.csrf_secret)
      }, 200, headers);
    }
    return json({ success: false, error: "Endpoint not found" }, 404, headers);
  } catch (err) {
    console.error("API error:", err);
    console.error("Error stack:", err.stack);
    console.error("Error message:", err.message);
    return json({ success: false, error: "Internal server error", details: err.message }, 500, secHeaders("", env));
  }
}
var enc2, json, b64, b64toBuf, randB32, timingSafeEq, COOKIE_NAME, cookieAttrs, setCookie, clearCookie, hexRegex, isAdmin, ipOf;
var init_path = __esm({
  "api/[[path]].js"() {
    init_functionsRoutes_0_5646645567038772();
    init_notification_service();
    init_bcryptjs();
    enc2 = new TextEncoder();
    json = /* @__PURE__ */ __name((data, status = 200, headers = {}) => new Response(JSON.stringify(data), {
      status,
      headers: { "Content-Type": "application/json", ...headers }
    }), "json");
    b64 = /* @__PURE__ */ __name((buf) => btoa(String.fromCharCode(...new Uint8Array(buf))), "b64");
    b64toBuf = /* @__PURE__ */ __name((s) => Uint8Array.from(atob(s), (c) => c.charCodeAt(0)), "b64toBuf");
    randB32 = /* @__PURE__ */ __name(() => crypto.getRandomValues(new Uint8Array(32)), "randB32");
    timingSafeEq = /* @__PURE__ */ __name((a, b) => {
      if (a.length !== b.length) return false;
      let diff = 0;
      for (let i = 0; i < a.length; i++) diff |= a.charCodeAt(i) ^ b.charCodeAt(i);
      return diff === 0;
    }, "timingSafeEq");
    __name(secHeaders, "secHeaders");
    COOKIE_NAME = "sbs_session";
    cookieAttrs = "; HttpOnly; Secure; SameSite=Lax; Path=/; Max-Age=2592000";
    setCookie = /* @__PURE__ */ __name((token) => `${COOKIE_NAME}=${token}${cookieAttrs}`, "setCookie");
    clearCookie = /* @__PURE__ */ __name(() => `${COOKIE_NAME}=; Path=/; Max-Age=0; HttpOnly; Secure; SameSite=Lax`, "clearCookie");
    __name(getCookie, "getCookie");
    __name(hashPassword, "hashPassword");
    hexRegex = /^[a-f0-9]{64}$/i;
    __name(verifyPassword2, "verifyPassword");
    __name(issueCsrfSecret, "issueCsrfSecret");
    __name(csrfTokenFromSecret, "csrfTokenFromSecret");
    __name(assertCsrf, "assertCsrf");
    __name(createSession, "createSession");
    __name(sha256b644, "sha256b64");
    __name(readSession, "readSession");
    __name(destroySession, "destroySession");
    isAdmin = /* @__PURE__ */ __name((session) => session?.role === "admin" && session?.is_allowlisted === 1, "isAdmin");
    ipOf = /* @__PURE__ */ __name((req) => req.headers.get("CF-Connecting-IP") || (req.headers.get("X-Forwarded-For") || "").split(",")[0] || "unknown", "ipOf");
    __name(onRequest7, "onRequest");
  }
});

// ../.wrangler/tmp/pages-62b7Kd/functionsRoutes-0.5646645567038772.mjs
var routes;
var init_functionsRoutes_0_5646645567038772 = __esm({
  "../.wrangler/tmp/pages-62b7Kd/functionsRoutes-0.5646645567038772.mjs"() {
    init_activity();
    init_activity();
    init_analytics();
    init_auth();
    init_auth();
    init_auth();
    init_delete_image();
    init_orders();
    init_orders();
    init_orders();
    init_orders();
    init_products();
    init_products();
    init_products();
    init_products();
    init_products();
    init_update_image_metadata();
    init_upload_image();
    init_sync();
    init_track();
    init_submit();
    init_upload_photos();
    init_create();
    init_reservations();
    init_sell_requests();
    init_sell_submissions();
    init_sell_submissions();
    init_analytics_v2();
    init_eircode_proxy();
    init_products2();
    init_products_smart();
    init_path();
    routes = [
      {
        routePath: "/api/admin/activity",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet]
      },
      {
        routePath: "/api/admin/activity",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions]
      },
      {
        routePath: "/api/admin/analytics",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet2]
      },
      {
        routePath: "/api/admin/auth",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet3]
      },
      {
        routePath: "/api/admin/auth",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions2]
      },
      {
        routePath: "/api/admin/auth",
        mountPath: "/api/admin",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost]
      },
      {
        routePath: "/api/admin/delete-image",
        mountPath: "/api/admin",
        method: "DELETE",
        middlewares: [],
        modules: [onRequestDelete]
      },
      {
        routePath: "/api/admin/orders",
        mountPath: "/api/admin",
        method: "DELETE",
        middlewares: [],
        modules: [onRequestDelete2]
      },
      {
        routePath: "/api/admin/orders",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet4]
      },
      {
        routePath: "/api/admin/orders",
        mountPath: "/api/admin",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost2]
      },
      {
        routePath: "/api/admin/orders",
        mountPath: "/api/admin",
        method: "PUT",
        middlewares: [],
        modules: [onRequestPut]
      },
      {
        routePath: "/api/admin/products",
        mountPath: "/api/admin",
        method: "DELETE",
        middlewares: [],
        modules: [onRequestDelete3]
      },
      {
        routePath: "/api/admin/products",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet5]
      },
      {
        routePath: "/api/admin/products",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions3]
      },
      {
        routePath: "/api/admin/products",
        mountPath: "/api/admin",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost3]
      },
      {
        routePath: "/api/admin/products",
        mountPath: "/api/admin",
        method: "PUT",
        middlewares: [],
        modules: [onRequestPut2]
      },
      {
        routePath: "/api/admin/update-image-metadata",
        mountPath: "/api/admin",
        method: "PATCH",
        middlewares: [],
        modules: [onRequestPatch]
      },
      {
        routePath: "/api/admin/upload-image",
        mountPath: "/api/admin",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost4]
      },
      {
        routePath: "/api/analytics/sync",
        mountPath: "/api/analytics",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost5]
      },
      {
        routePath: "/api/analytics/track",
        mountPath: "/api/analytics",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost6]
      },
      {
        routePath: "/api/cases/submit",
        mountPath: "/api/cases",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost7]
      },
      {
        routePath: "/api/cases/upload-photos",
        mountPath: "/api/cases",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost8]
      },
      {
        routePath: "/api/reservations/create",
        mountPath: "/api/reservations",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost9]
      },
      {
        routePath: "/api/admin/reservations",
        mountPath: "/api/admin",
        method: "",
        middlewares: [],
        modules: [onRequest]
      },
      {
        routePath: "/api/admin/sell-requests",
        mountPath: "/api/admin",
        method: "",
        middlewares: [],
        modules: [onRequest2]
      },
      {
        routePath: "/api/sell-submissions",
        mountPath: "/api",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet6]
      },
      {
        routePath: "/api/sell-submissions",
        mountPath: "/api",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost10]
      },
      {
        routePath: "/api/analytics-v2",
        mountPath: "/api",
        method: "",
        middlewares: [],
        modules: [onRequest3]
      },
      {
        routePath: "/api/eircode-proxy",
        mountPath: "/api",
        method: "",
        middlewares: [],
        modules: [onRequest4]
      },
      {
        routePath: "/api/products",
        mountPath: "/api",
        method: "",
        middlewares: [],
        modules: [onRequest5]
      },
      {
        routePath: "/api/products-smart",
        mountPath: "/api",
        method: "",
        middlewares: [],
        modules: [onRequest6]
      },
      {
        routePath: "/api/:path*",
        mountPath: "/api",
        method: "",
        middlewares: [],
        modules: [onRequest7]
      }
    ];
  }
});

// ../node_modules/wrangler/templates/pages-template-worker.ts
init_functionsRoutes_0_5646645567038772();

// ../node_modules/path-to-regexp/dist.es2015/index.js
init_functionsRoutes_0_5646645567038772();
function lexer(str) {
  var tokens = [];
  var i = 0;
  while (i < str.length) {
    var char = str[i];
    if (char === "*" || char === "+" || char === "?") {
      tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
      continue;
    }
    if (char === "\\") {
      tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
      continue;
    }
    if (char === "{") {
      tokens.push({ type: "OPEN", index: i, value: str[i++] });
      continue;
    }
    if (char === "}") {
      tokens.push({ type: "CLOSE", index: i, value: str[i++] });
      continue;
    }
    if (char === ":") {
      var name = "";
      var j = i + 1;
      while (j < str.length) {
        var code = str.charCodeAt(j);
        if (
          // `0-9`
          code >= 48 && code <= 57 || // `A-Z`
          code >= 65 && code <= 90 || // `a-z`
          code >= 97 && code <= 122 || // `_`
          code === 95
        ) {
          name += str[j++];
          continue;
        }
        break;
      }
      if (!name)
        throw new TypeError("Missing parameter name at ".concat(i));
      tokens.push({ type: "NAME", index: i, value: name });
      i = j;
      continue;
    }
    if (char === "(") {
      var count = 1;
      var pattern = "";
      var j = i + 1;
      if (str[j] === "?") {
        throw new TypeError('Pattern cannot start with "?" at '.concat(j));
      }
      while (j < str.length) {
        if (str[j] === "\\") {
          pattern += str[j++] + str[j++];
          continue;
        }
        if (str[j] === ")") {
          count--;
          if (count === 0) {
            j++;
            break;
          }
        } else if (str[j] === "(") {
          count++;
          if (str[j + 1] !== "?") {
            throw new TypeError("Capturing groups are not allowed at ".concat(j));
          }
        }
        pattern += str[j++];
      }
      if (count)
        throw new TypeError("Unbalanced pattern at ".concat(i));
      if (!pattern)
        throw new TypeError("Missing pattern at ".concat(i));
      tokens.push({ type: "PATTERN", index: i, value: pattern });
      i = j;
      continue;
    }
    tokens.push({ type: "CHAR", index: i, value: str[i++] });
  }
  tokens.push({ type: "END", index: i, value: "" });
  return tokens;
}
__name(lexer, "lexer");
function parse(str, options) {
  if (options === void 0) {
    options = {};
  }
  var tokens = lexer(str);
  var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a, _b = options.delimiter, delimiter = _b === void 0 ? "/#?" : _b;
  var result = [];
  var key = 0;
  var i = 0;
  var path = "";
  var tryConsume = /* @__PURE__ */ __name(function(type) {
    if (i < tokens.length && tokens[i].type === type)
      return tokens[i++].value;
  }, "tryConsume");
  var mustConsume = /* @__PURE__ */ __name(function(type) {
    var value2 = tryConsume(type);
    if (value2 !== void 0)
      return value2;
    var _a2 = tokens[i], nextType = _a2.type, index = _a2.index;
    throw new TypeError("Unexpected ".concat(nextType, " at ").concat(index, ", expected ").concat(type));
  }, "mustConsume");
  var consumeText = /* @__PURE__ */ __name(function() {
    var result2 = "";
    var value2;
    while (value2 = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")) {
      result2 += value2;
    }
    return result2;
  }, "consumeText");
  var isSafe = /* @__PURE__ */ __name(function(value2) {
    for (var _i = 0, delimiter_1 = delimiter; _i < delimiter_1.length; _i++) {
      var char2 = delimiter_1[_i];
      if (value2.indexOf(char2) > -1)
        return true;
    }
    return false;
  }, "isSafe");
  var safePattern = /* @__PURE__ */ __name(function(prefix2) {
    var prev = result[result.length - 1];
    var prevText = prefix2 || (prev && typeof prev === "string" ? prev : "");
    if (prev && !prevText) {
      throw new TypeError('Must have text between two parameters, missing text after "'.concat(prev.name, '"'));
    }
    if (!prevText || isSafe(prevText))
      return "[^".concat(escapeString(delimiter), "]+?");
    return "(?:(?!".concat(escapeString(prevText), ")[^").concat(escapeString(delimiter), "])+?");
  }, "safePattern");
  while (i < tokens.length) {
    var char = tryConsume("CHAR");
    var name = tryConsume("NAME");
    var pattern = tryConsume("PATTERN");
    if (name || pattern) {
      var prefix = char || "";
      if (prefixes.indexOf(prefix) === -1) {
        path += prefix;
        prefix = "";
      }
      if (path) {
        result.push(path);
        path = "";
      }
      result.push({
        name: name || key++,
        prefix,
        suffix: "",
        pattern: pattern || safePattern(prefix),
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    var value = char || tryConsume("ESCAPED_CHAR");
    if (value) {
      path += value;
      continue;
    }
    if (path) {
      result.push(path);
      path = "";
    }
    var open = tryConsume("OPEN");
    if (open) {
      var prefix = consumeText();
      var name_1 = tryConsume("NAME") || "";
      var pattern_1 = tryConsume("PATTERN") || "";
      var suffix = consumeText();
      mustConsume("CLOSE");
      result.push({
        name: name_1 || (pattern_1 ? key++ : ""),
        pattern: name_1 && !pattern_1 ? safePattern(prefix) : pattern_1,
        prefix,
        suffix,
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    mustConsume("END");
  }
  return result;
}
__name(parse, "parse");
function match(str, options) {
  var keys = [];
  var re = pathToRegexp(str, keys, options);
  return regexpToFunction(re, keys, options);
}
__name(match, "match");
function regexpToFunction(re, keys, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.decode, decode = _a === void 0 ? function(x) {
    return x;
  } : _a;
  return function(pathname) {
    var m = re.exec(pathname);
    if (!m)
      return false;
    var path = m[0], index = m.index;
    var params = /* @__PURE__ */ Object.create(null);
    var _loop_1 = /* @__PURE__ */ __name(function(i2) {
      if (m[i2] === void 0)
        return "continue";
      var key = keys[i2 - 1];
      if (key.modifier === "*" || key.modifier === "+") {
        params[key.name] = m[i2].split(key.prefix + key.suffix).map(function(value) {
          return decode(value, key);
        });
      } else {
        params[key.name] = decode(m[i2], key);
      }
    }, "_loop_1");
    for (var i = 1; i < m.length; i++) {
      _loop_1(i);
    }
    return { path, index, params };
  };
}
__name(regexpToFunction, "regexpToFunction");
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
__name(escapeString, "escapeString");
function flags(options) {
  return options && options.sensitive ? "" : "i";
}
__name(flags, "flags");
function regexpToRegexp(path, keys) {
  if (!keys)
    return path;
  var groupsRegex = /\((?:\?<(.*?)>)?(?!\?)/g;
  var index = 0;
  var execResult = groupsRegex.exec(path.source);
  while (execResult) {
    keys.push({
      // Use parenthesized substring match if available, index otherwise
      name: execResult[1] || index++,
      prefix: "",
      suffix: "",
      modifier: "",
      pattern: ""
    });
    execResult = groupsRegex.exec(path.source);
  }
  return path;
}
__name(regexpToRegexp, "regexpToRegexp");
function arrayToRegexp(paths, keys, options) {
  var parts = paths.map(function(path) {
    return pathToRegexp(path, keys, options).source;
  });
  return new RegExp("(?:".concat(parts.join("|"), ")"), flags(options));
}
__name(arrayToRegexp, "arrayToRegexp");
function stringToRegexp(path, keys, options) {
  return tokensToRegexp(parse(path, options), keys, options);
}
__name(stringToRegexp, "stringToRegexp");
function tokensToRegexp(tokens, keys, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function(x) {
    return x;
  } : _d, _e = options.delimiter, delimiter = _e === void 0 ? "/#?" : _e, _f = options.endsWith, endsWith = _f === void 0 ? "" : _f;
  var endsWithRe = "[".concat(escapeString(endsWith), "]|$");
  var delimiterRe = "[".concat(escapeString(delimiter), "]");
  var route = start ? "^" : "";
  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
    var token = tokens_1[_i];
    if (typeof token === "string") {
      route += escapeString(encode(token));
    } else {
      var prefix = escapeString(encode(token.prefix));
      var suffix = escapeString(encode(token.suffix));
      if (token.pattern) {
        if (keys)
          keys.push(token);
        if (prefix || suffix) {
          if (token.modifier === "+" || token.modifier === "*") {
            var mod = token.modifier === "*" ? "?" : "";
            route += "(?:".concat(prefix, "((?:").concat(token.pattern, ")(?:").concat(suffix).concat(prefix, "(?:").concat(token.pattern, "))*)").concat(suffix, ")").concat(mod);
          } else {
            route += "(?:".concat(prefix, "(").concat(token.pattern, ")").concat(suffix, ")").concat(token.modifier);
          }
        } else {
          if (token.modifier === "+" || token.modifier === "*") {
            throw new TypeError('Can not repeat "'.concat(token.name, '" without a prefix and suffix'));
          }
          route += "(".concat(token.pattern, ")").concat(token.modifier);
        }
      } else {
        route += "(?:".concat(prefix).concat(suffix, ")").concat(token.modifier);
      }
    }
  }
  if (end) {
    if (!strict)
      route += "".concat(delimiterRe, "?");
    route += !options.endsWith ? "$" : "(?=".concat(endsWithRe, ")");
  } else {
    var endToken = tokens[tokens.length - 1];
    var isEndDelimited = typeof endToken === "string" ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1 : endToken === void 0;
    if (!strict) {
      route += "(?:".concat(delimiterRe, "(?=").concat(endsWithRe, "))?");
    }
    if (!isEndDelimited) {
      route += "(?=".concat(delimiterRe, "|").concat(endsWithRe, ")");
    }
  }
  return new RegExp(route, flags(options));
}
__name(tokensToRegexp, "tokensToRegexp");
function pathToRegexp(path, keys, options) {
  if (path instanceof RegExp)
    return regexpToRegexp(path, keys);
  if (Array.isArray(path))
    return arrayToRegexp(path, keys, options);
  return stringToRegexp(path, keys, options);
}
__name(pathToRegexp, "pathToRegexp");

// ../node_modules/wrangler/templates/pages-template-worker.ts
var escapeRegex = /[.+?^${}()|[\]\\]/g;
function* executeRequest(request) {
  const requestPath = new URL(request.url).pathname;
  for (const route of [...routes].reverse()) {
    if (route.method && route.method !== request.method) {
      continue;
    }
    const routeMatcher = match(route.routePath.replace(escapeRegex, "\\$&"), {
      end: false
    });
    const mountMatcher = match(route.mountPath.replace(escapeRegex, "\\$&"), {
      end: false
    });
    const matchResult = routeMatcher(requestPath);
    const mountMatchResult = mountMatcher(requestPath);
    if (matchResult && mountMatchResult) {
      for (const handler of route.middlewares.flat()) {
        yield {
          handler,
          params: matchResult.params,
          path: mountMatchResult.path
        };
      }
    }
  }
  for (const route of routes) {
    if (route.method && route.method !== request.method) {
      continue;
    }
    const routeMatcher = match(route.routePath.replace(escapeRegex, "\\$&"), {
      end: true
    });
    const mountMatcher = match(route.mountPath.replace(escapeRegex, "\\$&"), {
      end: false
    });
    const matchResult = routeMatcher(requestPath);
    const mountMatchResult = mountMatcher(requestPath);
    if (matchResult && mountMatchResult && route.modules.length) {
      for (const handler of route.modules.flat()) {
        yield {
          handler,
          params: matchResult.params,
          path: matchResult.path
        };
      }
      break;
    }
  }
}
__name(executeRequest, "executeRequest");
var pages_template_worker_default = {
  async fetch(originalRequest, env, workerContext) {
    let request = originalRequest;
    const handlerIterator = executeRequest(request);
    let data = {};
    let isFailOpen = false;
    const next = /* @__PURE__ */ __name(async (input, init) => {
      if (input !== void 0) {
        let url = input;
        if (typeof input === "string") {
          url = new URL(input, request.url).toString();
        }
        request = new Request(url, init);
      }
      const result = handlerIterator.next();
      if (result.done === false) {
        const { handler, params, path } = result.value;
        const context = {
          request: new Request(request.clone()),
          functionPath: path,
          next,
          params,
          get data() {
            return data;
          },
          set data(value) {
            if (typeof value !== "object" || value === null) {
              throw new Error("context.data must be an object");
            }
            data = value;
          },
          env,
          waitUntil: workerContext.waitUntil.bind(workerContext),
          passThroughOnException: /* @__PURE__ */ __name(() => {
            isFailOpen = true;
          }, "passThroughOnException")
        };
        const response = await handler(context);
        if (!(response instanceof Response)) {
          throw new Error("Your Pages function should return a Response");
        }
        return cloneResponse(response);
      } else if ("ASSETS") {
        const response = await env["ASSETS"].fetch(request);
        return cloneResponse(response);
      } else {
        const response = await fetch(request);
        return cloneResponse(response);
      }
    }, "next");
    try {
      return await next();
    } catch (error) {
      if (isFailOpen) {
        const response = await env["ASSETS"].fetch(request);
        return cloneResponse(response);
      }
      throw error;
    }
  }
};
var cloneResponse = /* @__PURE__ */ __name((response) => (
  // https://fetch.spec.whatwg.org/#null-body-status
  new Response(
    [101, 204, 205, 304].includes(response.status) ? null : response.body,
    response
  )
), "cloneResponse");
export {
  pages_template_worker_default as default
};

------formdata-undici-021293909545--
