------formdata-undici-028884142580
Content-Disposition: form-data; name="metadata"

{"main_module":"functionsWorker-0.03257029603760242.js"}
------formdata-undici-028884142580
Content-Disposition: form-data; name="functionsWorker-0.03257029603760242.js"; filename="functionsWorker-0.03257029603760242.js"
Content-Type: application/javascript+module

var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// lib/security.js
function base64FromBytes(bytes) {
  const binString = Array.from(bytes, (byte) => String.fromCodePoint(byte)).join("");
  return btoa(binString);
}
function bytesFromBase64(base64) {
  const binString = atob(base64);
  return Uint8Array.from(binString, (char) => char.codePointAt(0));
}
function hexFromBytes(bytes) {
  return Array.from(bytes, (byte) => byte.toString(16).padStart(2, "0")).join("");
}
async function derivePbkdf2(password, salt, iterations = PBKDF2_ITERATIONS) {
  const encoder = new TextEncoder();
  const passwordKey = await crypto.subtle.importKey(
    "raw",
    encoder.encode(password),
    "PBKDF2",
    false,
    ["deriveBits"]
  );
  const derivedBits = await crypto.subtle.deriveBits(
    {
      name: "PBKDF2",
      salt,
      iterations,
      hash: "SHA-256"
    },
    passwordKey,
    256
    // 256-bit output
  );
  return new Uint8Array(derivedBits);
}
async function verifyPasswordPbkdf2(password, storedHash, storedSalt, iterations = PBKDF2_ITERATIONS) {
  const salt = bytesFromBase64(storedSalt);
  const derived = await derivePbkdf2(password, salt, iterations);
  const candidateHash = base64FromBytes(derived);
  return timingSafeEqualString(candidateHash, storedHash);
}
async function verifyPasswordAgainstUser(password, user) {
  const hashType = (user?.password_hash_type || "").toLowerCase();
  if (hashType.startsWith("pbkdf2")) {
    return await verifyPasswordPbkdf2(
      password,
      user.password_hash,
      user.password_salt,
      user.password_iterations || PBKDF2_ITERATIONS
    );
  }
  if (hashType === "bcrypt") {
    throw new Error("bcrypt verification must be handled by caller with bcryptjs library");
  }
  const legacyHash = await hashPasswordLegacy(password);
  return timingSafeEqualString(legacyHash, user.password_hash);
}
async function verifyPassword(password, user) {
  if (!user) return false;
  return verifyPasswordAgainstUser(password, user);
}
async function hashPasswordLegacy(password) {
  const encoder = new TextEncoder();
  const data = encoder.encode(password);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  return hexFromBytes(new Uint8Array(hashBuffer));
}
function timingSafeEqualString(a, b) {
  if (!a || !b) return false;
  if (a.length !== b.length) return false;
  let result = 0;
  for (let i = 0; i < a.length; i++) {
    result |= a.charCodeAt(i) ^ b.charCodeAt(i);
  }
  return result === 0;
}
async function hashToken(token) {
  const encoder = new TextEncoder();
  const data = encoder.encode(token);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  return hexFromBytes(new Uint8Array(hashBuffer));
}
function generateOrderNumber() {
  const randomBytes = crypto.getRandomValues(new Uint8Array(6));
  const part1 = hexFromBytes(randomBytes.slice(0, 3)).toUpperCase();
  const part2 = hexFromBytes(randomBytes.slice(3, 6)).toUpperCase();
  return `SBS-${part1}-${part2}`;
}
function base32Encode(bytes) {
  let bits = 0;
  let value = 0;
  let output = "";
  for (let i = 0; i < bytes.length; i++) {
    value = value << 8 | bytes[i];
    bits += 8;
    while (bits >= 5) {
      output += BASE32_ALPHABET[value >>> bits - 5 & 31];
      bits -= 5;
    }
  }
  if (bits > 0) {
    output += BASE32_ALPHABET[value << 5 - bits & 31];
  }
  while (output.length % 8 !== 0) {
    output += "=";
  }
  return output;
}
function generateTotpSecret() {
  const bytes = crypto.getRandomValues(new Uint8Array(20));
  return base32Encode(bytes).replace(/=+$/, "");
}
function generateRecoveryCodes(count = 8) {
  const codes = [];
  for (let i = 0; i < count; i++) {
    const bytes = crypto.getRandomValues(new Uint8Array(5));
    const code = Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("").toUpperCase();
    codes.push(code);
  }
  return codes;
}
var PBKDF2_ITERATIONS, BASE32_ALPHABET;
var init_security = __esm({
  "lib/security.js"() {
    init_functionsRoutes_0_9937148203508366();
    PBKDF2_ITERATIONS = 21e4;
    __name(base64FromBytes, "base64FromBytes");
    __name(bytesFromBase64, "bytesFromBase64");
    __name(hexFromBytes, "hexFromBytes");
    __name(derivePbkdf2, "derivePbkdf2");
    __name(verifyPasswordPbkdf2, "verifyPasswordPbkdf2");
    __name(verifyPasswordAgainstUser, "verifyPasswordAgainstUser");
    __name(verifyPassword, "verifyPassword");
    __name(hashPasswordLegacy, "hashPasswordLegacy");
    __name(timingSafeEqualString, "timingSafeEqualString");
    __name(hashToken, "hashToken");
    __name(generateOrderNumber, "generateOrderNumber");
    BASE32_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
    __name(base32Encode, "base32Encode");
    __name(generateTotpSecret, "generateTotpSecret");
    __name(generateRecoveryCodes, "generateRecoveryCodes");
  }
});

// lib/admin.js
var admin_exports = {};
__export(admin_exports, {
  ADMIN_CONSTANTS: () => ADMIN_CONSTANTS,
  generateAdminMenuHTML: () => generateAdminMenuHTML,
  isAdminSession: () => isAdminSession,
  logAdminAction: () => logAdminAction,
  promoteToAdmin: () => promoteToAdmin,
  runAdminDiagnostics: () => runAdminDiagnostics,
  setupTotpForAdmin: () => setupTotpForAdmin,
  shouldElevateToAdmin: () => shouldElevateToAdmin,
  verifyAdminAuth: () => verifyAdminAuth
});
function isAdminSession(session) {
  return session?.role === "admin" && session?.is_allowlisted === 1;
}
async function verifyAdminAuth(request, env) {
  const authHeader = request.headers.get("Authorization");
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return null;
  }
  const token = authHeader.substring(7);
  const tokenHash = await hashToken(token);
  const session = await env.DB.prepare(`
        SELECT s.user_id, s.csrf_secret, s.expires_at,
               u.email, u.role, u.is_allowlisted, u.first_name, u.last_name
        FROM sessions s
        JOIN users u ON s.user_id = u.id
        WHERE s.token_hash = ? AND s.expires_at > datetime('now')
        AND u.role = 'admin' AND u.is_allowlisted = 1
    `).bind(tokenHash).first();
  return session;
}
function shouldElevateToAdmin(env, socialHandle) {
  const allowlistHandles = env.ADMIN_ALLOWLIST_HANDLES?.split(",").map((h) => h.trim().toLowerCase().replace(/^@/, "")).filter(Boolean) || [];
  const normalized = socialHandle.toLowerCase().replace(/^@/, "");
  return allowlistHandles.includes(normalized);
}
async function promoteToAdmin(env, userId) {
  await env.DB.prepare(`
        UPDATE users
        SET role = 'admin'
        WHERE id = ?
    `).bind(userId).run();
  await env.DB.prepare(`
        INSERT OR IGNORE INTO admin_allowlist (user_id, notes)
        VALUES (?, 'Auto-promoted via ADMIN_ALLOWLIST_HANDLES')
    `).bind(userId).run();
}
async function logAdminAction(env, session, action, resource = null, metadata = null, ipAddress = null) {
  if (!session?.user_id) return;
  await env.DB.prepare(`
        INSERT INTO admin_audit_logs (
            user_id, action, resource, metadata_json, ip_address
        ) VALUES (?, ?, ?, ?, ?)
    `).bind(
    session.user_id,
    action,
    resource,
    metadata ? JSON.stringify(metadata) : null,
    ipAddress
  ).run();
}
function generateAdminMenuHTML() {
  return `
<section class="admin-menu" style="background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%); padding: 1.5rem; border-radius: 12px; margin-bottom: 2rem; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
    <h2 style="color: #000; margin: 0 0 1rem 0; font-size: 1.5rem; font-weight: 700;">\u{1F6E1}\uFE0F Admin Controls</h2>
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
        <button id="runBoard07" type="button" style="background: #000; color: #FFD700; border: 2px solid #FFD700; padding: 0.75rem 1.5rem; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.3s ease;">
            \u{1F50D} Run Diagnostics (Board-07)
        </button>
        <button id="setupTOTP" type="button" style="background: #000; color: #FFD700; border: 2px solid #FFD700; padding: 0.75rem 1.5rem; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.3s ease;">
            \u{1F510} Setup 2FA/TOTP
        </button>
        <button id="viewAuditLogs" type="button" style="background: #000; color: #FFD700; border: 2px solid #FFD700; padding: 0.75rem 1.5rem; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.3s ease;">
            \u{1F4CB} View Audit Logs
        </button>
    </div>
</section>
    `.trim();
}
async function setupTotpForAdmin(env, session) {
  const existingUser = await env.DB.prepare(`
        SELECT totp_secret FROM users WHERE id = ?
    `).bind(session.user_id).first();
  if (existingUser?.totp_secret) {
    throw new Error("TOTP is already configured for this account");
  }
  const secret = generateTotpSecret();
  const recoveryCodes = generateRecoveryCodes(8);
  await env.DB.prepare(`
        UPDATE users
        SET totp_secret = ?, totp_recovery_codes = ?
        WHERE id = ?
    `).bind(
    secret,
    JSON.stringify(recoveryCodes),
    session.user_id
  ).run();
  const identifier = encodeURIComponent(
    session.email || session.social_handle || `user-${session.user_id}`
  );
  const issuer = encodeURIComponent("SBS Unity");
  const otpauthUrl = `otpauth://totp/${issuer}:${identifier}?secret=${secret}&issuer=${issuer}&algorithm=SHA256&digits=6&period=30`;
  return {
    secret,
    recovery_codes: recoveryCodes,
    otpauth_url: otpauthUrl
  };
}
async function runAdminDiagnostics(env) {
  const checks = [];
  try {
    const tables = await env.DB.prepare(`
            SELECT name FROM sqlite_master
            WHERE type='table'
            ORDER BY name
        `).all();
    const tableNames = tables.results.map((t) => t.name);
    const requiredTables = [
      "users",
      "sessions",
      "orders",
      "admin_allowlist",
      "admin_audit_logs",
      "password_reset_tokens",
      "email_verification_tokens"
    ];
    const missingTables = requiredTables.filter((t) => !tableNames.includes(t));
    checks.push({
      name: "tables_present",
      passed: missingTables.length === 0,
      details: tableNames,
      missing: missingTables
    });
  } catch (error) {
    checks.push({
      name: "tables_present",
      passed: false,
      error: error.message
    });
  }
  try {
    const userColumns = await env.DB.prepare(`
            PRAGMA table_info('users')
        `).all();
    const columnNames = userColumns.results.map((c) => c.name);
    const requiredColumns = [
      "id",
      "social_handle",
      "email",
      "password_hash",
      "role",
      "password_salt",
      "password_hash_type",
      "totp_secret",
      "email_verified_at",
      "locked_until"
    ];
    const missingColumns = requiredColumns.filter((c) => !columnNames.includes(c));
    checks.push({
      name: "users_columns",
      passed: missingColumns.length === 0,
      total_columns: columnNames.length,
      missing: missingColumns
    });
  } catch (error) {
    checks.push({
      name: "users_columns",
      passed: false,
      error: error.message
    });
  }
  try {
    const sessionColumns = await env.DB.prepare(`
            PRAGMA table_info('sessions')
        `).all();
    const columnNames = sessionColumns.results.map((c) => c.name);
    const requiredColumns = [
      "id",
      "user_id",
      "token_hash",
      "csrf_secret",
      "expires_at",
      "invalidated_at",
      "ip_address",
      "user_agent"
    ];
    const missingColumns = requiredColumns.filter((c) => !columnNames.includes(c));
    checks.push({
      name: "sessions_columns",
      passed: missingColumns.length === 0,
      total_columns: columnNames.length,
      missing: missingColumns
    });
  } catch (error) {
    checks.push({
      name: "sessions_columns",
      passed: false,
      error: error.message
    });
  }
  try {
    const allowlistCount = await env.DB.prepare(`
            SELECT COUNT(*) as total FROM admin_allowlist
        `).first();
    checks.push({
      name: "admin_allowlist",
      passed: true,
      total: allowlistCount.total
    });
  } catch (error) {
    checks.push({
      name: "admin_allowlist",
      passed: false,
      error: error.message
    });
  }
  try {
    const auditCount = await env.DB.prepare(`
            SELECT COUNT(*) as total
            FROM admin_audit_logs
            WHERE created_at > datetime('now', '-1 day')
        `).first();
    checks.push({
      name: "audit_logs_24h",
      passed: true,
      total: auditCount.total
    });
  } catch (error) {
    checks.push({
      name: "audit_logs_24h",
      passed: false,
      error: error.message
    });
  }
  try {
    const sessionCount = await env.DB.prepare(`
            SELECT COUNT(*) as total
            FROM sessions
            WHERE expires_at > datetime('now')
                AND invalidated_at IS NULL
        `).first();
    checks.push({
      name: "active_sessions",
      passed: true,
      total: sessionCount.total
    });
  } catch (error) {
    checks.push({
      name: "active_sessions",
      passed: false,
      error: error.message
    });
  }
  const envVars = {
    ADMIN_ALLOWLIST_HANDLES: !!env.ADMIN_ALLOWLIST_HANDLES,
    ALLOWED_ORIGINS: !!env.ALLOWED_ORIGINS,
    NODE_ENV: !!env.NODE_ENV,
    DB: !!env.DB
  };
  checks.push({
    name: "environment_variables",
    passed: envVars.DB && envVars.ADMIN_ALLOWLIST_HANDLES,
    details: envVars
  });
  return checks;
}
var ADMIN_CONSTANTS;
var init_admin = __esm({
  "lib/admin.js"() {
    init_functionsRoutes_0_9937148203508366();
    init_security();
    __name(isAdminSession, "isAdminSession");
    __name(verifyAdminAuth, "verifyAdminAuth");
    __name(shouldElevateToAdmin, "shouldElevateToAdmin");
    __name(promoteToAdmin, "promoteToAdmin");
    __name(logAdminAction, "logAdminAction");
    __name(generateAdminMenuHTML, "generateAdminMenuHTML");
    __name(setupTotpForAdmin, "setupTotpForAdmin");
    __name(runAdminDiagnostics, "runAdminDiagnostics");
    ADMIN_CONSTANTS = {
      ADMIN_ACTIONS: {
        MENU_VIEW: "admin_menu_view",
        BOARD07: "admin_board07",
        TOTP_SETUP: "admin_totp_setup",
        AUDIT_LOGS_VIEW: "admin_audit_logs_view"
      }
    };
  }
});

// api/admin/activity.js
function jsonResponse(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization"
    }
  });
}
async function onRequestGet(context) {
  const { request, env } = context;
  const url = new URL(request.url);
  try {
    const session = await verifyAdminAuth(request, env);
    if (!session) {
      return jsonResponse({
        success: false,
        error: "Unauthorized - Admin access required"
      }, 401);
    }
    if (url.pathname.endsWith("/activity")) {
      return await handleGetActivity(context, session);
    } else if (url.pathname.endsWith("/stats")) {
      return await handleGetStats(context, session);
    }
    return jsonResponse({ error: "Endpoint not found" }, 404);
  } catch (error) {
    console.error("\u274C Admin activity/stats error:", error);
    return jsonResponse({
      success: false,
      error: "Failed to fetch data",
      details: error.message
    }, 500);
  }
}
async function handleGetActivity(context, session) {
  const { env } = context;
  const url = new URL(context.request.url);
  const limit = parseInt(url.searchParams.get("limit")) || 50;
  try {
    await logAdminAction(env, session, "admin_activity_view");
    const auditLogs = await env.DB.prepare(`
            SELECT
                aal.id,
                aal.action,
                aal.resource,
                aal.metadata_json,
                aal.ip_address,
                aal.created_at,
                u.email as admin_email,
                u.first_name,
                u.last_name
            FROM admin_audit_logs aal
            JOIN users u ON aal.user_id = u.id
            ORDER BY aal.created_at DESC
            LIMIT ?
        `).bind(limit).all();
    const recentOrders = await env.DB.prepare(`
            SELECT
                id,
                order_number,
                customer_name,
                total,
                status,
                created_at
            FROM orders
            ORDER BY created_at DESC
            LIMIT 10
        `).all();
    const recentUsers = await env.DB.prepare(`
            SELECT
                id,
                email,
                first_name,
                last_name,
                role,
                created_at
            FROM users
            WHERE role = 'customer'
            ORDER BY created_at DESC
            LIMIT 10
        `).all();
    const recentSubmissions = await env.DB.prepare(`
            SELECT
                id,
                batch_id,
                contact_name,
                item_count,
                status,
                created_at
            FROM sell_submissions
            ORDER BY created_at DESC
            LIMIT 10
        `).all();
    return jsonResponse({
      success: true,
      data: {
        admin_actions: auditLogs.results || [],
        recent_orders: recentOrders.results || [],
        recent_users: recentUsers.results || [],
        recent_submissions: recentSubmissions.results || [],
        generated_at: (/* @__PURE__ */ new Date()).toISOString(),
        generated_by: session.email
      }
    });
  } catch (error) {
    console.error("\u274C Error fetching admin activity:", error);
    throw error;
  }
}
async function handleGetStats(context, session) {
  const { env } = context;
  const url = new URL(context.request.url);
  const period = url.searchParams.get("period") || "7d";
  try {
    await logAdminAction(env, session, "admin_stats_view", null, { period });
    const days = period === "24h" ? 1 : period === "7d" ? 7 : period === "30d" ? 30 : 9999;
    const dateFilter = period !== "all" ? `WHERE DATE(created_at) >= DATE('now', '-${days} days')` : "";
    const userStats = await env.DB.prepare(`
            SELECT
                COUNT(*) as total_users,
                COUNT(CASE WHEN role = 'customer' THEN 1 END) as customers,
                COUNT(CASE WHEN role = 'admin' THEN 1 END) as admins,
                COUNT(CASE WHEN is_verified = 1 THEN 1 END) as verified_users,
                COUNT(CASE WHEN DATE(created_at) >= DATE('now', '-${days} days') THEN 1 END) as new_users_period
            FROM users
        `).first();
    const orderStats = await env.DB.prepare(`
            SELECT
                COUNT(*) as total_orders,
                COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_orders,
                COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_orders,
                SUM(CASE WHEN status = 'completed' THEN total ELSE 0 END) as total_revenue,
                AVG(CASE WHEN status = 'completed' THEN total ELSE NULL END) as avg_order_value,
                COUNT(CASE WHEN DATE(created_at) >= DATE('now', '-${days} days') THEN 1 END) as orders_period
            FROM orders
        `).first();
    const productStats = await env.DB.prepare(`
            SELECT
                COUNT(*) as total_products,
                COUNT(CASE WHEN status = 'available' THEN 1 END) as available_products,
                COUNT(CASE WHEN status = 'sold' THEN 1 END) as sold_products,
                COUNT(CASE WHEN featured = 1 THEN 1 END) as featured_products,
                COUNT(CASE WHEN DATE(created_at) >= DATE('now', '-${days} days') THEN 1 END) as products_added_period
            FROM products
        `).first();
    const submissionStats = await env.DB.prepare(`
            SELECT
                COUNT(*) as total_submissions,
                COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_submissions,
                COUNT(CASE WHEN status = 'approved' THEN 1 END) as approved_submissions,
                COUNT(CASE WHEN status = 'rejected' THEN 1 END) as rejected_submissions,
                SUM(item_count) as total_items_submitted,
                COUNT(CASE WHEN DATE(created_at) >= DATE('now', '-${days} days') THEN 1 END) as submissions_period
            FROM sell_submissions
        `).first();
    const sessionStats = await env.DB.prepare(`
            SELECT
                COUNT(*) as active_sessions,
                COUNT(DISTINCT user_id) as active_users,
                COUNT(CASE WHEN DATE(created_at) >= DATE('now', '-1 days') THEN 1 END) as sessions_24h
            FROM sessions
            WHERE expires_at > datetime('now')
        `).first();
    const topCategories = await env.DB.prepare(`
            SELECT
                category,
                COUNT(*) as product_count,
                COUNT(CASE WHEN status = 'sold' THEN 1 END) as sold_count
            FROM products
            GROUP BY category
            ORDER BY product_count DESC
            LIMIT 10
        `).all();
    const dailyStats = await env.DB.prepare(`
            SELECT
                DATE(created_at) as date,
                COUNT(CASE WHEN table_type = 'orders' THEN 1 END) as orders,
                COUNT(CASE WHEN table_type = 'users' THEN 1 END) as users,
                COUNT(CASE WHEN table_type = 'products' THEN 1 END) as products
            FROM (
                SELECT created_at, 'orders' as table_type FROM orders
                UNION ALL
                SELECT created_at, 'users' as table_type FROM users WHERE role = 'customer'
                UNION ALL
                SELECT created_at, 'products' as table_type FROM products
            )
            WHERE DATE(created_at) >= DATE('now', '-7 days')
            GROUP BY DATE(created_at)
            ORDER BY date DESC
        `).all();
    return jsonResponse({
      success: true,
      period,
      data: {
        users: userStats,
        orders: orderStats,
        products: productStats,
        submissions: submissionStats,
        sessions: sessionStats,
        top_categories: topCategories.results || [],
        daily_trends: dailyStats.results || [],
        generated_at: (/* @__PURE__ */ new Date()).toISOString(),
        generated_by: session.email
      }
    });
  } catch (error) {
    console.error("\u274C Error fetching admin stats:", error);
    throw error;
  }
}
async function onRequestOptions(context) {
  return jsonResponse(null, 204);
}
var init_activity = __esm({
  "api/admin/activity.js"() {
    init_functionsRoutes_0_9937148203508366();
    init_admin();
    __name(jsonResponse, "jsonResponse");
    __name(onRequestGet, "onRequestGet");
    __name(handleGetActivity, "handleGetActivity");
    __name(handleGetStats, "handleGetStats");
    __name(onRequestOptions, "onRequestOptions");
  }
});

// api/admin/analytics.js
async function onRequestGet2(context) {
  const { request, env } = context;
  const url = new URL(request.url);
  const period = url.searchParams.get("period") || "7d";
  try {
    const authHeader = request.headers.get("Authorization");
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return jsonResponse2({ success: false, error: "Unauthorized" }, 401);
    }
    const token = authHeader.substring(7);
    const encoder = new TextEncoder();
    const data = encoder.encode(token);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const tokenHash = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
    const session = await env.DB.prepare(`
            SELECT s.user_id, u.role, u.is_allowlisted
            FROM sessions s
            JOIN users u ON s.user_id = u.id
            WHERE s.token_hash = ? AND s.expires_at > datetime('now')
            AND u.role = 'admin' AND u.is_allowlisted = 1
        `).bind(tokenHash).first();
    if (!session) {
      return jsonResponse2({ success: false, error: "Invalid session or insufficient privileges" }, 401);
    }
    console.log(`\u{1F4CA} Fetching analytics for period: ${period}`);
    const days = period === "24h" ? 1 : period === "7d" ? 7 : period === "30d" ? 30 : 365;
    const summaries = await env.DB.prepare(`
            SELECT * FROM analytics_daily_summary
            WHERE date >= date('now', '-${days} days')
            ORDER BY date DESC
        `).all();
    const totals = await env.DB.prepare(`
            SELECT
                SUM(unique_visitors) as total_visitors,
                SUM(page_views) as total_page_views,
                SUM(orders_completed) as total_orders,
                SUM(revenue) as total_revenue,
                AVG(conversion_rate) as avg_conversion_rate,
                AVG(avg_order_value) as avg_order_value
            FROM analytics_daily_summary
            WHERE date >= date('now', '-${days} days')
        `).first();
    const topProducts = await env.DB.prepare(`
            SELECT
                product_id,
                product_name,
                category,
                brand,
                SUM(views) as total_views,
                SUM(cart_adds) as total_cart_adds,
                SUM(purchases) as total_purchases,
                SUM(revenue) as total_revenue,
                AVG(overall_conversion_rate) as avg_conversion_rate
            FROM analytics_product_performance
            WHERE date >= date('now', '-${days} days')
            GROUP BY product_id
            ORDER BY total_revenue DESC
            LIMIT 10
        `).all();
    const topSearches = await env.DB.prepare(`
            SELECT
                search_term,
                SUM(search_count) as total_searches,
                AVG(results_found) as avg_results,
                AVG(click_through_rate) as avg_ctr
            FROM analytics_searches
            WHERE date >= date('now', '-${days} days')
            GROUP BY search_term
            ORDER BY total_searches DESC
            LIMIT 10
        `).all();
    const today = await env.DB.prepare(`
            SELECT * FROM analytics_daily_summary
            WHERE date = date('now')
        `).first();
    const previousPeriod = await env.DB.prepare(`
            SELECT
                SUM(revenue) as prev_revenue,
                SUM(unique_visitors) as prev_visitors,
                SUM(orders_completed) as prev_orders
            FROM analytics_daily_summary
            WHERE date >= date('now', '-${days * 2} days')
            AND date < date('now', '-${days} days')
        `).first();
    const revenueGrowth = previousPeriod?.prev_revenue > 0 ? ((totals.total_revenue - previousPeriod.prev_revenue) / previousPeriod.prev_revenue * 100).toFixed(2) : 0;
    const visitorGrowth = previousPeriod?.prev_visitors > 0 ? ((totals.total_visitors - previousPeriod.prev_visitors) / previousPeriod.prev_visitors * 100).toFixed(2) : 0;
    return jsonResponse2({
      success: true,
      period,
      date_range: {
        start: new Date(Date.now() - days * 24 * 60 * 60 * 1e3).toISOString().split("T")[0],
        end: (/* @__PURE__ */ new Date()).toISOString().split("T")[0]
      },
      overview: {
        total_visitors: totals?.total_visitors || 0,
        total_page_views: totals?.total_page_views || 0,
        total_orders: totals?.total_orders || 0,
        total_revenue: parseFloat(totals?.total_revenue || 0).toFixed(2),
        avg_conversion_rate: parseFloat(totals?.avg_conversion_rate || 0).toFixed(2),
        avg_order_value: parseFloat(totals?.avg_order_value || 0).toFixed(2),
        revenue_growth: revenueGrowth,
        visitor_growth: visitorGrowth
      },
      today: today || {
        unique_visitors: 0,
        page_views: 0,
        orders_completed: 0,
        revenue: 0,
        conversion_rate: 0
      },
      daily_trend: summaries.results || [],
      top_products: topProducts.results || [],
      top_searches: topSearches.results || [],
      last_sync: summaries.results?.[0]?.synced_at || null
    });
  } catch (error) {
    console.error("\u274C Analytics fetch error:", error);
    return jsonResponse2({
      success: false,
      error: error.message
    }, 500);
  }
}
function jsonResponse2(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*"
    }
  });
}
var init_analytics = __esm({
  "api/admin/analytics.js"() {
    init_functionsRoutes_0_9937148203508366();
    __name(onRequestGet2, "onRequestGet");
    __name(jsonResponse2, "jsonResponse");
  }
});

// api/admin/auth.js
function jsonResponse3(data, status = 200, headers = {}) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization",
      ...headers
    }
  });
}
function generateSessionToken() {
  const array = new Uint8Array(32);
  crypto.getRandomValues(array);
  return Array.from(array, (byte) => byte.toString(16).padStart(2, "0")).join("");
}
async function hashToken2(token) {
  const encoder = new TextEncoder();
  const data = encoder.encode(token);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
}
async function onRequestGet3(context) {
  const { request, env } = context;
  const url = new URL(request.url);
  if (url.pathname.endsWith("/verify")) {
    return await handleVerifySession(context);
  }
  return jsonResponse3({ error: "Endpoint not found" }, 404);
}
async function onRequestPost(context) {
  const { request, env } = context;
  const url = new URL(request.url);
  if (url.pathname.endsWith("/login")) {
    return await handleLogin(context);
  } else if (url.pathname.endsWith("/logout")) {
    return await handleLogout(context);
  }
  return jsonResponse3({ error: "Endpoint not found" }, 404);
}
async function handleLogin(context) {
  const { request, env } = context;
  try {
    const body = await request.json();
    const { email, password } = body;
    if (!email || !password) {
      return jsonResponse3({
        success: false,
        error: "Email and password are required"
      }, 400);
    }
    console.log(`\u{1F510} Admin login attempt for: ${email}`);
    const user = await env.DB.prepare(`
            SELECT id, email, password_hash, password_salt, password_hash_type,
                   password_iterations, role, is_allowlisted, first_name, last_name
            FROM users
            WHERE email = ? AND role = 'admin'
        `).bind(email).first();
    if (!user) {
      console.log(`\u274C Admin user not found: ${email}`);
      return jsonResponse3({
        success: false,
        error: "Invalid credentials"
      }, 401);
    }
    const isValidPassword = await verifyPassword(password, user);
    if (!isValidPassword) {
      console.log(`\u274C Invalid password for admin: ${email}`);
      return jsonResponse3({
        success: false,
        error: "Invalid credentials"
      }, 401);
    }
    if (!user.is_allowlisted) {
      console.log(`\u274C Admin not allowlisted: ${email}`);
      return jsonResponse3({
        success: false,
        error: "Access denied. Contact system administrator."
      }, 403);
    }
    const sessionToken = generateSessionToken();
    const tokenHash = await hashToken2(sessionToken);
    const expiresAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3).toISOString();
    const clientIP = request.headers.get("CF-Connecting-IP") || request.headers.get("X-Forwarded-For") || "unknown";
    const userAgent = request.headers.get("User-Agent") || "unknown";
    await env.DB.prepare(`
            INSERT INTO sessions (user_id, token_hash, csrf_secret, expires_at, ip_address, user_agent)
            VALUES (?, ?, ?, ?, ?, ?)
        `).bind(
      user.id,
      tokenHash,
      generateSessionToken(),
      // CSRF secret
      expiresAt,
      clientIP,
      userAgent
    ).run();
    await env.DB.prepare(`
            INSERT INTO session_tokens (token_hash, user_id, expires_at)
            VALUES (?, ?, ?)
        `).bind(tokenHash, user.id, expiresAt).run();
    const mockSession = { user_id: user.id, role: "admin", is_allowlisted: 1 };
    await logAdminAction(env, mockSession, "admin_login", null, {
      email: user.email,
      ip_address: clientIP,
      user_agent: userAgent
    });
    console.log(`\u2705 Admin login successful: ${email}`);
    return jsonResponse3({
      success: true,
      message: "Login successful",
      token: sessionToken,
      user: {
        id: user.id,
        email: user.email,
        role: user.role,
        name: `${user.first_name || ""} ${user.last_name || ""}`.trim() || "Admin"
      },
      expires_at: expiresAt
    });
  } catch (error) {
    console.error("\u274C Admin login error:", error);
    return jsonResponse3({
      success: false,
      error: "Login failed",
      details: error.message
    }, 500);
  }
}
async function handleLogout(context) {
  const { request, env } = context;
  try {
    const authHeader = request.headers.get("Authorization");
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return jsonResponse3({
        success: false,
        error: "No session token provided"
      }, 400);
    }
    const token = authHeader.substring(7);
    const tokenHash = await hashToken2(token);
    const session = await env.DB.prepare(`
            SELECT s.user_id, u.email, u.role
            FROM sessions s
            JOIN users u ON s.user_id = u.id
            WHERE s.token_hash = ? AND s.expires_at > datetime('now')
        `).bind(tokenHash).first();
    await env.DB.prepare(`
            DELETE FROM sessions WHERE token_hash = ?
        `).bind(tokenHash).run();
    await env.DB.prepare(`
            DELETE FROM session_tokens WHERE token_hash = ?
        `).bind(tokenHash).run();
    if (session) {
      const mockSession = { user_id: session.user_id, role: session.role, is_allowlisted: 1 };
      await logAdminAction(env, mockSession, "admin_logout", null, {
        email: session.email
      });
      console.log(`\u2705 Admin logout successful: ${session.email}`);
    }
    return jsonResponse3({
      success: true,
      message: "Logout successful"
    });
  } catch (error) {
    console.error("\u274C Admin logout error:", error);
    return jsonResponse3({
      success: false,
      error: "Logout failed",
      details: error.message
    }, 500);
  }
}
async function handleVerifySession(context) {
  const { request, env } = context;
  try {
    const authHeader = request.headers.get("Authorization");
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return jsonResponse3({
        success: false,
        error: "No session token provided"
      }, 401);
    }
    const token = authHeader.substring(7);
    const tokenHash = await hashToken2(token);
    const session = await env.DB.prepare(`
            SELECT s.user_id, s.csrf_secret, s.expires_at, s.ip_address,
                   u.email, u.role, u.is_allowlisted, u.first_name, u.last_name
            FROM sessions s
            JOIN users u ON s.user_id = u.id
            WHERE s.token_hash = ? AND s.expires_at > datetime('now')
        `).bind(tokenHash).first();
    if (!session) {
      return jsonResponse3({
        success: false,
        error: "Invalid or expired session"
      }, 401);
    }
    if (!isAdminSession(session)) {
      return jsonResponse3({
        success: false,
        error: "Access denied. Admin privileges required."
      }, 403);
    }
    await env.DB.prepare(`
            UPDATE sessions
            SET updated_at = datetime('now')
            WHERE token_hash = ?
        `).bind(tokenHash).run();
    return jsonResponse3({
      success: true,
      message: "Session valid",
      user: {
        id: session.user_id,
        email: session.email,
        role: session.role,
        name: `${session.first_name || ""} ${session.last_name || ""}`.trim() || "Admin"
      },
      session: {
        expires_at: session.expires_at,
        csrf_secret: session.csrf_secret
      }
    });
  } catch (error) {
    console.error("\u274C Admin session verification error:", error);
    return jsonResponse3({
      success: false,
      error: "Session verification failed",
      details: error.message
    }, 500);
  }
}
async function onRequestOptions2(context) {
  return jsonResponse3(null, 204);
}
var init_auth = __esm({
  "api/admin/auth.js"() {
    init_functionsRoutes_0_9937148203508366();
    init_security();
    init_admin();
    __name(jsonResponse3, "jsonResponse");
    __name(generateSessionToken, "generateSessionToken");
    __name(hashToken2, "hashToken");
    __name(onRequestGet3, "onRequestGet");
    __name(onRequestPost, "onRequestPost");
    __name(handleLogin, "handleLogin");
    __name(handleLogout, "handleLogout");
    __name(handleVerifySession, "handleVerifySession");
    __name(onRequestOptions2, "onRequestOptions");
  }
});

// api/admin/delete-image.js
async function sha256b64(text) {
  const encoder = new TextEncoder();
  const data = encoder.encode(text);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = new Uint8Array(hashBuffer);
  return btoa(String.fromCharCode(...hashArray));
}
async function onRequestDelete({ request, env }) {
  const cookie = request.headers.get("Cookie") || "";
  const sessionId = cookie.split("sbs_session=")[1]?.split(";")[0];
  if (!sessionId) {
    return new Response(JSON.stringify({
      success: false,
      error: "Not authenticated"
    }), {
      status: 401,
      headers: { "Content-Type": "application/json" }
    });
  }
  try {
    const sessionHash = await sha256b64(sessionId);
    const sessionResult = await env.DB.prepare(
      "SELECT user_id, expires_at FROM sessions WHERE token = ? AND invalidated_at IS NULL"
    ).bind(sessionHash).first();
    if (!sessionResult) {
      return new Response(JSON.stringify({
        success: false,
        error: "Session not found. Please log in again."
      }), {
        status: 401,
        headers: { "Content-Type": "application/json" }
      });
    }
    const now = (/* @__PURE__ */ new Date()).toISOString();
    if (sessionResult.expires_at < now) {
      return new Response(JSON.stringify({
        success: false,
        error: "Session expired. Please log in again."
      }), {
        status: 401,
        headers: { "Content-Type": "application/json" }
      });
    }
    const userResult = await env.DB.prepare(
      "SELECT role FROM users WHERE id = ?"
    ).bind(sessionResult.user_id).first();
    if (!userResult || userResult.role !== "admin") {
      return new Response(JSON.stringify({
        success: false,
        error: "Admin access required"
      }), {
        status: 403,
        headers: { "Content-Type": "application/json" }
      });
    }
    const { imageId } = await request.json();
    if (!imageId) {
      return new Response(JSON.stringify({
        success: false,
        error: "Missing imageId"
      }), {
        status: 400,
        headers: { "Content-Type": "application/json" }
      });
    }
    const accountId = env.CLOUDFLARE_ACCOUNT_ID;
    const apiToken = env.CLOUDFLARE_IMAGES_API_TOKEN || env.CLOUDFLARE_API_TOKEN;
    if (!accountId || !apiToken) {
      return new Response(JSON.stringify({
        success: false,
        error: "Missing Cloudflare credentials"
      }), {
        status: 500,
        headers: { "Content-Type": "application/json" }
      });
    }
    const deleteUrl = `https://api.cloudflare.com/client/v4/accounts/${accountId}/images/v1/${imageId}`;
    const deleteResponse = await fetch(deleteUrl, {
      method: "DELETE",
      headers: {
        "Authorization": `Bearer ${apiToken}`
      }
    });
    const deleteResult = await deleteResponse.json();
    if (!deleteResponse.ok || !deleteResult.success) {
      console.error("CF Images delete failed:", deleteResult);
      return new Response(JSON.stringify({
        success: false,
        error: deleteResult.errors?.[0]?.message || "Failed to delete image"
      }), {
        status: deleteResponse.status,
        headers: { "Content-Type": "application/json" }
      });
    }
    return new Response(JSON.stringify({
      success: true,
      message: "Image deleted successfully",
      imageId
    }), {
      status: 200,
      headers: { "Content-Type": "application/json" }
    });
  } catch (error) {
    console.error("Delete image error:", error);
    return new Response(JSON.stringify({
      success: false,
      error: error.message || "Internal server error"
    }), {
      status: 500,
      headers: { "Content-Type": "application/json" }
    });
  }
}
var init_delete_image = __esm({
  "api/admin/delete-image.js"() {
    init_functionsRoutes_0_9937148203508366();
    __name(sha256b64, "sha256b64");
    __name(onRequestDelete, "onRequestDelete");
  }
});

// lib/notification-service.js
var NotificationService, notification_service_default;
var init_notification_service = __esm({
  "lib/notification-service.js"() {
    init_functionsRoutes_0_9937148203508366();
    NotificationService = class {
      static {
        __name(this, "NotificationService");
      }
      constructor(env) {
        this.env = env;
        this.resendApiKey = env.RESEND_API_KEY;
        this.siteUrl = env.SITE_URL || "https://thesbsofficial.com";
      }
      /**
       * Send order status update notification
       */
      async sendOrderStatusUpdate(order, newStatus) {
        if (!this.resendApiKey) {
          console.warn("\u{1F4E7} Email notifications disabled - RESEND_API_KEY not configured");
          return { success: false, reason: "email_not_configured" };
        }
        try {
          const statusMessages = {
            "pending": "We've received your order and it's being processed.",
            "confirmed": "Your order has been confirmed and is being prepared.",
            "processing": "Your order is currently being processed.",
            "shipped": "Great news! Your order has been shipped.",
            "delivered": "Your order has been delivered. Thank you for shopping with SBS!",
            "cancelled": "Your order has been cancelled. If you have questions, please contact us.",
            "ready": "Your order is ready for collection/delivery!"
          };
          const subject = `Order Update: ${order.order_number} - ${newStatus.charAt(0).toUpperCase() + newStatus.slice(1)}`;
          const message = statusMessages[newStatus] || `Your order status has been updated to: ${newStatus}`;
          const emailHtml = `
                <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 30px; text-align: center;">
                        <h1 style="color: white; margin: 0; font-size: 28px;">SBS</h1>
                        <p style="color: white; margin: 10px 0 0 0; opacity: 0.9;">Sneaker & Clothing Store</p>
                    </div>
                    
                    <div style="padding: 30px; background: white;">
                        <h2 style="color: #333; margin-top: 0;">Order Update</h2>
                        
                        <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                            <p style="margin: 0; font-weight: bold; color: #667eea;">Order #${order.order_number}</p>
                            <p style="margin: 5px 0 0 0; color: #666;">Status: <strong>${newStatus.charAt(0).toUpperCase() + newStatus.slice(1)}</strong></p>
                        </div>
                        
                        <p style="color: #333; line-height: 1.6;">${message}</p>
                        
                        ${newStatus === "shipped" ? `
                            <div style="background: #e8f5e8; padding: 15px; border-radius: 8px; margin: 20px 0;">
                                <p style="margin: 0; color: #2d5016;"><strong>\u{1F4E6} Shipping Information</strong></p>
                                <p style="margin: 5px 0 0 0; color: #2d5016;">Your order is on its way! You should receive it within 1-3 business days.</p>
                            </div>
                        ` : ""}
                        
                        <div style="text-align: center; margin: 30px 0;">
                            <a href="${this.siteUrl}/dashboard.html" 
                               style="background: #667eea; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;">
                                View Order Details
                            </a>
                        </div>
                        
                        <hr style="border: none; border-top: 1px solid #eee; margin: 30px 0;">
                        
                        <p style="color: #666; font-size: 14px; margin: 0;">
                            Questions? Reply to this email or contact us at <a href="mailto:support@thesbsofficial.com" style="color: #667eea;">support@thesbsofficial.com</a>
                        </p>
                    </div>
                    
                    <div style="background: #f8f9fa; padding: 20px; text-align: center; color: #666; font-size: 12px;">
                        <p style="margin: 0;">SBS - Sneaker & Clothing Store</p>
                        <p style="margin: 5px 0 0 0;">Dublin, Ireland</p>
                    </div>
                </div>
            `;
          const response = await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${this.resendApiKey}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              from: "SBS Store <orders@thesbsofficial.com>",
              to: [order.user_email || order.email],
              subject,
              html: emailHtml
            })
          });
          if (!response.ok) {
            const error = await response.text();
            console.error("\u{1F4E7} Email send failed:", error);
            return { success: false, reason: "email_send_failed", error };
          }
          console.log(`\u{1F4E7} Order notification sent to ${order.user_email || order.email}: ${newStatus}`);
          return { success: true, method: "email" };
        } catch (error) {
          console.error("\u{1F4E7} Notification error:", error);
          return { success: false, reason: "notification_error", error: error.message };
        }
      }
      /**
       * Send order confirmation email
       */
      async sendOrderConfirmation(order, orderItems) {
        if (!this.resendApiKey) {
          console.warn("\u{1F4E7} Email notifications disabled - RESEND_API_KEY not configured");
          return { success: false, reason: "email_not_configured" };
        }
        try {
          const itemsHtml = orderItems.map((item) => `
                <tr>
                    <td style="padding: 10px; border-bottom: 1px solid #eee;">
                        <div style="font-weight: bold;">${item.name}</div>
                        <div style="color: #666; font-size: 14px;">Size: ${item.size}</div>
                    </td>
                    <td style="padding: 10px; border-bottom: 1px solid #eee; text-align: center;">
                        ${item.quantity}
                    </td>
                    <td style="padding: 10px; border-bottom: 1px solid #eee; text-align: right;">
                        \u20AC${item.price}
                    </td>
                </tr>
            `).join("");
          const emailHtml = `
                <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 30px; text-align: center;">
                        <h1 style="color: white; margin: 0; font-size: 28px;">Order Confirmed! \u{1F389}</h1>
                        <p style="color: white; margin: 10px 0 0 0; opacity: 0.9;">Thank you for shopping with SBS</p>
                    </div>
                    
                    <div style="padding: 30px; background: white;">
                        <div style="background: #e8f5e8; padding: 20px; border-radius: 8px; margin-bottom: 30px;">
                            <h2 style="margin: 0 0 10px 0; color: #2d5016;">Order #${order.order_number}</h2>
                            <p style="margin: 0; color: #2d5016;">Your order has been confirmed and will be processed shortly.</p>
                        </div>
                        
                        <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                            <thead>
                                <tr style="background: #f8f9fa;">
                                    <th style="padding: 15px 10px; text-align: left; border-bottom: 2px solid #667eea;">Item</th>
                                    <th style="padding: 15px 10px; text-align: center; border-bottom: 2px solid #667eea;">Qty</th>
                                    <th style="padding: 15px 10px; text-align: right; border-bottom: 2px solid #667eea;">Price</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${itemsHtml}
                                <tr style="background: #f8f9fa; font-weight: bold;">
                                    <td style="padding: 15px 10px;" colspan="2">Total</td>
                                    <td style="padding: 15px 10px; text-align: right;">\u20AC${order.total_amount || "TBD"}</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin: 20px 0;">
                            <p style="margin: 0; color: #856404;"><strong>\u{1F4CB} What's Next?</strong></p>
                            <p style="margin: 5px 0 0 0; color: #856404;">We'll prepare your order and send you updates. Typical processing time is 1-2 business days.</p>
                        </div>
                        
                        <div style="text-align: center; margin: 30px 0;">
                            <a href="${this.siteUrl}/dashboard.html" 
                               style="background: #667eea; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block; margin-right: 10px;">
                                Track Order
                            </a>
                            <a href="${this.siteUrl}/shop.html" 
                               style="background: #6c757d; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;">
                                Continue Shopping
                            </a>
                        </div>
                    </div>
                    
                    <div style="background: #f8f9fa; padding: 20px; text-align: center; color: #666; font-size: 12px;">
                        <p style="margin: 0;">Questions? Contact us at <a href="mailto:support@thesbsofficial.com" style="color: #667eea;">support@thesbsofficial.com</a></p>
                        <p style="margin: 5px 0 0 0;">SBS - Dublin, Ireland</p>
                    </div>
                </div>
            `;
          const response = await fetch("https://api.resend.com/emails", {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${this.resendApiKey}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              from: "SBS Store <orders@thesbsofficial.com>",
              to: [order.user_email || order.email],
              subject: `Order Confirmation - ${order.order_number}`,
              html: emailHtml
            })
          });
          if (!response.ok) {
            const error = await response.text();
            console.error("\u{1F4E7} Order confirmation email failed:", error);
            return { success: false, reason: "email_send_failed", error };
          }
          console.log(`\u{1F4E7} Order confirmation sent to ${order.user_email || order.email}`);
          return { success: true, method: "email" };
        } catch (error) {
          console.error("\u{1F4E7} Order confirmation error:", error);
          return { success: false, reason: "notification_error", error: error.message };
        }
      }
    };
    notification_service_default = NotificationService;
  }
});

// api/admin/orders.js
function jsonResponse4(data, status = 200, headers = {}) {
  return new Response(JSON.stringify(data), {
    status,
    headers: { ...BASE_HEADERS, ...headers }
  });
}
async function requireAdminSession(context) {
  const session = await verifyAdminAuth(context.request, context.env);
  if (!session) {
    return { error: jsonResponse4({ error: "Unauthorized" }, 401) };
  }
  return { session };
}
async function fetchOrderWithItems(DB, orderNumber) {
  const order = await DB.prepare(`
        SELECT
            o.*,
            GROUP_CONCAT(
                json_object(
                    'product_id', oi.product_id,
                    'category', oi.category,
                    'size', oi.size,
                    'image_url', oi.image_url
                )
            ) AS items_json
        FROM orders o
        LEFT JOIN order_items oi ON o.order_number = oi.order_number
        WHERE o.order_number = ?
        GROUP BY o.order_number
    `).bind(orderNumber).first();
  if (!order) {
    return null;
  }
  order.items = order.items_json ? JSON.parse(`[${order.items_json}]`) : [];
  delete order.items_json;
  return order;
}
async function attachItemsToOrders(DB, orders) {
  if (!orders.length) {
    return;
  }
  const orderNumbers = orders.map((o) => o.order_number);
  const placeholders = orderNumbers.map(() => "?").join(",");
  const { results: allItems } = await DB.prepare(`
        SELECT order_number, product_id, category, size, image_url
        FROM order_items
        WHERE order_number IN (${placeholders})
        ORDER BY order_number
    `).bind(...orderNumbers).all();
  const itemsByOrder = /* @__PURE__ */ new Map();
  for (const item of allItems) {
    if (!itemsByOrder.has(item.order_number)) {
      itemsByOrder.set(item.order_number, []);
    }
    itemsByOrder.get(item.order_number).push(item);
  }
  for (const order of orders) {
    order.items = itemsByOrder.get(order.order_number) || [];
  }
}
function deriveOrderEmail(order) {
  return order?.customer_email || order?.user_email || order?.email || null;
}
function mapItemsForNotification(items = []) {
  return items.map((item) => ({
    name: item.name || item.category || item.product_id || "SBS Item",
    size: item.size || "N/A",
    quantity: item.quantity || 1,
    price: typeof item.price === "number" ? item.price : "TBD"
  }));
}
function normalizeStatus(value) {
  return (value || "").toLowerCase();
}
function createOrderNumber() {
  const generated = generateOrderNumber();
  return generated.startsWith("SBS-") ? generated.replace("SBS-", "ORD-") : generated;
}
async function onRequestGet4(context) {
  try {
    const check = await requireAdminSession(context);
    if (check.error) return check.error;
    const { DB } = context.env;
    const url = new URL(context.request.url);
    const orderNumber = url.searchParams.get("order_number");
    const statusFilter = normalizeStatus(url.searchParams.get("status"));
    if (orderNumber) {
      const order = await fetchOrderWithItems(DB, orderNumber);
      if (!order) {
        return jsonResponse4({ error: "Order not found" }, 404);
      }
      await logAdminAction(context.env, check.session, "admin_order_view", `order_${orderNumber}`, {
        via: "orders_api",
        order_number: orderNumber
      });
      return jsonResponse4({ success: true, order });
    }
    let baseQuery = `
            SELECT o.*
            FROM orders o
        `;
    const params = [];
    if (statusFilter && statusFilter !== "all") {
      baseQuery += " WHERE lower(o.status) = ?";
      params.push(statusFilter);
    }
    baseQuery += " ORDER BY o.created_at DESC LIMIT 100";
    const stmt = params.length ? DB.prepare(baseQuery).bind(...params) : DB.prepare(baseQuery);
    const { results: orders } = await stmt.all();
    await attachItemsToOrders(DB, orders);
    const todayStr = (/* @__PURE__ */ new Date()).toDateString();
    const stats = {
      pending: orders.filter((o) => normalizeStatus(o.status) === "pending").length,
      ready: orders.filter((o) => normalizeStatus(o.status) === "ready").length,
      completed: orders.filter((o) => normalizeStatus(o.status) === "completed" && new Date(o.created_at).toDateString() === todayStr).length,
      revenue: orders.filter((o) => normalizeStatus(o.status) === "completed" && new Date(o.created_at).toDateString() === todayStr).reduce((sum, o) => sum + (Number(o.total_amount) || 0), 0)
    };
    await logAdminAction(context.env, check.session, "admin_orders_list", null, {
      count: orders.length,
      status_filter: statusFilter || "all"
    });
    return jsonResponse4({ success: true, orders, stats, total: orders.length });
  } catch (error) {
    console.error("Orders GET Error:", error);
    return jsonResponse4({ error: "Failed to fetch orders", message: error.message }, 500);
  }
}
async function onRequestPost2(context) {
  try {
    const check = await requireAdminSession(context);
    if (check.error) return check.error;
    const { DB } = context.env;
    const orderData = await context.request.json();
    if (!Array.isArray(orderData.items) || orderData.items.length === 0) {
      return jsonResponse4({ error: "Order must include at least one item" }, 400);
    }
    const requiredFields = ["customer_name", "customer_phone", "delivery_method"];
    for (const field of requiredFields) {
      if (!orderData[field]) {
        return jsonResponse4({ error: `Missing required field: ${field}` }, 400);
      }
    }
    const deliveryMethod = orderData.delivery_method;
    if (!["collection", "delivery"].includes(deliveryMethod)) {
      return jsonResponse4({ error: "delivery_method must be collection or delivery" }, 400);
    }
    const orderNumber = createOrderNumber();
    const deliveryFee = deliveryMethod === "delivery" ? 5 : 0;
    const itemsTotal = orderData.items.reduce((sum, item) => sum + (Number(item.price) || 0), 0);
    const providedTotal = Number(orderData.total_amount);
    const totalAmount = Number.isFinite(providedTotal) ? providedTotal : itemsTotal + deliveryFee;
    await DB.prepare(`
            INSERT INTO orders (
                order_number,
                customer_name,
                customer_phone,
                customer_email,
                delivery_method,
                delivery_address,
                delivery_city,
                delivery_eircode,
                total_amount,
                status,
                created_at,
                updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', datetime('now'), datetime('now'))
        `).bind(
      orderNumber,
      orderData.customer_name,
      orderData.customer_phone,
      orderData.customer_email || null,
      deliveryMethod,
      orderData.delivery_address || null,
      orderData.delivery_city || null,
      orderData.delivery_eircode || null,
      totalAmount
    ).run();
    for (const item of orderData.items) {
      await DB.prepare(`
                INSERT INTO order_items (
                    order_number,
                    product_id,
                    category,
                    size,
                    image_url,
                    created_at
                ) VALUES (?, ?, ?, ?, ?, datetime('now'))
            `).bind(
        orderNumber,
        item.product_id,
        item.category,
        item.size,
        item.image_url
      ).run();
    }
    const createdOrder = await fetchOrderWithItems(DB, orderNumber);
    if (createdOrder) {
      const orderEmail = deriveOrderEmail(createdOrder);
      if (orderEmail) {
        try {
          const notificationService = new notification_service_default(context.env);
          const notificationResult = await notificationService.sendOrderConfirmation(
            { ...createdOrder, email: orderEmail, user_email: orderEmail },
            mapItemsForNotification(orderData.items)
          );
          if (!notificationResult.success) {
            console.warn("Order confirmation email not sent:", notificationResult.reason || notificationResult.error);
          }
        } catch (notificationError) {
          console.error("Order confirmation notification failed:", notificationError);
        }
      }
    }
    await logAdminAction(context.env, check.session, "admin_order_created", `order_${orderNumber}`, {
      delivery_method: deliveryMethod,
      items: orderData.items.length,
      has_email: Boolean(orderData.customer_email)
    });
    return jsonResponse4({
      success: true,
      order_number: orderNumber,
      order: createdOrder,
      message: "Order created successfully"
    }, 201);
  } catch (error) {
    console.error("Orders POST Error:", error);
    return jsonResponse4({ error: "Failed to create order", message: error.message }, 500);
  }
}
async function onRequestPut(context) {
  try {
    const check = await requireAdminSession(context);
    if (check.error) return check.error;
    const { DB } = context.env;
    const body = await context.request.json();
    const orderNumber = body.order_number;
    const newStatus = normalizeStatus(body.status);
    const adminNotes = body.admin_notes;
    if (!orderNumber) {
      return jsonResponse4({ error: "order_number is required" }, 400);
    }
    const validStatuses = ["pending", "ready", "completed", "cancelled"];
    if (!validStatuses.includes(newStatus)) {
      return jsonResponse4({
        error: "Invalid status value",
        valid_statuses: validStatuses
      }, 400);
    }
    const existingOrder = await DB.prepare(`
            SELECT * FROM orders WHERE order_number = ?
        `).bind(orderNumber).first();
    if (!existingOrder) {
      return jsonResponse4({ error: "Order not found" }, 404);
    }
    await DB.prepare(`
            UPDATE orders
            SET status = ?,
                admin_notes = COALESCE(?, admin_notes),
                updated_at = datetime('now')
            WHERE order_number = ?
        `).bind(newStatus, adminNotes, orderNumber).run();
    const updatedOrder = await fetchOrderWithItems(DB, orderNumber) || existingOrder;
    const orderEmail = deriveOrderEmail(updatedOrder);
    if (orderEmail) {
      try {
        const notificationService = new notification_service_default(context.env);
        const notificationResult = await notificationService.sendOrderStatusUpdate(
          { ...updatedOrder, email: orderEmail, user_email: orderEmail },
          newStatus
        );
        if (!notificationResult.success) {
          console.warn("Status notification not delivered:", notificationResult.reason || notificationResult.error);
        }
      } catch (notificationError) {
        console.error("Status notification error:", notificationError);
      }
    }
    await logAdminAction(context.env, check.session, "admin_order_status_update", `order_${orderNumber}`, {
      old_status: existingOrder.status,
      new_status: newStatus
    });
    return jsonResponse4({
      success: true,
      message: `Order ${orderNumber} status updated to ${newStatus}`,
      order: updatedOrder
    });
  } catch (error) {
    console.error("Orders PUT Error:", error);
    return jsonResponse4({ error: "Failed to update order", message: error.message }, 500);
  }
}
async function onRequestDelete2(context) {
  try {
    const check = await requireAdminSession(context);
    if (check.error) return check.error;
    const { DB } = context.env;
    const url = new URL(context.request.url);
    const orderNumber = url.searchParams.get("order_number");
    if (!orderNumber) {
      return jsonResponse4({ error: "Missing order_number parameter" }, 400);
    }
    const existingOrder = await DB.prepare(`
            SELECT order_number FROM orders WHERE order_number = ?
        `).bind(orderNumber).first();
    if (!existingOrder) {
      return jsonResponse4({ error: "Order not found" }, 404);
    }
    await DB.prepare(`
            DELETE FROM order_items WHERE order_number = ?
        `).bind(orderNumber).run();
    await DB.prepare(`
            DELETE FROM orders WHERE order_number = ?
        `).bind(orderNumber).run();
    await logAdminAction(context.env, check.session, "admin_order_deleted", `order_${orderNumber}`);
    return jsonResponse4({
      success: true,
      message: `Order ${orderNumber} deleted successfully`
    });
  } catch (error) {
    console.error("Orders DELETE Error:", error);
    return jsonResponse4({ error: "Failed to delete order", message: error.message }, 500);
  }
}
var BASE_HEADERS;
var init_orders = __esm({
  "api/admin/orders.js"() {
    init_functionsRoutes_0_9937148203508366();
    init_notification_service();
    init_admin();
    init_security();
    BASE_HEADERS = {
      "Content-Type": "application/json",
      "Cache-Control": "no-cache"
    };
    __name(jsonResponse4, "jsonResponse");
    __name(requireAdminSession, "requireAdminSession");
    __name(fetchOrderWithItems, "fetchOrderWithItems");
    __name(attachItemsToOrders, "attachItemsToOrders");
    __name(deriveOrderEmail, "deriveOrderEmail");
    __name(mapItemsForNotification, "mapItemsForNotification");
    __name(normalizeStatus, "normalizeStatus");
    __name(createOrderNumber, "createOrderNumber");
    __name(onRequestGet4, "onRequestGet");
    __name(onRequestPost2, "onRequestPost");
    __name(onRequestPut, "onRequestPut");
    __name(onRequestDelete2, "onRequestDelete");
  }
});

// api/admin/products.js
function jsonResponse5(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization"
    }
  });
}
async function onRequestGet5(context) {
  const { request, env } = context;
  const url = new URL(request.url);
  try {
    const session = await verifyAdminAuth(request, env);
    if (!session) {
      return jsonResponse5({
        success: false,
        error: "Unauthorized - Admin access required"
      }, 401);
    }
    const category = url.searchParams.get("category");
    const status = url.searchParams.get("status") || "available";
    const search = url.searchParams.get("search");
    const sortBy = url.searchParams.get("sort") || "created_at";
    const sortOrder = url.searchParams.get("order") || "DESC";
    const limit = parseInt(url.searchParams.get("limit")) || 100;
    const offset = parseInt(url.searchParams.get("offset")) || 0;
    let query = `
            SELECT
                id,
                category,
                size,
                brand,
                description,
                condition,
                price,
                original_price,
                image_url,
                cloudflare_image_id,
                status,
                featured,
                sku,
                tags,
                created_at,
                updated_at,
                sold_at
            FROM products
            WHERE 1=1
        `;
    const params = [];
    if (category && category !== "all") {
      query += " AND category = ?";
      params.push(category);
    }
    if (status && status !== "all") {
      query += " AND status = ?";
      params.push(status);
    }
    if (search) {
      query += " AND (brand LIKE ? OR description LIKE ? OR sku LIKE ?)";
      const searchTerm = `%${search}%`;
      params.push(searchTerm, searchTerm, searchTerm);
    }
    const allowedSorts = ["created_at", "updated_at", "price", "brand", "category"];
    const sortColumn = allowedSorts.includes(sortBy) ? sortBy : "created_at";
    const sortDir = sortOrder.toUpperCase() === "ASC" ? "ASC" : "DESC";
    query += ` ORDER BY ${sortColumn} ${sortDir}`;
    query += " LIMIT ? OFFSET ?";
    params.push(limit, offset);
    const stmt = params.length > 0 ? env.DB.prepare(query).bind(...params) : env.DB.prepare(query);
    const products = await stmt.all();
    let countQuery = "SELECT COUNT(*) as total FROM products WHERE 1=1";
    const countParams = [];
    if (category && category !== "all") {
      countQuery += " AND category = ?";
      countParams.push(category);
    }
    if (status && status !== "all") {
      countQuery += " AND status = ?";
      countParams.push(status);
    }
    if (search) {
      countQuery += " AND (brand LIKE ? OR description LIKE ? OR sku LIKE ?)";
      const searchTerm = `%${search}%`;
      countParams.push(searchTerm, searchTerm, searchTerm);
    }
    const countStmt = countParams.length > 0 ? env.DB.prepare(countQuery).bind(...countParams) : env.DB.prepare(countQuery);
    const countResult = await countStmt.first();
    await logAdminAction(env, session, "products_list_view", null, {
      filters: { category, status, search },
      result_count: products.results?.length || 0
    });
    return jsonResponse5({
      success: true,
      data: {
        products: products.results || [],
        pagination: {
          total: countResult?.total || 0,
          limit,
          offset,
          has_more: offset + limit < (countResult?.total || 0)
        }
      }
    });
  } catch (error) {
    console.error("\u274C Error fetching products:", error);
    return jsonResponse5({
      success: false,
      error: "Failed to fetch products",
      details: error.message
    }, 500);
  }
}
async function onRequestPost3(context) {
  const { request, env } = context;
  try {
    const session = await verifyAdminAuth(request, env);
    if (!session) {
      return jsonResponse5({
        success: false,
        error: "Unauthorized - Admin access required"
      }, 401);
    }
    const body = await request.json();
    const required = ["category", "size", "brand", "price"];
    for (const field of required) {
      if (!body[field]) {
        return jsonResponse5({
          success: false,
          error: `Missing required field: ${field}`
        }, 400);
      }
    }
    const validCategories = ["BN-CLOTHES", "BN-SHOES", "PO-CLOTHES", "PO-SHOES"];
    if (!validCategories.includes(body.category)) {
      return jsonResponse5({
        success: false,
        error: "Invalid category. Must be one of: " + validCategories.join(", ")
      }, 400);
    }
    const validConditions = ["new", "excellent", "good"];
    const condition = body.condition || "new";
    if (!validConditions.includes(condition)) {
      return jsonResponse5({
        success: false,
        error: "Invalid condition. Must be one of: " + validConditions.join(", ")
      }, 400);
    }
    const sku = body.sku || generateSKU(body.category, body.brand);
    const result = await env.DB.prepare(`
            INSERT INTO products (
                category, size, brand, description, condition,
                price, original_price, image_url, cloudflare_image_id,
                status, featured, sku, tags, created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
        `).bind(
      body.category,
      body.size,
      body.brand,
      body.description || null,
      condition,
      body.price,
      body.original_price || null,
      body.image_url || null,
      body.cloudflare_image_id || null,
      body.status || "available",
      body.featured ? 1 : 0,
      sku,
      body.tags ? JSON.stringify(body.tags) : null
    ).run();
    const productId = result.meta?.last_row_id;
    const product = await env.DB.prepare(
      "SELECT * FROM products WHERE id = ?"
    ).bind(productId).first();
    await logAdminAction(env, session, "product_create", `product_${productId}`, {
      product_id: productId,
      category: body.category,
      brand: body.brand,
      price: body.price
    });
    console.log(`\u2705 Product created: ${productId} - ${body.brand} ${body.category}`);
    return jsonResponse5({
      success: true,
      message: "Product created successfully",
      data: { product }
    }, 201);
  } catch (error) {
    console.error("\u274C Error creating product:", error);
    return jsonResponse5({
      success: false,
      error: "Failed to create product",
      details: error.message
    }, 500);
  }
}
async function onRequestPut2(context) {
  const { request, env } = context;
  const url = new URL(request.url);
  try {
    const session = await verifyAdminAuth(request, env);
    if (!session) {
      return jsonResponse5({
        success: false,
        error: "Unauthorized - Admin access required"
      }, 401);
    }
    const pathParts = url.pathname.split("/");
    const productId = pathParts[pathParts.length - 1];
    if (!productId || isNaN(productId)) {
      return jsonResponse5({
        success: false,
        error: "Invalid product ID"
      }, 400);
    }
    const existingProduct = await env.DB.prepare(
      "SELECT * FROM products WHERE id = ?"
    ).bind(productId).first();
    if (!existingProduct) {
      return jsonResponse5({
        success: false,
        error: "Product not found"
      }, 404);
    }
    const body = await request.json();
    const updates = [];
    const params = [];
    const allowedFields = [
      "category",
      "size",
      "brand",
      "description",
      "condition",
      "price",
      "original_price",
      "image_url",
      "cloudflare_image_id",
      "status",
      "featured",
      "sku",
      "tags"
    ];
    for (const field of allowedFields) {
      if (body[field] !== void 0) {
        updates.push(`${field} = ?`);
        if (field === "featured") {
          params.push(body[field] ? 1 : 0);
        } else if (field === "tags" && typeof body[field] === "object") {
          params.push(JSON.stringify(body[field]));
        } else {
          params.push(body[field]);
        }
      }
    }
    if (updates.length === 0) {
      return jsonResponse5({
        success: false,
        error: "No valid fields to update"
      }, 400);
    }
    updates.push('updated_at = datetime("now")');
    if (body.status === "sold" && existingProduct.status !== "sold") {
      updates.push('sold_at = datetime("now")');
    }
    params.push(productId);
    await env.DB.prepare(`
            UPDATE products
            SET ${updates.join(", ")}
            WHERE id = ?
        `).bind(...params).run();
    const updatedProduct = await env.DB.prepare(
      "SELECT * FROM products WHERE id = ?"
    ).bind(productId).first();
    await logAdminAction(env, session, "product_update", `product_${productId}`, {
      product_id: productId,
      updated_fields: Object.keys(body),
      previous_status: existingProduct.status,
      new_status: body.status || existingProduct.status
    });
    console.log(`\u2705 Product updated: ${productId}`);
    return jsonResponse5({
      success: true,
      message: "Product updated successfully",
      data: { product: updatedProduct }
    });
  } catch (error) {
    console.error("\u274C Error updating product:", error);
    return jsonResponse5({
      success: false,
      error: "Failed to update product",
      details: error.message
    }, 500);
  }
}
async function onRequestDelete3(context) {
  const { request, env } = context;
  const url = new URL(request.url);
  try {
    const session = await verifyAdminAuth(request, env);
    if (!session) {
      return jsonResponse5({
        success: false,
        error: "Unauthorized - Admin access required"
      }, 401);
    }
    const pathParts = url.pathname.split("/");
    const productId = pathParts[pathParts.length - 1];
    if (!productId || isNaN(productId)) {
      return jsonResponse5({
        success: false,
        error: "Invalid product ID"
      }, 400);
    }
    const product = await env.DB.prepare(
      "SELECT * FROM products WHERE id = ?"
    ).bind(productId).first();
    if (!product) {
      return jsonResponse5({
        success: false,
        error: "Product not found"
      }, 404);
    }
    await env.DB.prepare(`
            UPDATE products
            SET status = 'removed', updated_at = datetime('now')
            WHERE id = ?
        `).bind(productId).run();
    await logAdminAction(env, session, "product_delete", `product_${productId}`, {
      product_id: productId,
      brand: product.brand,
      category: product.category,
      sku: product.sku
    });
    console.log(`\u2705 Product deleted (soft): ${productId} - ${product.brand}`);
    return jsonResponse5({
      success: true,
      message: "Product deleted successfully"
    });
  } catch (error) {
    console.error("\u274C Error deleting product:", error);
    return jsonResponse5({
      success: false,
      error: "Failed to delete product",
      details: error.message
    }, 500);
  }
}
async function onRequestOptions3(context) {
  return jsonResponse5(null, 204);
}
function generateSKU(category, brand) {
  const prefix = category.substring(0, 2);
  const brandPrefix = brand.substring(0, 3).toUpperCase();
  const timestamp = Date.now().toString(36).toUpperCase().slice(-6);
  return `${prefix}-${brandPrefix}-${timestamp}`;
}
var init_products = __esm({
  "api/admin/products.js"() {
    init_functionsRoutes_0_9937148203508366();
    init_admin();
    __name(jsonResponse5, "jsonResponse");
    __name(onRequestGet5, "onRequestGet");
    __name(onRequestPost3, "onRequestPost");
    __name(onRequestPut2, "onRequestPut");
    __name(onRequestDelete3, "onRequestDelete");
    __name(onRequestOptions3, "onRequestOptions");
    __name(generateSKU, "generateSKU");
  }
});

// api/admin/update-image-metadata.js
async function sha256b642(text) {
  const encoder = new TextEncoder();
  const data = encoder.encode(text);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = new Uint8Array(hashBuffer);
  return btoa(String.fromCharCode(...hashArray));
}
async function onRequestPatch({ request, env }) {
  const cookie = request.headers.get("Cookie") || "";
  const sessionId = cookie.split("sbs_session=")[1]?.split(";")[0];
  if (!sessionId) {
    return new Response(JSON.stringify({
      success: false,
      error: "Not authenticated"
    }), {
      status: 401,
      headers: { "Content-Type": "application/json" }
    });
  }
  try {
    const sessionHash = await sha256b642(sessionId);
    const sessionResult = await env.DB.prepare(
      "SELECT user_id, expires_at FROM sessions WHERE token = ? AND invalidated_at IS NULL"
    ).bind(sessionHash).first();
    if (!sessionResult) {
      return new Response(JSON.stringify({
        success: false,
        error: "Session not found. Please log in again."
      }), {
        status: 401,
        headers: { "Content-Type": "application/json" }
      });
    }
    const now = (/* @__PURE__ */ new Date()).toISOString();
    if (sessionResult.expires_at < now) {
      return new Response(JSON.stringify({
        success: false,
        error: "Session expired. Please log in again."
      }), {
        status: 401,
        headers: { "Content-Type": "application/json" }
      });
    }
    const userResult = await env.DB.prepare(
      "SELECT role FROM users WHERE id = ?"
    ).bind(sessionResult.user_id).first();
    if (!userResult || userResult.role !== "admin") {
      return new Response(JSON.stringify({
        success: false,
        error: "Admin access required"
      }), {
        status: 403,
        headers: { "Content-Type": "application/json" }
      });
    }
    const { imageId, metadata } = await request.json();
    if (!imageId || !metadata) {
      return new Response(JSON.stringify({
        success: false,
        error: "Missing imageId or metadata"
      }), {
        status: 400,
        headers: { "Content-Type": "application/json" }
      });
    }
    const accountId = env.CLOUDFLARE_ACCOUNT_ID;
    const apiToken = env.CLOUDFLARE_IMAGES_API_TOKEN || env.CLOUDFLARE_API_TOKEN;
    if (!accountId || !apiToken) {
      return new Response(JSON.stringify({
        success: false,
        error: "Missing Cloudflare credentials"
      }), {
        status: 500,
        headers: { "Content-Type": "application/json" }
      });
    }
    const updateUrl = `https://api.cloudflare.com/client/v4/accounts/${accountId}/images/v1/${imageId}`;
    const updateResponse = await fetch(updateUrl, {
      method: "PATCH",
      headers: {
        "Authorization": `Bearer ${apiToken}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ metadata })
    });
    const updateResult = await updateResponse.json();
    if (!updateResponse.ok || !updateResult.success) {
      console.error("CF Images update failed:", updateResult);
      return new Response(JSON.stringify({
        success: false,
        error: updateResult.errors?.[0]?.message || "Failed to update image metadata"
      }), {
        status: updateResponse.status,
        headers: { "Content-Type": "application/json" }
      });
    }
    return new Response(JSON.stringify({
      success: true,
      message: "Metadata updated successfully",
      imageId
    }), {
      status: 200,
      headers: { "Content-Type": "application/json" }
    });
  } catch (error) {
    console.error("Update metadata error:", error);
    return new Response(JSON.stringify({
      success: false,
      error: error.message || "Internal server error"
    }), {
      status: 500,
      headers: { "Content-Type": "application/json" }
    });
  }
}
var init_update_image_metadata = __esm({
  "api/admin/update-image-metadata.js"() {
    init_functionsRoutes_0_9937148203508366();
    __name(sha256b642, "sha256b64");
    __name(onRequestPatch, "onRequestPatch");
  }
});

// api/admin/upload-image.js
async function sha256b643(text) {
  const encoder = new TextEncoder();
  const data = encoder.encode(text);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = new Uint8Array(hashBuffer);
  return btoa(String.fromCharCode(...hashArray));
}
async function onRequestPost4({ request, env }) {
  const cookie = request.headers.get("Cookie") || "";
  const sessionId = cookie.split("sbs_session=")[1]?.split(";")[0];
  if (!sessionId) {
    return new Response(JSON.stringify({
      success: false,
      error: "Not authenticated"
    }), {
      status: 401,
      headers: { "Content-Type": "application/json" }
    });
  }
  try {
    const sessionHash = await sha256b643(sessionId);
    const sessionResult = await env.DB.prepare(
      "SELECT user_id, expires_at FROM sessions WHERE token = ? AND invalidated_at IS NULL"
    ).bind(sessionHash).first();
    if (!sessionResult) {
      return new Response(JSON.stringify({
        success: false,
        error: "Session not found. Please log in again."
      }), {
        status: 401,
        headers: { "Content-Type": "application/json" }
      });
    }
    const now = (/* @__PURE__ */ new Date()).toISOString();
    if (sessionResult.expires_at < now) {
      return new Response(JSON.stringify({
        success: false,
        error: "Session expired. Please log in again."
      }), {
        status: 401,
        headers: { "Content-Type": "application/json" }
      });
    }
    const userResult = await env.DB.prepare(
      "SELECT role FROM users WHERE id = ?"
    ).bind(sessionResult.user_id).first();
    if (!userResult) {
      return new Response(JSON.stringify({
        success: false,
        error: "User not found."
      }), {
        status: 401,
        headers: { "Content-Type": "application/json" }
      });
    }
    if (userResult.role !== "admin") {
      return new Response(JSON.stringify({
        success: false,
        error: "Admin access required. Your account role is: " + (userResult.role || "user")
      }), {
        status: 403,
        headers: { "Content-Type": "application/json" }
      });
    }
    const formData = await request.formData();
    const file = formData.get("file");
    const filename = formData.get("filename");
    const metadataJson = formData.get("metadata");
    if (!file) {
      return new Response(JSON.stringify({
        success: false,
        error: "No file provided"
      }), {
        status: 400,
        headers: { "Content-Type": "application/json" }
      });
    }
    let uploadMetadata = {};
    if (metadataJson) {
      try {
        uploadMetadata = JSON.parse(metadataJson);
      } catch (e) {
        console.warn("Failed to parse metadata:", e);
      }
    }
    const accountId = env.CLOUDFLARE_ACCOUNT_ID;
    const apiToken = env.CLOUDFLARE_IMAGES_API_TOKEN || env.CLOUDFLARE_API_TOKEN;
    if (!accountId || !apiToken) {
      return new Response(JSON.stringify({
        success: false,
        error: "Missing Cloudflare credentials"
      }), {
        status: 500,
        headers: { "Content-Type": "application/json" }
      });
    }
    const cleanFilename = filename || file.name || "untitled";
    let productName = cleanFilename.replace(/\.(jpg|jpeg|png|webp|gif)$/i, "").replace(/DESC-([^-]+)-CAT/i, "$1").replace(/CAT-[^-]+-SIZE-[^-]+-/gi, "").replace(/DATE-\d+-/gi, "").replace(/TIME-\d+-/gi, "").replace(/BATCH-[^-]+-/gi, "").replace(/ITEM-\d+/gi, "").replace(/[-_]/g, " ").trim();
    if (!productName || productName.length < 3) {
      const category = uploadMetadata.category || "Unknown";
      const size = uploadMetadata.size || "";
      productName = `${category.replace("-", " ")} ${size}`.trim();
    }
    productName = productName.split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(" ");
    const cfMetadata = {
      // Product Info - what shop reads
      name: uploadMetadata.description || productName,
      // Use description as name if provided
      category: uploadMetadata.category || "",
      // BN-CLOTHES, BN-SHOES, etc.
      size: uploadMetadata.size || "",
      brand: "",
      // Can be set later via edit
      // Inventory status
      status: "active",
      // active, hidden, sold
      stock: "1",
      // String format for CF Images
      // Additional Info
      description: uploadMetadata.description || productName,
      sku: "",
      // Auto-generated by products.js
      featured: "false",
      // Tracking (optional)
      batch: uploadMetadata.batch || "",
      item: uploadMetadata.item || "",
      originalName: uploadMetadata.originalName || file.name
    };
    const uploadFormData = new FormData();
    uploadFormData.append("file", file);
    uploadFormData.append("metadata", JSON.stringify(cfMetadata));
    const uploadUrl = `https://api.cloudflare.com/client/v4/accounts/${accountId}/images/v1`;
    const uploadResponse = await fetch(uploadUrl, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${apiToken}`
      },
      body: uploadFormData
    });
    const uploadResult = await uploadResponse.json();
    if (!uploadResponse.ok || !uploadResult.success) {
      console.error("CF Images upload failed:", uploadResult);
      return new Response(JSON.stringify({
        success: false,
        error: uploadResult.errors?.[0]?.message || "Failed to upload image to Cloudflare"
      }), {
        status: uploadResponse.status,
        headers: { "Content-Type": "application/json" }
      });
    }
    const imageId = uploadResult.result.id;
    try {
      await env.DB.prepare(`
                INSERT INTO products (
                    image_id, category, size, condition, 
                    status, quantity_total, quantity_available,
                    created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
            `).bind(
        imageId,
        cfMetadata.category || "BN-CLOTHES",
        cfMetadata.size || null,
        uploadMetadata.category?.includes("BN") ? "Brand New" : "Pre-Owned",
        cfMetadata.status || "active",
        1,
        // quantity_total
        1
        // quantity_available
      ).run();
      console.log(`\u2705 Product ${imageId} synced to D1 inventory`);
    } catch (dbError) {
      console.warn("\u26A0\uFE0F D1 sync failed (non-critical):", dbError.message);
    }
    return new Response(JSON.stringify({
      success: true,
      message: "Image uploaded successfully with metadata and synced to smart inventory",
      uploadedId: imageId,
      filename: cleanFilename,
      metadata: cfMetadata,
      productName: cfMetadata.name,
      d1_synced: true
    }), {
      status: 200,
      headers: { "Content-Type": "application/json" }
    });
  } catch (error) {
    console.error("Upload error:", error);
    return new Response(JSON.stringify({
      success: false,
      error: error.message || "Internal server error"
    }), {
      status: 500,
      headers: { "Content-Type": "application/json" }
    });
  }
}
var init_upload_image = __esm({
  "api/admin/upload-image.js"() {
    init_functionsRoutes_0_9937148203508366();
    __name(sha256b643, "sha256b64");
    __name(onRequestPost4, "onRequestPost");
  }
});

// api/analytics/sync.js
async function onRequestPost5(context) {
  const { request, env } = context;
  try {
    const authHeader = request.headers.get("Authorization");
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return jsonResponse6({ success: false, error: "Unauthorized" }, 401);
    }
    const token = authHeader.substring(7);
    const session = await env.DB.prepare(`
            SELECT user_id FROM admin_sessions 
            WHERE token = ? AND datetime(expires_at) > datetime('now')
        `).bind(token).first();
    if (!session) {
      return jsonResponse6({ success: false, error: "Invalid session" }, 401);
    }
    const startTime = Date.now();
    const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    console.log(`\u{1F4CA} Starting analytics sync for ${today}`);
    const summary = await env.DB.prepare(`
            SELECT 
                COUNT(DISTINCT session_id) as unique_visitors,
                COUNT(*) FILTER (WHERE event_type = 'page_view') as page_views,
                COUNT(*) FILTER (WHERE event_type = 'product_view') as products_viewed,
                COUNT(DISTINCT product_id) FILTER (WHERE event_type = 'product_view' AND product_id IS NOT NULL) as unique_products_viewed,
                COUNT(*) FILTER (WHERE event_type = 'add_to_cart') as cart_adds,
                COUNT(*) FILTER (WHERE event_type = 'checkout_initiated') as checkouts_initiated,
                COUNT(*) FILTER (WHERE event_type = 'purchase') as orders_completed,
                SUM(value) FILTER (WHERE event_type = 'purchase') as revenue,
                SUM(quantity) FILTER (WHERE event_type = 'purchase') as items_sold,
                COUNT(*) FILTER (WHERE event_type = 'search') as total_searches,
                COUNT(DISTINCT json_extract(metadata, '$.search_term')) FILTER (WHERE event_type = 'search') as unique_search_terms
            FROM analytics_events
            WHERE DATE(created_at) = ?
        `).bind(today).first();
    const conversionRate = summary.unique_visitors > 0 ? (summary.orders_completed / summary.unique_visitors * 100).toFixed(2) : 0;
    const cartAbandonmentRate = summary.cart_adds > 0 ? ((summary.cart_adds - summary.orders_completed) / summary.cart_adds * 100).toFixed(2) : 0;
    const addToCartRate = summary.products_viewed > 0 ? (summary.cart_adds / summary.products_viewed * 100).toFixed(2) : 0;
    const avgOrderValue = summary.orders_completed > 0 ? (summary.revenue / summary.orders_completed).toFixed(2) : 0;
    const topProduct = await env.DB.prepare(`
            SELECT product_id, COUNT(*) as view_count
            FROM analytics_events
            WHERE DATE(created_at) = ? AND event_type = 'product_view' AND product_id IS NOT NULL
            GROUP BY product_id
            ORDER BY view_count DESC
            LIMIT 1
        `).bind(today).first();
    const topCategory = await env.DB.prepare(`
            SELECT category, COUNT(*) as count
            FROM analytics_events
            WHERE DATE(created_at) = ? AND category IS NOT NULL
            GROUP BY category
            ORDER BY count DESC
            LIMIT 1
        `).bind(today).first();
    const topBrand = await env.DB.prepare(`
            SELECT brand, COUNT(*) as count
            FROM analytics_events
            WHERE DATE(created_at) = ? AND brand IS NOT NULL
            GROUP BY brand
            ORDER BY count DESC
            LIMIT 1
        `).bind(today).first();
    const topSearch = await env.DB.prepare(`
            SELECT json_extract(metadata, '$.search_term') as search_term, COUNT(*) as count
            FROM analytics_events
            WHERE DATE(created_at) = ? AND event_type = 'search'
            GROUP BY search_term
            ORDER BY count DESC
            LIMIT 1
        `).bind(today).first();
    await env.DB.prepare(`
            INSERT INTO analytics_daily_summary 
            (date, unique_visitors, page_views, products_viewed, unique_products_viewed,
             cart_adds, checkouts_initiated, orders_completed, revenue, avg_order_value,
             items_sold, conversion_rate, cart_abandonment_rate, add_to_cart_rate,
             top_product_id, top_product_views, top_category, top_brand, total_searches,
             unique_search_terms, top_search_term, synced_at, updated_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ON CONFLICT(date) DO UPDATE SET
                unique_visitors = excluded.unique_visitors,
                page_views = excluded.page_views,
                products_viewed = excluded.products_viewed,
                unique_products_viewed = excluded.unique_products_viewed,
                cart_adds = excluded.cart_adds,
                checkouts_initiated = excluded.checkouts_initiated,
                orders_completed = excluded.orders_completed,
                revenue = excluded.revenue,
                avg_order_value = excluded.avg_order_value,
                items_sold = excluded.items_sold,
                conversion_rate = excluded.conversion_rate,
                cart_abandonment_rate = excluded.cart_abandonment_rate,
                add_to_cart_rate = excluded.add_to_cart_rate,
                top_product_id = excluded.top_product_id,
                top_product_views = excluded.top_product_views,
                top_category = excluded.top_category,
                top_brand = excluded.top_brand,
                total_searches = excluded.total_searches,
                unique_search_terms = excluded.unique_search_terms,
                top_search_term = excluded.top_search_term,
                synced_at = excluded.synced_at,
                updated_at = excluded.updated_at
        `).bind(
      today,
      summary.unique_visitors,
      summary.page_views,
      summary.products_viewed,
      summary.unique_products_viewed,
      summary.cart_adds,
      summary.checkouts_initiated,
      summary.orders_completed,
      summary.revenue || 0,
      avgOrderValue,
      summary.items_sold || 0,
      conversionRate,
      cartAbandonmentRate,
      addToCartRate,
      topProduct?.product_id || null,
      topProduct?.view_count || 0,
      topCategory?.category || null,
      topBrand?.brand || null,
      summary.total_searches,
      summary.unique_search_terms,
      topSearch?.search_term || null,
      (/* @__PURE__ */ new Date()).toISOString(),
      (/* @__PURE__ */ new Date()).toISOString()
    ).run();
    const productStats = await env.DB.prepare(`
            SELECT 
                product_id,
                json_extract(metadata, '$.product_name') as product_name,
                json_extract(metadata, '$.category') as category,
                json_extract(metadata, '$.brand') as brand,
                json_extract(metadata, '$.price') as price,
                COUNT(*) FILTER (WHERE event_type = 'product_view') as views,
                COUNT(DISTINCT session_id) FILTER (WHERE event_type = 'product_view') as unique_viewers,
                COUNT(*) FILTER (WHERE event_type = 'add_to_cart') as cart_adds,
                COUNT(*) FILTER (WHERE event_type = 'purchase') as purchases,
                SUM(value) FILTER (WHERE event_type = 'purchase') as revenue,
                SUM(quantity) FILTER (WHERE event_type = 'purchase') as units_sold
            FROM analytics_events
            WHERE DATE(created_at) = ? AND product_id IS NOT NULL
            GROUP BY product_id
        `).bind(today).all();
    for (const product of productStats.results || []) {
      const viewToCartRate = product.views > 0 ? (product.cart_adds / product.views * 100).toFixed(2) : 0;
      const cartToPurchaseRate = product.cart_adds > 0 ? (product.purchases / product.cart_adds * 100).toFixed(2) : 0;
      const overallConversionRate = product.views > 0 ? (product.purchases / product.views * 100).toFixed(2) : 0;
      await env.DB.prepare(`
                INSERT INTO analytics_product_performance
                (product_id, date, views, unique_viewers, cart_adds, purchases,
                 revenue, units_sold, view_to_cart_rate, cart_to_purchase_rate,
                 overall_conversion_rate, product_name, category, brand, price, synced_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ON CONFLICT(product_id, date) DO UPDATE SET
                    views = excluded.views,
                    unique_viewers = excluded.unique_viewers,
                    cart_adds = excluded.cart_adds,
                    purchases = excluded.purchases,
                    revenue = excluded.revenue,
                    units_sold = excluded.units_sold,
                    view_to_cart_rate = excluded.view_to_cart_rate,
                    cart_to_purchase_rate = excluded.cart_to_purchase_rate,
                    overall_conversion_rate = excluded.overall_conversion_rate,
                    synced_at = excluded.synced_at
            `).bind(
        product.product_id,
        today,
        product.views,
        product.unique_viewers,
        product.cart_adds,
        product.purchases,
        product.revenue || 0,
        product.units_sold || 0,
        viewToCartRate,
        cartToPurchaseRate,
        overallConversionRate,
        product.product_name,
        product.category,
        product.brand,
        product.price,
        (/* @__PURE__ */ new Date()).toISOString()
      ).run();
    }
    const duration = Date.now() - startTime;
    await env.DB.prepare(`
            INSERT INTO analytics_sync_log
            (sync_type, sync_date, status, events_processed, records_updated, duration_ms, started_at, completed_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `).bind(
      "daily_summary",
      today,
      "success",
      summary.page_views || 0,
      1 + (productStats.results?.length || 0),
      duration,
      new Date(startTime).toISOString(),
      (/* @__PURE__ */ new Date()).toISOString()
    ).run();
    console.log(`\u2705 Analytics sync completed in ${duration}ms`);
    return jsonResponse6({
      success: true,
      sync_date: today,
      summary: {
        unique_visitors: summary.unique_visitors,
        page_views: summary.page_views,
        orders_completed: summary.orders_completed,
        revenue: summary.revenue || 0,
        conversion_rate: conversionRate,
        products_synced: productStats.results?.length || 0
      },
      duration_ms: duration
    });
  } catch (error) {
    console.error("\u274C Analytics sync error:", error);
    return jsonResponse6({
      success: false,
      error: error.message
    }, 500);
  }
}
function jsonResponse6(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*"
    }
  });
}
var init_sync = __esm({
  "api/analytics/sync.js"() {
    init_functionsRoutes_0_9937148203508366();
    __name(onRequestPost5, "onRequestPost");
    __name(jsonResponse6, "jsonResponse");
  }
});

// api/analytics/track.js
async function onRequestPost6(context) {
  const { request, env } = context;
  const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "POST, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type",
    "Content-Type": "application/json"
  };
  if (request.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }
  try {
    const { events } = await request.json();
    if (!events || !Array.isArray(events) || events.length === 0) {
      return new Response(JSON.stringify({
        success: false,
        error: "Invalid events data"
      }), {
        status: 400,
        headers: corsHeaders
      });
    }
    console.log(`\u{1F4CA} Tracking ${events.length} events`);
    const insertPromises = events.map((event) => {
      return env.DB.prepare(`
                INSERT INTO analytics_events 
                (event_type, session_id, user_id, product_id, category, brand, metadata, value, user_agent, created_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
            `).bind(
        event.event_type,
        event.session_id,
        event.user_id || null,
        event.product_id || null,
        event.category || null,
        event.brand || null,
        JSON.stringify(event),
        // Store full event as JSON in metadata
        event.value || 0,
        event.user_agent || event.userAgent || null
      ).run();
    });
    await Promise.all(insertPromises);
    return new Response(JSON.stringify({
      success: true,
      tracked: events.length,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    }), {
      status: 200,
      headers: corsHeaders
    });
  } catch (error) {
    console.error("\u274C Analytics tracking error:", error);
    return new Response(JSON.stringify({
      success: false,
      error: error.message,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    }), {
      status: 500,
      headers: corsHeaders
    });
  }
}
var init_track = __esm({
  "api/analytics/track.js"() {
    init_functionsRoutes_0_9937148203508366();
    __name(onRequestPost6, "onRequestPost");
  }
});

// api/cases/submit.js
async function onRequestPost7(context) {
  const { request, env } = context;
  try {
    const data = await request.json();
    const required = ["category", "brand", "condition", "price", "address", "city", "phone", "socialChannel", "socialHandle"];
    for (const field of required) {
      if (!data[field]) {
        return Response.json({ error: `Missing required field: ${field}` }, { status: 400 });
      }
    }
    const authHeader = request.headers.get("Authorization");
    const token = authHeader?.replace("Bearer ", "");
    let userId = null;
    if (token) {
      const session = await env.DB.prepare(
        'SELECT user_id FROM sessions WHERE token = ? AND expires_at > datetime("now")'
      ).bind(token).first();
      if (session) {
        userId = session.user_id;
      }
    }
    const year = (/* @__PURE__ */ new Date()).getFullYear();
    const caseNumber = await getNextCaseNumber(env.DB, year);
    const caseId = `CASE-${year}-${String(caseNumber).padStart(3, "0")}`;
    const insertResult = await env.DB.prepare(`
            INSERT INTO sell_cases (
                case_id, user_id, category, brand, condition, size, price,
                address, city, eircode, defects,
                phone, preferred_contact, social_handle, email,
                photo_count, save_profile
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `).bind(
      caseId,
      userId,
      // Will be NULL if not logged in, integer if logged in
      data.category,
      data.brand,
      data.condition,
      data.size || null,
      data.price,
      data.address,
      data.city,
      data.eircode || null,
      data.defects || null,
      data.phone,
      data.socialChannel,
      data.socialHandle,
      data.email || null,
      data.uploadedFiles ? data.uploadedFiles.length : 0,
      data.saveProfile ? 1 : 0
    ).run();
    if (data.uploadedFiles && data.uploadedFiles.length > 0) {
      for (const file of data.uploadedFiles) {
        const newKey = `cases/${caseId}/${file.filename}`;
        const tempObject = await env.USER_UPLOADS.get(file.r2Key);
        if (tempObject) {
          await env.USER_UPLOADS.put(newKey, tempObject.body, {
            httpMetadata: {
              contentType: file.mimeType
            },
            customMetadata: {
              caseId,
              originalName: file.filename,
              uploadedAt: (/* @__PURE__ */ new Date()).toISOString()
            }
          });
          await env.USER_UPLOADS.delete(file.r2Key);
          await env.DB.prepare(`
                        INSERT INTO case_photos (case_id, filename, r2_key, file_size, mime_type)
                        VALUES (?, ?, ?, ?, ?)
                    `).bind(caseId, file.filename, newKey, file.size, file.mimeType).run();
        }
      }
    }
    if (data.saveProfile && data.email) {
      const emailResult = await sendRegistrationEmail(env, {
        caseId,
        email: data.email,
        socialHandle: data.socialHandle,
        socialChannel: data.socialChannel,
        city: data.city
      });
      if (emailResult.sent) {
        await env.DB.prepare(`
                    UPDATE sell_cases SET registration_email_sent = 1 WHERE case_id = ?
                `).bind(caseId).run();
      } else {
        console.warn(`\u26A0\uFE0F Registration email skipped for case ${caseId}:`, emailResult.reason);
      }
    }
    return Response.json({
      success: true,
      caseId,
      message: "Case submitted successfully",
      photosUploaded: data.uploadedFiles ? data.uploadedFiles.length : 0
    });
  } catch (error) {
    console.error("Case submission error:", error);
    return Response.json({
      error: "Submission failed",
      details: error.message
    }, { status: 500 });
  }
}
async function getNextCaseNumber(db, year) {
  const result = await db.prepare(`
        SELECT MAX(CAST(SUBSTR(case_id, -3) AS INTEGER)) as max_num
        FROM sell_cases
        WHERE case_id LIKE ?
    `).bind(`CASE-${year}-%`).first();
  return (result?.max_num || 0) + 1;
}
async function sendRegistrationEmail(env, payload) {
  const apiKey = env.RESEND_API_KEY;
  if (!apiKey) {
    return { sent: false, reason: "RESEND_API_KEY not configured" };
  }
  try {
    const response = await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        from: "SBS Team <noreply@thesbsofficial.com>",
        to: [payload.email],
        subject: "\u{1F44B} Welcome to SBS \u2014 Let\u2019s get you set up",
        html: buildRegistrationEmailHtml(payload)
      })
    });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Resend error ${response.status}: ${errorText}`);
    }
    const result = await response.json();
    console.log(`\u2705 Registration email sent for case ${payload.caseId}:`, result.id);
    return { sent: true, id: result.id };
  } catch (error) {
    console.error("Registration email send failed:", error);
    return { sent: false, reason: error.message };
  }
}
function buildRegistrationEmailHtml({ caseId, socialHandle, socialChannel, city }) {
  const handle = socialHandle ? `@${socialHandle}` : "your profile";
  const channelLabel = socialChannel === "snapchat" ? "Snapchat" : "Instagram";
  const location = city ? ` in ${city}` : "";
  return `
        <div style="font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background:#0a0a0a; color:#fff; padding:32px;">
            <div style="max-width:560px; margin:0 auto; background:#141414; border:1px solid rgba(255,215,0,0.2); border-radius:18px; overflow:hidden;">
                <div style="padding:32px; text-align:center; background:linear-gradient(135deg, rgba(255,215,0,0.12), transparent);">
                    <h1 style="margin:0; font-size:28px; letter-spacing:1px; color:#ffd700;">Welcome to SBS</h1>
                    <p style="margin:12px 0 0; font-size:16px; color:#f5f5f5;">We received your sell request ${location}.</p>
                </div>
                <div style="padding:32px;">
                    <p style="margin:0 0 16px; font-size:16px; color:#f5f5f5;">
                        Thanks for trusting us with your drop! Your submission <strong>${caseId}</strong> is in the queue.
                    </p>
                    <div style="background:rgba(255,215,0,0.08); border-radius:12px; padding:20px; margin-bottom:20px;">
                        <p style="margin:0; font-size:15px; color:#ffd700; font-weight:600;">Submission Snapshot</p>
                        <ul style="margin:12px 0 0; padding-left:18px; color:#e5e5e5; font-size:14px; line-height:1.6;">
                            <li>Handle: <strong>${handle}</strong> (${channelLabel})</li>
                            <li>Status: Pending review by the SBS buying team</li>
                            <li>Response: We aim to reply within 60 minutes during service hours</li>
                        </ul>
                    </div>
                    <p style="margin:0 0 16px; font-size:15px; color:#d1d1d1;">
                        Want faster checkouts and same-day collection updates? Finish setting up your SBS seller profile and we\u2019ll keep everything synced automatically.
                    </p>
                    <div style="text-align:center; margin:32px 0;">
                        <a href="https://thesbsofficial.com/register" style="display:inline-block; padding:14px 28px; background:linear-gradient(135deg,#ffd700,#ffc400); color:#000; font-weight:700; border-radius:999px; text-decoration:none; letter-spacing:0.5px;">Complete Your Profile</a>
                    </div>
                    <p style="margin:0; font-size:13px; color:#888; text-align:center;">
                        Questions? Reply to this email or DM us on Instagram. We\u2019re here to help.
                    </p>
                </div>
            </div>
        </div>
    `;
}
var init_submit = __esm({
  "api/cases/submit.js"() {
    init_functionsRoutes_0_9937148203508366();
    __name(onRequestPost7, "onRequestPost");
    __name(getNextCaseNumber, "getNextCaseNumber");
    __name(sendRegistrationEmail, "sendRegistrationEmail");
    __name(buildRegistrationEmailHtml, "buildRegistrationEmailHtml");
  }
});

// api/cases/upload-photos.js
async function onRequestPost8(context) {
  const { request, env } = context;
  try {
    const formData = await request.formData();
    const photos = formData.getAll("photos");
    if (!photos || photos.length === 0) {
      return Response.json({ error: "No photos provided" }, { status: 400 });
    }
    if (photos.length > 5) {
      return Response.json({ error: "Maximum 5 photos allowed" }, { status: 400 });
    }
    const sessionId = crypto.randomUUID();
    const uploadedFiles = [];
    for (const photo of photos) {
      if (photo.size > 10 * 1024 * 1024) {
        return Response.json({
          error: `File ${photo.name} exceeds 10MB limit`
        }, { status: 400 });
      }
      if (!photo.type.startsWith("image/")) {
        return Response.json({
          error: `File ${photo.name} is not an image`
        }, { status: 400 });
      }
      const timestamp = Date.now();
      const filename = `${timestamp}-${photo.name}`;
      const r2Key = `temp/${sessionId}/${filename}`;
      await env.USER_UPLOADS.put(r2Key, photo.stream(), {
        httpMetadata: {
          contentType: photo.type
        },
        customMetadata: {
          originalName: photo.name,
          uploadedAt: (/* @__PURE__ */ new Date()).toISOString()
        }
      });
      uploadedFiles.push({
        filename,
        r2Key,
        size: photo.size,
        mimeType: photo.type
      });
    }
    return Response.json({
      success: true,
      sessionId,
      uploadedFiles,
      message: `${uploadedFiles.length} photo${uploadedFiles.length > 1 ? "s" : ""} uploaded successfully`
    });
  } catch (error) {
    console.error("Photo upload error:", error);
    return Response.json({
      error: "Upload failed",
      details: error.message
    }, { status: 500 });
  }
}
var init_upload_photos = __esm({
  "api/cases/upload-photos.js"() {
    init_functionsRoutes_0_9937148203508366();
    __name(onRequestPost8, "onRequestPost");
  }
});

// api/reservations/create.js
async function onRequestPost9(context) {
  const { request, env } = context;
  const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "POST, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type"
  };
  if (request.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }
  try {
    const { items, customer, order_number } = await request.json();
    if (!items || !Array.isArray(items) || items.length === 0) {
      return new Response(JSON.stringify({
        success: false,
        error: "No items to reserve"
      }), {
        status: 400,
        headers: { ...corsHeaders, "Content-Type": "application/json" }
      });
    }
    if (!customer || !customer.name || !customer.phone) {
      return new Response(JSON.stringify({
        success: false,
        error: "Customer information required"
      }), {
        status: 400,
        headers: { ...corsHeaders, "Content-Type": "application/json" }
      });
    }
    const db = env.DB;
    const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1e3).toISOString();
    const reservations = [];
    for (const item of items) {
      const product = await db.prepare(`
                SELECT id, title, status 
                FROM products 
                WHERE id = ?
            `).bind(item.id).first();
      if (!product) {
        console.warn(`Product ${item.id} not found`);
        continue;
      }
      if (product.status !== "available") {
        console.warn(`Product ${item.id} (${product.title}) is ${product.status}`);
        continue;
      }
      const result = await db.prepare(`
                INSERT INTO product_reservations (
                    product_id,
                    order_number,
                    customer_name,
                    customer_phone,
                    customer_email,
                    expires_at,
                    status
                ) VALUES (?, ?, ?, ?, ?, ?, 'pending')
            `).bind(
        item.id,
        order_number,
        customer.name,
        customer.phone,
        customer.email || null,
        expiresAt
      ).run();
      reservations.push({
        product_id: item.id,
        product_title: product.title,
        reservation_id: result.meta.last_row_id
      });
    }
    if (reservations.length === 0) {
      return new Response(JSON.stringify({
        success: false,
        error: "No products could be reserved (already reserved or sold)"
      }), {
        status: 400,
        headers: { ...corsHeaders, "Content-Type": "application/json" }
      });
    }
    return new Response(JSON.stringify({
      success: true,
      message: `${reservations.length} item(s) reserved successfully`,
      reservations,
      expires_at: expiresAt
    }), {
      status: 200,
      headers: { ...corsHeaders, "Content-Type": "application/json" }
    });
  } catch (error) {
    console.error("Reservation error:", error);
    return new Response(JSON.stringify({
      success: false,
      error: error.message || "Failed to create reservations"
    }), {
      status: 500,
      headers: { ...corsHeaders, "Content-Type": "application/json" }
    });
  }
}
var init_create = __esm({
  "api/reservations/create.js"() {
    init_functionsRoutes_0_9937148203508366();
    __name(onRequestPost9, "onRequestPost");
  }
});

// api/admin/reservations.js
async function onRequest(context) {
  const { request, env } = context;
  const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, Authorization"
  };
  if (request.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }
  try {
    const db = env.DB;
    if (request.method === "GET") {
      const reservations = await db.prepare(`
                SELECT 
                    r.*,
                    p.title as product_title,
                    p.brand as product_brand,
                    p.price as product_price,
                    p.image_url as product_image,
                    p.status as product_status
                FROM product_reservations r
                LEFT JOIN products p ON r.product_id = p.id
                WHERE r.status = 'pending'
                ORDER BY r.created_at DESC
            `).all();
      return new Response(JSON.stringify({
        success: true,
        reservations: reservations.results || []
      }), {
        status: 200,
        headers: { ...corsHeaders, "Content-Type": "application/json" }
      });
    }
    if (request.method === "POST") {
      const { reservation_id, action, admin_notes } = await request.json();
      if (!reservation_id || !action) {
        return new Response(JSON.stringify({
          success: false,
          error: "reservation_id and action required"
        }), {
          status: 400,
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
      const validActions = ["confirm", "cancel"];
      if (!validActions.includes(action)) {
        return new Response(JSON.stringify({
          success: false,
          error: "Invalid action. Use: confirm or cancel"
        }), {
          status: 400,
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
      const newStatus = action === "confirm" ? "confirmed" : "cancelled";
      await db.prepare(`
                UPDATE product_reservations
                SET status = ?,
                    admin_notes = ?,
                    reviewed_at = CURRENT_TIMESTAMP,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = ?
            `).bind(newStatus, admin_notes || null, reservation_id).run();
      const reservation = await db.prepare(`
                SELECT 
                    r.*,
                    p.title as product_title,
                    p.status as product_status
                FROM product_reservations r
                LEFT JOIN products p ON r.product_id = p.id
                WHERE r.id = ?
            `).bind(reservation_id).first();
      return new Response(JSON.stringify({
        success: true,
        message: `Reservation ${action}ed successfully`,
        reservation
      }), {
        status: 200,
        headers: { ...corsHeaders, "Content-Type": "application/json" }
      });
    }
    return new Response(JSON.stringify({
      success: false,
      error: "Method not allowed"
    }), {
      status: 405,
      headers: { ...corsHeaders, "Content-Type": "application/json" }
    });
  } catch (error) {
    console.error("Admin reservations error:", error);
    return new Response(JSON.stringify({
      success: false,
      error: error.message || "Failed to manage reservations"
    }), {
      status: 500,
      headers: { ...corsHeaders, "Content-Type": "application/json" }
    });
  }
}
var init_reservations = __esm({
  "api/admin/reservations.js"() {
    init_functionsRoutes_0_9937148203508366();
    __name(onRequest, "onRequest");
  }
});

// api/admin/sell-requests.js
async function onRequest2(context) {
  const { request, env } = context;
  const url = new URL(request.url);
  const pathParts = url.pathname.split("/").filter(Boolean);
  const authResult = await verifyAdminAuth(request, env);
  if (!authResult.success) {
    return Response.json({
      success: false,
      error: "Unauthorized"
    }, { status: 401 });
  }
  const method = request.method;
  const submissionId = pathParts[pathParts.length - 1];
  const isIdRequest = !isNaN(parseInt(submissionId));
  try {
    if (method === "GET" && !isIdRequest) {
      return await handleGetSubmissions(context, authResult.adminId);
    } else if (method === "GET" && isIdRequest) {
      return await handleGetSubmissionDetails(context, submissionId, authResult.adminId);
    } else if (method === "PUT" && isIdRequest) {
      return await handleUpdateSubmission(context, submissionId, authResult.adminId);
    } else if (method === "DELETE" && isIdRequest) {
      return await handleDeleteSubmission(context, submissionId, authResult.adminId);
    } else {
      return Response.json({
        success: false,
        error: "Method not allowed"
      }, { status: 405 });
    }
  } catch (error) {
    console.error("\u274C Sell requests API error:", error);
    return Response.json({
      success: false,
      error: "Internal server error",
      details: error.message
    }, { status: 500 });
  }
}
async function handleGetSubmissions(context, adminId) {
  const { request, env } = context;
  const url = new URL(request.url);
  const status = url.searchParams.get("status");
  const batchId = url.searchParams.get("batch_id");
  const search = url.searchParams.get("search");
  const page = parseInt(url.searchParams.get("page")) || 1;
  const limit = parseInt(url.searchParams.get("limit")) || 50;
  const offset = (page - 1) * limit;
  try {
    let conditions = [];
    let params = [];
    if (status) {
      conditions.push("status = ?");
      params.push(status);
    }
    if (batchId) {
      conditions.push("batch_id = ?");
      params.push(batchId);
    }
    if (search) {
      conditions.push(
        "(contact_phone LIKE ? OR contact_email LIKE ? OR contact_handle LIKE ? OR batch_id LIKE ?)"
      );
      const searchTerm = `%${search}%`;
      params.push(searchTerm, searchTerm, searchTerm, searchTerm);
    }
    const whereClause = conditions.length > 0 ? "WHERE " + conditions.join(" AND ") : "";
    const query = `
            SELECT
                id,
                batch_id,
                user_id,
                status,
                items_json,
                contact_phone,
                contact_channel,
                contact_handle,
                contact_email,
                address,
                city,
                eircode,
                notes,
                admin_notes,
                estimated_value,
                offered_price,
                final_price,
                reviewed_at,
                reviewed_by,
                created_at,
                updated_at
            FROM sell_submissions
            ${whereClause}
            ORDER BY created_at DESC
            LIMIT ? OFFSET ?
        `;
    const result = await env.DB.prepare(query).bind(...params, limit, offset).all();
    const countQuery = `
            SELECT COUNT(*) as total
            FROM sell_submissions
            ${whereClause}
        `;
    const countResult = await env.DB.prepare(countQuery).bind(...params).first();
    const submissions = result.results.map((sub) => {
      const items = JSON.parse(sub.items_json || "[]");
      return {
        ...sub,
        items,
        item_count: items.length,
        items_json: void 0
        // Remove raw JSON from response
      };
    });
    const statusSummary = await env.DB.prepare(`
            SELECT
                status,
                COUNT(*) as count,
                SUM(json_array_length(items_json)) as total_items
            FROM sell_submissions
            GROUP BY status
        `).all();
    await logAdminAction(env.DB, adminId, "view_sell_requests", null, {
      filters: { status, batchId, search },
      results_count: submissions.length
    });
    return Response.json({
      success: true,
      submissions,
      pagination: {
        page,
        limit,
        total: countResult.total,
        total_pages: Math.ceil(countResult.total / limit)
      },
      summary: statusSummary.results
    });
  } catch (error) {
    console.error("\u274C Get submissions error:", error);
    throw error;
  }
}
async function handleGetSubmissionDetails(context, submissionId, adminId) {
  const { env } = context;
  try {
    const submission = await env.DB.prepare(`
            SELECT
                s.*,
                u.name as user_name,
                u.email as user_email,
                a.name as reviewer_name
            FROM sell_submissions s
            LEFT JOIN users u ON s.user_id = u.id
            LEFT JOIN users a ON s.reviewed_by = a.id
            WHERE s.id = ?
        `).bind(submissionId).first();
    if (!submission) {
      return Response.json({
        success: false,
        error: "Submission not found"
      }, { status: 404 });
    }
    submission.items = JSON.parse(submission.items_json || "[]");
    delete submission.items_json;
    const history = await env.DB.prepare(`
            SELECT
                action,
                metadata,
                created_at,
                u.name as admin_name
            FROM admin_audit_log a
            LEFT JOIN users u ON a.admin_id = u.id
            WHERE a.action LIKE '%sell_request%'
                AND json_extract(a.metadata, '$.submission_id') = ?
            ORDER BY a.created_at DESC
        `).bind(submissionId).all();
    await logAdminAction(env.DB, adminId, "view_sell_request_details", submissionId, {
      batch_id: submission.batch_id
    });
    return Response.json({
      success: true,
      submission,
      history: history.results
    });
  } catch (error) {
    console.error("\u274C Get submission details error:", error);
    throw error;
  }
}
async function handleUpdateSubmission(context, submissionId, adminId) {
  const { request, env } = context;
  const updates = await request.json();
  try {
    const current = await env.DB.prepare(
      "SELECT * FROM sell_submissions WHERE id = ?"
    ).bind(submissionId).first();
    if (!current) {
      return Response.json({
        success: false,
        error: "Submission not found"
      }, { status: 404 });
    }
    const allowedFields = [
      "status",
      "admin_notes",
      "estimated_value",
      "offered_price",
      "final_price",
      "reviewed_by",
      "reviewed_at"
    ];
    const updateFields = [];
    const params = [];
    Object.keys(updates).forEach((key) => {
      if (allowedFields.includes(key)) {
        updateFields.push(`${key} = ?`);
        params.push(updates[key]);
      }
    });
    if (updates.status && updates.status !== current.status) {
      if (!updateFields.includes("reviewed_by = ?")) {
        updateFields.push("reviewed_by = ?");
        params.push(adminId);
      }
      if (!updateFields.includes("reviewed_at = ?")) {
        updateFields.push("reviewed_at = CURRENT_TIMESTAMP");
      }
    }
    updateFields.push("updated_at = CURRENT_TIMESTAMP");
    if (updateFields.length === 0) {
      return Response.json({
        success: false,
        error: "No valid fields to update"
      }, { status: 400 });
    }
    params.push(submissionId);
    const query = `
            UPDATE sell_submissions
            SET ${updateFields.join(", ")}
            WHERE id = ?
        `;
    await env.DB.prepare(query).bind(...params).run();
    const updated = await env.DB.prepare(
      "SELECT * FROM sell_submissions WHERE id = ?"
    ).bind(submissionId).first();
    updated.items = JSON.parse(updated.items_json || "[]");
    delete updated.items_json;
    await logAdminAction(env.DB, adminId, "update_sell_request", submissionId, {
      batch_id: updated.batch_id,
      updates,
      old_status: current.status,
      new_status: updated.status
    });
    return Response.json({
      success: true,
      submission: updated,
      message: "Submission updated successfully"
    });
  } catch (error) {
    console.error("\u274C Update submission error:", error);
    throw error;
  }
}
async function handleDeleteSubmission(context, submissionId, adminId) {
  const { env } = context;
  try {
    const submission = await env.DB.prepare(
      "SELECT batch_id, status FROM sell_submissions WHERE id = ?"
    ).bind(submissionId).first();
    if (!submission) {
      return Response.json({
        success: false,
        error: "Submission not found"
      }, { status: 404 });
    }
    await env.DB.prepare(
      "DELETE FROM sell_submissions WHERE id = ?"
    ).bind(submissionId).run();
    await logAdminAction(env.DB, adminId, "delete_sell_request", submissionId, {
      batch_id: submission.batch_id,
      status: submission.status
    });
    return Response.json({
      success: true,
      message: "Submission deleted successfully"
    });
  } catch (error) {
    console.error("\u274C Delete submission error:", error);
    throw error;
  }
}
var init_sell_requests = __esm({
  "api/admin/sell-requests.js"() {
    init_functionsRoutes_0_9937148203508366();
    init_admin();
    init_admin();
    __name(onRequest2, "onRequest");
    __name(handleGetSubmissions, "handleGetSubmissions");
    __name(handleGetSubmissionDetails, "handleGetSubmissionDetails");
    __name(handleUpdateSubmission, "handleUpdateSubmission");
    __name(handleDeleteSubmission, "handleDeleteSubmission");
  }
});

// api/sell-submissions.js
async function onRequestPost10(context) {
  const { request, env } = context;
  try {
    const data = await request.json();
    if (!data.items || !Array.isArray(data.items) || data.items.length === 0) {
      return Response.json({
        success: false,
        error: "At least one item is required"
      }, { status: 400 });
    }
    if (!data.contact_phone || !data.contact_channel || !data.contact_handle) {
      return Response.json({
        success: false,
        error: "Contact details are required"
      }, { status: 400 });
    }
    const batchId = await generateBatchId(env.DB);
    const itemsJson = JSON.stringify(data.items);
    const result = await env.DB.prepare(`
            INSERT INTO sell_submissions (
                batch_id,
                user_id,
                status,
                items_json,
                contact_phone,
                contact_channel,
                contact_handle,
                contact_email,
                address,
                city,
                eircode,
                notes,
                created_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
        `).bind(
      batchId,
      data.user_id || null,
      "pending",
      itemsJson,
      data.contact_phone,
      data.contact_channel,
      data.contact_handle,
      data.contact_email || null,
      data.address || null,
      data.city || null,
      data.eircode || null,
      data.notes || null
    ).run();
    return Response.json({
      success: true,
      batch_id: batchId,
      submission_id: result.meta.last_row_id,
      message: `Submission received! Batch ID: ${batchId}`,
      items_count: data.items.length
    }, { status: 201 });
  } catch (error) {
    console.error("Sell submission error:", error);
    return Response.json({
      success: false,
      error: "Submission failed. Please try again.",
      details: error.message
    }, { status: 500 });
  }
}
async function generateBatchId(db) {
  const date = /* @__PURE__ */ new Date();
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  const dateStr = `${year}${month}${day}`;
  const random = Math.floor(1e4 + Math.random() * 9e4);
  const batchId = `BATCH-${dateStr}-${random}`;
  const existing = await db.prepare(
    "SELECT batch_id FROM sell_submissions WHERE batch_id = ?"
  ).bind(batchId).first();
  if (existing) {
    return generateBatchId(db);
  }
  return batchId;
}
async function onRequestGet6(context) {
  const { request, env } = context;
  const url = new URL(request.url);
  const status = url.searchParams.get("status");
  const batchId = url.searchParams.get("batch_id");
  try {
    let query = "SELECT * FROM sell_submissions";
    const params = [];
    if (batchId) {
      query += " WHERE batch_id = ?";
      params.push(batchId);
    } else if (status) {
      query += " WHERE status = ?";
      params.push(status);
    }
    query += " ORDER BY created_at DESC LIMIT 100";
    const result = await env.DB.prepare(query).bind(...params).all();
    const submissions = result.results.map((sub) => ({
      ...sub,
      items: JSON.parse(sub.items_json)
    }));
    return Response.json({
      success: true,
      submissions,
      count: submissions.length
    });
  } catch (error) {
    console.error("Fetch submissions error:", error);
    return Response.json({
      success: false,
      error: "Failed to fetch submissions"
    }, { status: 500 });
  }
}
var init_sell_submissions = __esm({
  "api/sell-submissions.js"() {
    init_functionsRoutes_0_9937148203508366();
    __name(onRequestPost10, "onRequestPost");
    __name(generateBatchId, "generateBatchId");
    __name(onRequestGet6, "onRequestGet");
  }
});

// api/analytics-v2.js
async function onRequest3(context) {
  const { env, request } = context;
  const url = new URL(request.url);
  const period = url.searchParams.get("period") || "week";
  const view = url.searchParams.get("view") || "overview";
  const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "GET, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type",
    "Content-Type": "application/json"
  };
  if (request.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }
  try {
    const db = env.DB;
    const now = /* @__PURE__ */ new Date();
    let startDate;
    switch (period) {
      case "day":
        startDate = new Date(now.setDate(now.getDate() - 1));
        break;
      case "week":
        startDate = new Date(now.setDate(now.getDate() - 7));
        break;
      case "month":
        startDate = new Date(now.setMonth(now.getMonth() - 1));
        break;
      default:
        startDate = /* @__PURE__ */ new Date("2024-01-01");
    }
    let analytics;
    switch (view) {
      case "products":
        analytics = await getProductAnalytics(db, startDate);
        break;
      case "customers":
        analytics = await getCustomerAnalytics(db, startDate);
        break;
      case "sellers":
        analytics = await getSellerAnalytics(db, startDate);
        break;
      default:
        analytics = await getOverviewAnalytics(db, startDate);
    }
    return new Response(JSON.stringify({
      success: true,
      view,
      period,
      date_range: {
        start: startDate.toISOString(),
        end: (/* @__PURE__ */ new Date()).toISOString()
      },
      ...analytics,
      generated_at: (/* @__PURE__ */ new Date()).toISOString()
    }), {
      status: 200,
      headers: corsHeaders
    });
  } catch (error) {
    console.error("\u274C Analytics error:", error);
    return new Response(JSON.stringify({
      success: false,
      error: error.message,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    }), {
      status: 500,
      headers: corsHeaders
    });
  }
}
async function getOverviewAnalytics(db, startDate) {
  const [products, customers, orders] = await Promise.all([
    db.prepare('SELECT COUNT(*) as count FROM products WHERE status = "active"').first(),
    db.prepare("SELECT COUNT(*) as count FROM users WHERE is_active = 1").first(),
    db.prepare("SELECT COUNT(*) as count FROM orders WHERE created_at >= ?").bind(startDate.toISOString()).first()
  ]);
  return {
    summary: {
      active_products: products?.count || 0,
      total_customers: customers?.count || 0,
      recent_orders: orders?.count || 0
    },
    quick_insights: [
      { metric: "Active Inventory", value: products?.count || 0, icon: "\u{1F4E6}", trend: "stable" },
      { metric: "Registered Customers", value: customers?.count || 0, icon: "\u{1F465}", trend: "growing" },
      { metric: "Recent Orders", value: orders?.count || 0, icon: "\u{1F6D2}", trend: "active" }
    ],
    upgrade_available: {
      products: "Detailed product trends",
      customers: "Top customers & behavior",
      sellers: "Seller performance tracking"
    }
  };
}
async function getProductAnalytics(db, startDate) {
  const total = await db.prepare("SELECT COUNT(*) as count FROM products").first();
  const statusBreakdown = await db.prepare(`
        SELECT
            status,
            COUNT(*) as count
        FROM products
        GROUP BY status
    `).all();
  const categoryStats = await db.prepare(`
        SELECT
            category,
            COUNT(*) as total,
            SUM(CASE WHEN status = 'active' THEN 1 ELSE 0 END) as active,
            SUM(CASE WHEN status = 'sold' THEN 1 ELSE 0 END) as sold,
            SUM(views_count) as total_views
        FROM products
        WHERE created_at >= ?
        GROUP BY category
        ORDER BY sold DESC
    `).bind(startDate.toISOString()).all();
  const hotProducts = await db.prepare(`
        SELECT
            image_id,
            category,
            size,
            views_count,
            created_at
        FROM products
        WHERE status = 'active' AND views_count > 0
        ORDER BY views_count DESC
        LIMIT 5
    `).all();
  const fastMovers = await db.prepare(`
        SELECT
            image_id,
            category,
            size,
            days_to_sell,
            sold_at
        FROM products
        WHERE status = 'sold'
            AND days_to_sell IS NOT NULL
            AND sold_at >= ?
        ORDER BY days_to_sell ASC
        LIMIT 5
    `).bind(startDate.toISOString()).all();
  return {
    summary: {
      total_products: total?.count || 0,
      by_status: statusBreakdown.results
    },
    category_performance: categoryStats.results,
    hot_products: hotProducts.results,
    fast_movers: fastMovers.results,
    insights: generateProductInsights(categoryStats.results, hotProducts.results)
  };
}
async function getCustomerAnalytics(db, startDate) {
  const topCustomers = await db.prepare(`
        SELECT
            u.id,
            u.email,
            u.first_name,
            u.last_name,
            u.city,
            u.preferred_contact,
            COUNT(o.id) as order_count,
            MAX(o.created_at) as last_order,
            MIN(o.created_at) as first_order
        FROM users u
        JOIN orders o ON u.id = o.user_id
        WHERE o.created_at >= ?
        GROUP BY u.id
        ORDER BY order_count DESC
        LIMIT 10
    `).bind(startDate.toISOString()).all();
  const locations = await db.prepare(`
        SELECT
            city,
            COUNT(*) as customer_count
        FROM users
        WHERE is_active = 1 AND city IS NOT NULL
        GROUP BY city
        ORDER BY customer_count DESC
        LIMIT 10
    `).all();
  const contactPrefs = await db.prepare(`
        SELECT
            preferred_contact,
            COUNT(*) as count
        FROM users
        WHERE is_active = 1
        GROUP BY preferred_contact
    `).all();
  const customerTypes = await db.prepare(`
        SELECT
            CASE
                WHEN order_count = 1 THEN 'new'
                ELSE 'returning'
            END as type,
            COUNT(*) as count
        FROM (
            SELECT user_id, COUNT(*) as order_count
            FROM orders
            WHERE created_at >= ?
            GROUP BY user_id
        )
        GROUP BY type
    `).bind(startDate.toISOString()).all();
  return {
    summary: {
      top_customers: topCustomers.results.slice(0, 5),
      total_active: topCustomers.results.length
    },
    locations: locations.results,
    contact_preferences: contactPrefs.results,
    customer_types: customerTypes.results,
    insights: generateCustomerInsights(topCustomers.results, locations.results)
  };
}
async function getSellerAnalytics(db, startDate) {
  const since = startDate.toISOString();
  const submissionsResult = await db.prepare(`
        SELECT
            id,
            batch_id,
            status,
            contact_channel,
            contact_handle,
            contact_phone,
            city,
            created_at,
            reviewed_at,
            reviewed_by,
            items_json
        FROM sell_submissions
        WHERE datetime(created_at) >= datetime(?)
        ORDER BY datetime(created_at) DESC
    `).bind(since).all();
  const submissions = submissionsResult.results || [];
  if (submissions.length === 0) {
    return {
      summary: {
        total_submissions: 0,
        pending: 0,
        processed: 0,
        avg_items_per_submission: 0,
        avg_response_time_minutes: 0
      },
      breakdowns: {
        by_status: [],
        by_channel: [],
        by_city: []
      },
      trends: {
        top_categories: [],
        top_brands: [],
        submissions_over_time: []
      },
      recent_submissions: [],
      insights: ["No seller submissions recorded for the selected period"]
    };
  }
  const statusCounter = /* @__PURE__ */ new Map();
  const channelCounter = /* @__PURE__ */ new Map();
  const cityCounter = /* @__PURE__ */ new Map();
  const categoryCounter = /* @__PURE__ */ new Map();
  const brandCounter = /* @__PURE__ */ new Map();
  const submissionsOverTime = /* @__PURE__ */ new Map();
  let totalItems = 0;
  let totalPhotos = 0;
  let responseTotalMinutes = 0;
  let responseSamples = 0;
  const parsedSubmissions = submissions.map((sub) => {
    statusCounter.set(sub.status, (statusCounter.get(sub.status) || 0) + 1);
    channelCounter.set(sub.contact_channel, (channelCounter.get(sub.contact_channel) || 0) + 1);
    if (sub.city) {
      cityCounter.set(sub.city, (cityCounter.get(sub.city) || 0) + 1);
    }
    const submissionDate = new Date(sub.created_at);
    const dateKey = submissionDate.toISOString().split("T")[0];
    submissionsOverTime.set(dateKey, (submissionsOverTime.get(dateKey) || 0) + 1);
    let items = [];
    try {
      const parsed = JSON.parse(sub.items_json || "[]");
      if (Array.isArray(parsed)) {
        items = parsed;
      }
    } catch (parseError) {
      console.warn(`\u26A0\uFE0F Failed to parse items for sell submission ${sub.batch_id}:`, parseError.message);
    }
    items.forEach((item) => {
      if (item?.category) {
        categoryCounter.set(item.category, (categoryCounter.get(item.category) || 0) + 1);
      }
      if (item?.brand) {
        brandCounter.set(item.brand, (brandCounter.get(item.brand) || 0) + 1);
      }
      if (typeof item?.photoCount === "number") {
        totalPhotos += item.photoCount;
      }
    });
    totalItems += items.length;
    if (sub.reviewed_at) {
      const reviewed = new Date(sub.reviewed_at);
      const diffMinutes = Math.max(0, (reviewed.getTime() - submissionDate.getTime()) / (1e3 * 60));
      responseTotalMinutes += diffMinutes;
      responseSamples += 1;
    }
    return {
      ...sub,
      items,
      items_count: items.length
    };
  });
  const totalSubmissions = submissions.length;
  const pendingCount = statusCounter.get("pending") || 0;
  const processedCount = totalSubmissions - pendingCount;
  const avgItems = totalItems > 0 ? totalItems / totalSubmissions : 0;
  const avgPhotos = totalPhotos > 0 ? totalPhotos / totalSubmissions : 0;
  const avgResponseMinutes = responseSamples > 0 ? responseTotalMinutes / responseSamples : 0;
  const toSortedArray = /* @__PURE__ */ __name((map) => Array.from(map.entries()).map(([key, value]) => ({ key, value })).sort((a, b) => b.value - a.value), "toSortedArray");
  const insights = [];
  const topChannel = toSortedArray(channelCounter)[0];
  if (topChannel) {
    insights.push(`${topChannel.key} delivers the most seller leads (${topChannel.value} submissions).`);
  }
  const topCategory = toSortedArray(categoryCounter)[0];
  if (topCategory) {
    insights.push(`${topCategory.key} is the most submitted category this period.`);
  }
  if (avgResponseMinutes > 0) {
    insights.push(`Average review response time is ${avgResponseMinutes.toFixed(1)} minutes.`);
  } else {
    insights.push("Submissions are awaiting review; no response-time data yet.");
  }
  if (avgPhotos > 0) {
    insights.push(`Sellers include an average of ${avgPhotos.toFixed(1)} photo(s) per submission.`);
  }
  return {
    summary: {
      total_submissions: totalSubmissions,
      pending: pendingCount,
      processed: processedCount,
      processed_rate: totalSubmissions > 0 ? (processedCount / totalSubmissions * 100).toFixed(1) : "0.0",
      avg_items_per_submission: Number(avgItems.toFixed(2)),
      avg_photos_per_submission: Number(avgPhotos.toFixed(2)),
      avg_response_time_minutes: Number(avgResponseMinutes.toFixed(1))
    },
    breakdowns: {
      by_status: toSortedArray(statusCounter),
      by_channel: toSortedArray(channelCounter),
      by_city: toSortedArray(cityCounter)
    },
    trends: {
      top_categories: toSortedArray(categoryCounter).slice(0, 5),
      top_brands: toSortedArray(brandCounter).slice(0, 5),
      submissions_over_time: Array.from(submissionsOverTime.entries()).map(([date, count]) => ({ date, count })).sort((a, b) => a.date.localeCompare(b.date))
    },
    recent_submissions: parsedSubmissions.slice(0, 5).map((sub) => ({
      batch_id: sub.batch_id,
      status: sub.status,
      items_count: sub.items_count,
      contact_channel: sub.contact_channel,
      contact_handle: sub.contact_handle,
      city: sub.city,
      submitted_at: sub.created_at,
      reviewed_at: sub.reviewed_at
    })),
    insights
  };
}
function generateProductInsights(categories, hotProducts) {
  const insights = [];
  if (categories.length > 0) {
    const topCategory = categories[0];
    insights.push(`${topCategory.category} is your best performing category with ${topCategory.sold} sales`);
  }
  if (hotProducts.length > 0) {
    insights.push(`${hotProducts.length} products are getting high views - potential hot sellers`);
  }
  return insights;
}
function generateCustomerInsights(topCustomers, locations) {
  const insights = [];
  if (topCustomers.length > 0) {
    const vip = topCustomers[0];
    insights.push(`Top customer has placed ${vip.order_count} orders`);
  }
  if (locations.length > 0) {
    const topLocation = locations[0];
    insights.push(`${topLocation.city} has the most customers (${topLocation.customer_count})`);
  }
  return insights;
}
var init_analytics_v2 = __esm({
  "api/analytics-v2.js"() {
    init_functionsRoutes_0_9937148203508366();
    __name(onRequest3, "onRequest");
    __name(getOverviewAnalytics, "getOverviewAnalytics");
    __name(getProductAnalytics, "getProductAnalytics");
    __name(getCustomerAnalytics, "getCustomerAnalytics");
    __name(getSellerAnalytics, "getSellerAnalytics");
    __name(generateProductInsights, "generateProductInsights");
    __name(generateCustomerInsights, "generateCustomerInsights");
  }
});

// api/eircode-proxy.js
async function onRequest4(context) {
  const { request } = context;
  const url = new URL(request.url);
  const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type"
  };
  if (request.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }
  try {
    const action = url.searchParams.get("action") || "identity";
    if (action === "identity") {
      const response = await fetch("https://api-finder.eircode.ie/Latest/findergetidentity", {
        headers: {
          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
          "Referer": "https://finder.eircode.ie/",
          "Origin": "https://finder.eircode.ie"
        }
      });
      const data = await response.json();
      return new Response(JSON.stringify(data), {
        status: 200,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json"
        }
      });
    } else if (action === "search") {
      const key = url.searchParams.get("key");
      const address = url.searchParams.get("address");
      const language = url.searchParams.get("language") || "en";
      const geographicAddress = url.searchParams.get("geographicAddress") || "true";
      const clientVersion = url.searchParams.get("clientVersion") || "e98fe302";
      if (!key || !address) {
        return new Response(JSON.stringify({
          error: { code: 400, text: "Missing key or address parameter" }
        }), {
          status: 400,
          headers: {
            ...corsHeaders,
            "Content-Type": "application/json"
          }
        });
      }
      const apiUrl = `https://api-finder.eircode.ie/Latest/finderfindaddress?key=${key}&address=${encodeURIComponent(address)}&language=${language}&geographicAddress=${geographicAddress}&clientVersion=${clientVersion}`;
      const response = await fetch(apiUrl, {
        headers: {
          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
          "Referer": "https://finder.eircode.ie/",
          "Origin": "https://finder.eircode.ie"
        }
      });
      const data = await response.json();
      return new Response(JSON.stringify(data), {
        status: response.status,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json"
        }
      });
    }
    return new Response(JSON.stringify({
      error: { code: 400, text: "Invalid action. Use action=identity or action=search" }
    }), {
      status: 400,
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json"
      }
    });
  } catch (error) {
    return new Response(JSON.stringify({
      error: {
        code: 500,
        text: error.message
      }
    }), {
      status: 500,
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json"
      }
    });
  }
}
var init_eircode_proxy = __esm({
  "api/eircode-proxy.js"() {
    init_functionsRoutes_0_9937148203508366();
    __name(onRequest4, "onRequest");
  }
});

// ../public/js/taxonomy.js
function getSizesForCategory(category) {
  return SIZES[category] || [];
}
var SIZES;
var init_taxonomy = __esm({
  "../public/js/taxonomy.js"() {
    init_functionsRoutes_0_9937148203508366();
    SIZES = {
      "BN-CLOTHES": [
        "XS",
        "S",
        "M",
        "L",
        "XL"
      ],
      "PO-CLOTHES": [
        // Standard sizes
        "XS",
        "S",
        "M",
        "L",
        "XL",
        // Mixed top/bottom (±1 size difference only)
        "XS-TOP-S-BOTTOM",
        "S-TOP-XS-BOTTOM",
        "S-TOP-M-BOTTOM",
        "M-TOP-S-BOTTOM",
        "M-TOP-L-BOTTOM",
        "L-TOP-M-BOTTOM",
        "L-TOP-XL-BOTTOM",
        "XL-TOP-L-BOTTOM"
      ],
      "BN-SHOES": [
        "UK-6",
        "UK-6-5",
        "UK-7",
        "UK-7-5",
        "UK-8",
        "UK-8-5",
        "UK-9",
        "UK-9-5",
        "UK-10",
        "UK-10-5",
        "UK-11",
        "UK-11-5",
        "UK-12"
      ],
      "PO-SHOES": [
        "UK-6",
        "UK-6-5",
        "UK-7",
        "UK-7-5",
        "UK-8",
        "UK-8-5",
        "UK-9",
        "UK-9-5",
        "UK-10",
        "UK-10-5",
        "UK-11",
        "UK-11-5",
        "UK-12"
      ]
    };
    __name(getSizesForCategory, "getSizesForCategory");
  }
});

// api/products.js
async function onRequest5(context) {
  const { env, request } = context;
  const url = new URL(request.url);
  const debugMode = url.searchParams.has("debug");
  const includeHidden = url.searchParams.has("includeHidden");
  const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "GET, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type",
    "Content-Type": "application/json"
  };
  if (context.request.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }
  try {
    const accountId = env.CLOUDFLARE_ACCOUNT_ID;
    const apiToken = env.CLOUDFLARE_API_TOKEN || env.CLOUDFLARE_IMAGES_API_TOKEN;
    const deliveryHash = env.CLOUDFLARE_IMAGES_HASH || env.CLOUDFLARE_DELIVERY_HASH || env.IMAGES_DELIVERY_HASH;
    if (!accountId || !apiToken) {
      const missing = [
        !accountId && "CLOUDFLARE_ACCOUNT_ID",
        !apiToken && "CLOUDFLARE_API_TOKEN or CLOUDFLARE_IMAGES_API_TOKEN"
      ].filter(Boolean).join(", ");
      console.warn("\u26A0\uFE0F CF Images credentials not configured:", missing);
      return new Response(JSON.stringify({
        success: true,
        products: [],
        message: `CF Images not configured yet. Missing: ${missing}`,
        total: 0,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      }), {
        status: 200,
        headers: corsHeaders
      });
    }
    const apiUrl = `https://api.cloudflare.com/client/v4/accounts/${accountId}/images/v1`;
    const response = await fetch(apiUrl, {
      headers: {
        "Authorization": `Bearer ${apiToken}`,
        "Content-Type": "application/json"
      }
    });
    if (!response.ok) {
      throw new Error(`Cloudflare API error: ${response.status}`);
    }
    const data = await response.json();
    if (!data.success || !data.result) {
      throw new Error("Cloudflare API error");
    }
    let images = [];
    if (Array.isArray(data.result)) {
      images = data.result;
    } else if (data.result.images && Array.isArray(data.result.images)) {
      images = data.result.images;
    }
    let dbStatusMap = {};
    try {
      if (env.DB) {
        const dbProducts = await env.DB.prepare("SELECT cloudflare_image_id, status FROM products").all();
        if (dbProducts.success && dbProducts.results) {
          dbProducts.results.forEach((p) => {
            if (p.cloudflare_image_id) {
              dbStatusMap[p.cloudflare_image_id] = p.status;
            }
          });
        }
      }
    } catch (dbError) {
      console.warn("\u26A0\uFE0F Could not fetch statuses from D1:", dbError.message);
    }
    const products = images.map((image) => {
      try {
        const meta = image.meta || image.metadata || {};
        const filename = image.filename || "";
        let status = dbStatusMap[image.id] || (meta.status || "active").toLowerCase();
        if (!includeHidden && (status === "hidden" || status === "sold")) {
          return null;
        }
        let name = meta.name || meta.title || filename.replace(/\.[^/.]+$/, "").replace(/[-_]/g, " ");
        name = name.replace(/\d{8,}/g, "").trim();
        name = name.charAt(0).toUpperCase() + name.slice(1) || `SBS Item ${image.id.slice(0, 8)}`;
        let category = (meta.category || "").toUpperCase();
        if (!["BN-CLOTHES", "BN-SHOES", "PO-CLOTHES", "PO-SHOES"].includes(category)) {
          const lowerName = name.toLowerCase();
          if (lowerName.includes("shoe") || lowerName.includes("sneaker") || lowerName.includes("boot")) {
            category = "BN-SHOES";
          } else {
            category = "BN-CLOTHES";
          }
        }
        const condition = category.includes("BN") ? "Brand New" : "Pre-Owned";
        const sizes = getSizesForCategory(category);
        const stock = parseInt(meta.stock || meta.quantity || "1", 10);
        const inStock = stock > 0;
        const variants = image.variants || [];
        let imageUrl = variants.find((v) => v.includes("/public")) || variants.find((v) => v.includes("/standard")) || variants[0];
        let thumbUrl = variants.find((v) => v.includes("/thumb")) || variants[0];
        if (!imageUrl && deliveryHash) {
          imageUrl = `https://imagedelivery.net/${deliveryHash}/${image.id}/public`;
        }
        if (!thumbUrl && deliveryHash) {
          thumbUrl = `https://imagedelivery.net/${deliveryHash}/${image.id}/thumb`;
        }
        return {
          id: image.id,
          name,
          category,
          condition,
          brand: meta.brand || null,
          size: meta.size || null,
          status,
          sku: meta.sku || `SBS-${image.id.slice(0, 8)}`,
          imageUrl,
          image: imageUrl,
          thumbnail: thumbUrl,
          description: meta.description || `${condition} ${name}`,
          sizes,
          inStock,
          stock,
          featured: meta.featured === "true" || meta.featured === "1",
          uploaded: image.uploaded,
          uploadedAt: image.uploaded,
          ...debugMode && {
            rawMeta: meta,
            rawFilename: filename,
            variants
          }
        };
      } catch (err) {
        console.error(`Error parsing image ${image.id}:`, err);
        return null;
      }
    }).filter((p) => p !== null);
    const result = {
      success: true,
      products,
      total: products.length,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      source: "Cloudflare Images",
      note: "Edit products in Cloudflare Images Dashboard > Image > Metadata",
      ...debugMode && {
        deliveryHashUsed: Boolean(deliveryHash),
        imagesRetrieved: images.length,
        metadataFields: [
          "name - Product name",
          "price - Price (45.99 or 4599 cents)",
          "category - BN-CLOTHES, BN-SHOES, PO-CLOTHES, PO-SHOES",
          "brand - Brand name",
          "size - Size (M, L, UK-9, etc)",
          "condition - BN or PO",
          "status - active, hidden, sold",
          "sku - SKU code",
          "stock - Stock quantity",
          "featured - true/false",
          "description - Product description"
        ]
      }
    };
    return new Response(JSON.stringify(result), {
      headers: corsHeaders,
      status: 200
    });
  } catch (error) {
    console.error("\u274C SBS API Error:", error);
    console.error("\u274C Error stack:", error.stack);
    return new Response(JSON.stringify({
      success: false,
      error: "Products temporarily unavailable",
      message: error.message,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    }), {
      headers: corsHeaders,
      status: 500
    });
  }
}
var init_products2 = __esm({
  "api/products.js"() {
    init_functionsRoutes_0_9937148203508366();
    init_taxonomy();
    __name(onRequest5, "onRequest");
  }
});

// api/products-smart.js
async function onRequest6(context) {
  const { env, request } = context;
  const url = new URL(request.url);
  const useD1 = url.searchParams.has("smart") || true;
  const includeHidden = url.searchParams.has("includeHidden");
  const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "GET, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type",
    "Content-Type": "application/json"
  };
  if (request.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }
  try {
    console.log("\u{1F680} SBS API: Fetching smart inventory from D1...");
    const db = env.DB;
    const statusFilter = includeHidden ? "status IN ('active', 'hidden')" : "status = 'active'";
    const dbProducts = await db.prepare(`
            SELECT
                id,
                image_id,
                category,
                size,
                condition,
                status,
                quantity_available,
                quantity_sold,
                views_count,
                created_at,
                sold_at,
                days_to_sell,
                notes
            FROM products
            WHERE ${statusFilter}
            ORDER BY created_at DESC
        `).all();
    if (!dbProducts.results || dbProducts.results.length === 0) {
      console.log("\u26A0\uFE0F No products in D1, falling back to CF Images discovery...");
      return await discoverFromCloudflare(env, corsHeaders, includeHidden);
    }
    console.log(`\u2705 Found ${dbProducts.results.length} products in D1`);
    const accountId = env.CLOUDFLARE_ACCOUNT_ID;
    const apiToken = env.CLOUDFLARE_API_TOKEN || env.CLOUDFLARE_IMAGES_API_TOKEN;
    const deliveryHash = env.CLOUDFLARE_IMAGES_HASH || env.CLOUDFLARE_DELIVERY_HASH;
    let cfImagesMap = {};
    if (accountId && apiToken) {
      const apiUrl = `https://api.cloudflare.com/client/v4/accounts/${accountId}/images/v1`;
      const response = await fetch(apiUrl, {
        headers: {
          "Authorization": `Bearer ${apiToken}`,
          "Content-Type": "application/json"
        }
      });
      if (response.ok) {
        const data = await response.json();
        const images = Array.isArray(data.result) ? data.result : data.result?.images || [];
        images.forEach((img) => {
          cfImagesMap[img.id] = img;
        });
      }
    }
    const enrichedProducts = dbProducts.results.map((product) => {
      const cfImage = cfImagesMap[product.image_id];
      const meta = cfImage?.meta || cfImage?.metadata || {};
      const variants = cfImage?.variants || [];
      let imageUrl = variants.find((v) => v.includes("/public")) || variants[0];
      let thumbUrl = variants.find((v) => v.includes("/thumb")) || variants[0];
      if (!imageUrl && deliveryHash) {
        imageUrl = `https://imagedelivery.net/${deliveryHash}/${product.image_id}/public`;
        thumbUrl = `https://imagedelivery.net/${deliveryHash}/${product.image_id}/thumb`;
      }
      return {
        id: product.image_id,
        name: meta.name || "SBS Product",
        category: product.category,
        condition: product.condition,
        size: product.size,
        brand: meta.brand || null,
        status: product.status,
        inStock: product.quantity_available > 0,
        stock: product.quantity_available,
        sold_count: product.quantity_sold,
        views: product.views_count,
        imageUrl,
        image: imageUrl,
        thumbnail: thumbUrl,
        uploaded: product.created_at,
        // Analytics insights
        days_listed: product.sold_at ? product.days_to_sell : Math.floor((Date.now() - new Date(product.created_at).getTime()) / (1e3 * 60 * 60 * 24)),
        is_hot: product.views_count > 20 && !product.sold_at,
        is_fast_mover: product.days_to_sell && product.days_to_sell < 7,
        notes: product.notes
      };
    });
    return new Response(JSON.stringify({
      success: true,
      products: enrichedProducts,
      total: enrichedProducts.length,
      source: "D1 Smart Inventory",
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    }), {
      status: 200,
      headers: corsHeaders
    });
  } catch (error) {
    console.error("\u274C Products API error:", error);
    return new Response(JSON.stringify({
      success: false,
      error: error.message,
      products: [],
      total: 0,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    }), {
      status: 500,
      headers: corsHeaders
    });
  }
}
async function discoverFromCloudflare(env, corsHeaders, includeHidden) {
  const accountId = env.CLOUDFLARE_ACCOUNT_ID;
  const apiToken = env.CLOUDFLARE_API_TOKEN || env.CLOUDFLARE_IMAGES_API_TOKEN;
  const deliveryHash = env.CLOUDFLARE_IMAGES_HASH || env.CLOUDFLARE_DELIVERY_HASH;
  if (!accountId || !apiToken) {
    return new Response(JSON.stringify({
      success: true,
      products: [],
      message: "No products in D1, and CF Images not configured",
      total: 0,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    }), {
      status: 200,
      headers: corsHeaders
    });
  }
  const apiUrl = `https://api.cloudflare.com/client/v4/accounts/${accountId}/images/v1`;
  const response = await fetch(apiUrl, {
    headers: {
      "Authorization": `Bearer ${apiToken}`,
      "Content-Type": "application/json"
    }
  });
  if (!response.ok) {
    throw new Error(`Cloudflare API error: ${response.status}`);
  }
  const data = await response.json();
  const images = Array.isArray(data.result) ? data.result : data.result?.images || [];
  console.log(`\u{1F50D} Discovered ${images.length} images from CF, will auto-sync to D1...`);
  const products = images.map((image) => {
    const meta = image.meta || image.metadata || {};
    const variants = image.variants || [];
    let imageUrl = variants.find((v) => v.includes("/public")) || variants[0];
    let thumbUrl = variants.find((v) => v.includes("/thumb")) || variants[0];
    if (!imageUrl && deliveryHash) {
      imageUrl = `https://imagedelivery.net/${deliveryHash}/${image.id}/public`;
      thumbUrl = `https://imagedelivery.net/${deliveryHash}/${image.id}/thumb`;
    }
    const status = meta.status || "active";
    const showImage = includeHidden || status === "active";
    return showImage ? {
      id: image.id,
      name: meta.name || "SBS Product",
      category: meta.category || "BN-CLOTHES",
      condition: meta.condition || "Brand New",
      size: meta.size || null,
      brand: meta.brand || null,
      status,
      inStock: true,
      stock: parseInt(meta.stock || "1"),
      imageUrl,
      image: imageUrl,
      thumbnail: thumbUrl,
      uploaded: image.uploaded,
      source: "CF Images Discovery"
    } : null;
  }).filter(Boolean);
  let syncSummary = {
    upserted: 0,
    skipped: 0,
    errors: 0
  };
  if (products.length > 0 && env.DB) {
    const db = env.DB;
    for (const product of products) {
      try {
        const result = await db.prepare(`
                    INSERT INTO products (
                        image_id,
                        category,
                        size,
                        condition,
                        status,
                        quantity_total,
                        quantity_available,
                        created_at,
                        updated_at
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
                    ON CONFLICT(image_id) DO UPDATE SET
                        category = excluded.category,
                        size = excluded.size,
                        condition = excluded.condition,
                        status = excluded.status,
                        quantity_total = excluded.quantity_total,
                        quantity_available = excluded.quantity_available,
                        updated_at = datetime('now')
                `).bind(
          product.id,
          product.category,
          product.size,
          product.condition,
          product.status,
          product.stock || 1,
          product.inStock ? product.stock || 1 : 0
        ).run();
        if (result.meta.changes > 0) {
          syncSummary.upserted += 1;
        } else {
          syncSummary.skipped += 1;
        }
      } catch (syncError) {
        syncSummary.errors += 1;
        console.warn(`\u26A0\uFE0F Failed to sync product ${product.id} to D1:`, syncError.message);
      }
    }
  }
  return new Response(JSON.stringify({
    success: true,
    products,
    total: products.length,
    message: syncSummary.upserted > 0 ? `Discovered from CF Images and synced ${syncSummary.upserted} item(s) to D1` : "Discovered from CF Images (no D1 sync performed)",
    d1_sync: syncSummary,
    timestamp: (/* @__PURE__ */ new Date()).toISOString()
  }), {
    status: 200,
    headers: corsHeaders
  });
}
var init_products_smart = __esm({
  "api/products-smart.js"() {
    init_functionsRoutes_0_9937148203508366();
    init_taxonomy();
    __name(onRequest6, "onRequest");
    __name(discoverFromCloudflare, "discoverFromCloudflare");
  }
});

// lib/email.js
var email_exports = {};
__export(email_exports, {
  cleanupExpiredTokens: () => cleanupExpiredTokens,
  createVerificationToken: () => createVerificationToken,
  sendVerificationEmail: () => sendVerificationEmail,
  verifyEmailToken: () => verifyEmailToken
});
function generateToken() {
  const bytes = crypto.getRandomValues(new Uint8Array(32));
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
async function hashToken3(token) {
  const data = enc.encode(token);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  return Array.from(new Uint8Array(hashBuffer)).map((b) => b.toString(16).padStart(2, "0")).join("");
}
async function sendVerificationEmail(email, token, siteUrl) {
  const verifyUrl = `${siteUrl}/verify-email.html?token=${token}`;
  const emailContent = {
    personalizations: [
      {
        to: [{ email }],
        dkim_domain: "thesbsofficial.com",
        dkim_selector: "mailchannels"
      }
    ],
    from: {
      email: "noreply@thesbsofficial.com",
      name: "SBS Unity"
    },
    subject: "\u2705 Verify Your SBS Account",
    content: [
      {
        type: "text/html",
        value: `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body style="margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; background: #0a0a0a; color: #ffffff;">
    <div style="max-width: 600px; margin: 0 auto; padding: 40px 20px;">
        <!-- Header -->
        <div style="text-align: center; margin-bottom: 40px;">
            <h1 style="color: #FFD700; font-size: 32px; font-weight: 900; margin: 0;">SBS</h1>
            <p style="color: #cccccc; margin: 8px 0 0 0;">Dublin's Premier Streetwear</p>
        </div>
        
        <!-- Main Content -->
        <div style="background: #1a1a1a; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 12px; padding: 32px;">
            <h2 style="color: #FFD700; font-size: 24px; margin: 0 0 16px 0;">Welcome to SBS Unity! \u{1F389}</h2>
            
            <p style="color: #ffffff; font-size: 16px; line-height: 1.6; margin: 0 0 24px 0;">
                Thanks for signing up! Please verify your email address to activate your account and start selling or shopping.
            </p>
            
            <!-- CTA Button -->
            <div style="text-align: center; margin: 32px 0;">
                <a href="${verifyUrl}" 
                   style="display: inline-block; background: #FFD700; color: #000000; padding: 16px 32px; border-radius: 8px; text-decoration: none; font-weight: 600; font-size: 16px;">
                    \u2705 Verify Email Address
                </a>
            </div>
            
            <p style="color: #cccccc; font-size: 14px; line-height: 1.6; margin: 24px 0 0 0;">
                Or copy and paste this link into your browser:
            </p>
            <div style="background: #0a0a0a; border: 1px solid rgba(255, 215, 0, 0.2); border-radius: 8px; padding: 12px; margin: 12px 0; word-break: break-all;">
                <code style="color: #FFD700; font-size: 14px;">${verifyUrl}</code>
            </div>
            
            <p style="color: #999999; font-size: 12px; line-height: 1.6; margin: 24px 0 0 0; border-top: 1px solid rgba(255, 255, 255, 0.1); padding-top: 16px;">
                \u23F0 This link expires in 24 hours.<br>
                \u{1F512} If you didn't create this account, you can safely ignore this email.
            </p>
        </div>
        
        <!-- Footer -->
        <div style="text-align: center; margin-top: 32px; color: #666666; font-size: 14px;">
            <p style="margin: 0 0 8px 0;">SBS Unity - Dublin's Premier Streetwear</p>
            <p style="margin: 0;">\u{1F4CD} Dublin, Ireland</p>
        </div>
    </div>
</body>
</html>
                `
      }
    ]
  };
  try {
    const response = await fetch("https://api.mailchannels.net/tx/v1/send", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(emailContent)
    });
    if (!response.ok) {
      const errorText = await response.text();
      console.error("MailChannels error:", errorText);
      console.error("MailChannels status:", response.status);
      throw new Error(`Email send failed: ${response.status} - ${errorText}`);
    }
    console.log("Email sent successfully via MailChannels");
    return { success: true };
  } catch (error) {
    console.error("Failed to send email:", error);
    console.error("Error details:", error.message);
    throw error;
  }
}
async function createVerificationToken(db, userId) {
  const token = generateToken();
  const tokenHash = await hashToken3(token);
  const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1e3).toISOString();
  await db.prepare(
    `INSERT INTO email_verification_tokens (user_id, token_hash, expires_at)
         VALUES (?, ?, ?)`
  ).bind(userId, tokenHash, expiresAt).run();
  return token;
}
async function verifyEmailToken(db, token) {
  const tokenHash = await hashToken3(token);
  const tokenRecord = await db.prepare(
    `SELECT * FROM email_verification_tokens 
         WHERE token_hash = ? AND used_at IS NULL AND expires_at > datetime('now')`
  ).bind(tokenHash).first();
  if (!tokenRecord) {
    return { success: false, error: "Invalid or expired token" };
  }
  await db.prepare(
    `UPDATE email_verification_tokens SET used_at = datetime('now')
         WHERE id = ?`
  ).bind(tokenRecord.id).run();
  await db.prepare(
    `UPDATE users SET email_verified = 1
         WHERE id = ?`
  ).bind(tokenRecord.user_id).run();
  const user = await db.prepare(
    `SELECT id, social_handle, email, first_name, last_name, email_verified
         FROM users WHERE id = ?`
  ).bind(tokenRecord.user_id).first();
  return { success: true, user };
}
async function cleanupExpiredTokens(db) {
  await db.prepare(
    `DELETE FROM email_verification_tokens 
         WHERE expires_at < datetime('now', '-7 days')`
  ).run();
}
var enc;
var init_email = __esm({
  "lib/email.js"() {
    init_functionsRoutes_0_9937148203508366();
    enc = new TextEncoder();
    __name(generateToken, "generateToken");
    __name(hashToken3, "hashToken");
    __name(sendVerificationEmail, "sendVerificationEmail");
    __name(createVerificationToken, "createVerificationToken");
    __name(verifyEmailToken, "verifyEmailToken");
    __name(cleanupExpiredTokens, "cleanupExpiredTokens");
  }
});

// lib/resend-wrapper.js
var resend_wrapper_exports = {};
__export(resend_wrapper_exports, {
  sendBeautifulVerificationEmail: () => sendBeautifulVerificationEmail
});
async function sendBeautifulVerificationEmail(apiKey, email, name, token, siteUrl) {
  const verifyUrl = `${siteUrl}/verify-email.html?token=${token}`;
  const firstName = name ? name.split(" ")[0] : "there";
  const html = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body style="margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);">
    <div style="max-width: 600px; margin: 0 auto; padding: 40px 20px;">
        <!-- Header -->
        <div style="text-align: center; margin-bottom: 40px;">
            <h1 style="color: #FFD700; font-size: 42px; font-weight: 900; margin: 0; text-shadow: 0 0 20px rgba(255, 215, 0, 0.3);">SBS</h1>
            <p style="color: #FFD700; margin: 8px 0 0 0; font-weight: 600; letter-spacing: 2px; font-size: 14px;">DUBLIN STREETWEAR</p>
        </div>
        
        <!-- Main Content -->
        <div style="background: rgba(26, 26, 26, 0.8); backdrop-filter: blur(10px); border: 2px solid rgba(255, 215, 0, 0.2); border-radius: 16px; padding: 40px; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);">
            <h2 style="color: #FFD700; font-size: 28px; margin: 0 0 20px 0; font-weight: 800;">Hey ${firstName}! \u{1F44B}</h2>
            
            <p style="color: #ffffff; font-size: 17px; line-height: 1.7; margin: 0 0 20px 0;">
                Welcome to the <strong style="color: #FFD700;">SBS crew</strong>! \u{1F680}
            </p>
            
            <p style="color: #ffffff; font-size: 17px; line-height: 1.7; margin: 0 0 30px 0;">
                We're stoked to have you. Just one quick step to unlock <strong style="color: #FFD700;">early drops</strong>, <strong style="color: #FFD700;">same-day Dublin</strong> delivery, and the best streetwear deals in Ireland.
            </p>
            
            <!-- CTA Button -->
            <div style="text-align: center; margin: 40px 0;">
                <a href="${verifyUrl}" 
                   style="display: inline-block; background: linear-gradient(135deg, #FFD700 0%, #FFC700 100%); color: #000000; padding: 18px 48px; border-radius: 30px; text-decoration: none; font-weight: 800; font-size: 18px; letter-spacing: 1px; box-shadow: 0 10px 30px rgba(255, 215, 0, 0.4); text-transform: uppercase; transition: all 0.3s ease;">
                    \u2705 VERIFY MY EMAIL
                </a>
            </p>
            
            <div style="background: rgba(10, 10, 10, 0.6); border-left: 4px solid #FFD700; border-radius: 8px; padding: 20px; margin: 30px 0;">
                <p style="color: #FFD700; font-size: 15px; margin: 0 0 12px 0; font-weight: 600;">
                    \u{1F517} Or copy this link:
                </p>
                <div style="background: #000000; border: 1px solid rgba(255, 215, 0, 0.3); border-radius: 8px; padding: 14px; word-break: break-all;">
                    <code style="color: #FFD700; font-size: 13px;">${verifyUrl}</code>
                </div>
            </div>
            
            <div style="border-top: 1px solid rgba(255, 215, 0, 0.2); margin-top: 32px; padding-top: 24px;">
                <p style="color: #999999; font-size: 14px; line-height: 1.6; margin: 0 0 12px 0;">
                    \u23F0 <strong>Link expires in 24 hours</strong> \u2014 verify soon!
                </p>
                <p style="color: #999999; font-size: 14px; line-height: 1.6; margin: 0;">
                    \u{1F512} Didn't sign up? No worries\u2014just ignore this email.
                </p>
            </div>
        </div>
        
        <!-- Footer -->
        <div style="text-align: center; margin-top: 40px; color: #666666; font-size: 14px; line-height: 1.6;">
            <p style="margin: 0 0 8px 0; font-weight: 600; color: #FFD700;">SBS</p>
            <p style="margin: 0 0 4px 0;">Dublin's Premier Streetwear Marketplace</p>
            <p style="margin: 0;">\u{1F4CD} Same-Day Dublin Delivery | \u{1F525} Authenticated Items</p>
        </div>
    </div>
</body>
</html>`;
  const response = await fetch("https://api.resend.com/emails", {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${apiKey}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      from: "SBS Team <noreply@thesbsofficial.com>",
      to: [email],
      subject: `Hey ${firstName}! Verify your email to unlock SBS \u{1F680}`,
      html
    })
  });
  if (!response.ok) {
    const error = await response.text();
    throw new Error(`Resend API error: ${response.status} - ${error}`);
  }
  return response.json();
}
var init_resend_wrapper = __esm({
  "lib/resend-wrapper.js"() {
    init_functionsRoutes_0_9937148203508366();
    __name(sendBeautifulVerificationEmail, "sendBeautifulVerificationEmail");
  }
});

// api/[[path]].js
function secHeaders(origin, env) {
  const allow = (env.ALLOWED_ORIGINS || "https://thesbsofficial.com,https://*.pages.dev").split(",").map((s) => s.trim());
  const allowed = allow.includes(origin) ? origin : allow[0];
  return {
    "Access-Control-Allow-Origin": allowed,
    "Access-Control-Allow-Credentials": "true",
    "Access-Control-Allow-Methods": "GET,POST,PUT,PATCH,DELETE,OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type,X-CSRF-Token",
    "X-Frame-Options": "DENY",
    "X-Content-Type-Options": "nosniff",
    "Referrer-Policy": "no-referrer",
    "Strict-Transport-Security": "max-age=31536000; includeSubDomains; preload",
    "Content-Security-Policy": "default-src 'self'; script-src 'self'; style-src 'self'; img-src 'self' data: blob:; connect-src 'self'; frame-ancestors 'none'"
  };
}
function getCookie(request, name) {
  const h = request.headers.get("Cookie") || "";
  const m = h.match(new RegExp(`(?:^|; )${name}=([^;]*)`));
  return m ? decodeURIComponent(m[1]) : null;
}
async function hashPassword(password, iterations = 1e5) {
  const salt = randB32();
  const key = await crypto.subtle.importKey("raw", enc2.encode(password), "PBKDF2", false, [
    "deriveBits"
  ]);
  const bits = await crypto.subtle.deriveBits(
    { name: "PBKDF2", hash: "SHA-256", salt, iterations },
    key,
    256
  );
  return {
    hash: b64(bits),
    salt: b64(salt),
    type: "pbkdf2",
    iterations
  };
}
async function verifyPassword2(password, user) {
  if (!user?.password_hash || !user?.password_salt) return false;
  const iters = Number(user.password_iterations || 1e5);
  const key = await crypto.subtle.importKey("raw", enc2.encode(password), "PBKDF2", false, [
    "deriveBits"
  ]);
  const bits = await crypto.subtle.deriveBits(
    { name: "PBKDF2", hash: "SHA-256", salt: b64toBuf(user.password_salt), iterations: iters },
    key,
    256
  );
  return timingSafeEq(b64(bits), user.password_hash);
}
function issueCsrfSecret() {
  return b64(randB32());
}
async function csrfTokenFromSecret(secretB64) {
  const data = enc2.encode("csrf:" + secretB64);
  const digest = await crypto.subtle.digest("SHA-256", data);
  return b64(digest);
}
async function assertCsrf(request, session) {
  const hdr = request.headers.get("X-CSRF-Token");
  if (!hdr) return false;
  const expected = await csrfTokenFromSecret(session.csrf_secret);
  return timingSafeEq(expected, hdr);
}
async function createSession(env, userId, ip, ua) {
  const tokenRaw = b64(randB32());
  const csrfSecret = issueCsrfSecret();
  const now = /* @__PURE__ */ new Date();
  const exp = new Date(now.getTime() + 30 * 24 * 3600 * 1e3).toISOString();
  const tokenHash = await sha256b644(tokenRaw);
  await env.DB.prepare(
    `INSERT INTO sessions (user_id, token, csrf_secret, expires_at, ip_address, user_agent)
     VALUES (?, ?, ?, ?, ?, ?)`
  ).bind(userId, tokenHash, csrfSecret, exp, ip || null, ua || null).run();
  await env.DB.prepare(
    `INSERT INTO session_tokens (token_hash, user_id, expires_at) VALUES (?, ?, ?)`
  ).bind(tokenHash, userId, exp).run();
  return { token: tokenRaw, csrfSecret };
}
async function sha256b644(s) {
  const d = await crypto.subtle.digest("SHA-256", enc2.encode(s));
  return b64(d);
}
async function readSession(env, tokenRaw) {
  if (!tokenRaw) return null;
  const tokenHash = await sha256b644(tokenRaw);
  const tok = await env.DB.prepare(
    `SELECT user_id, expires_at FROM session_tokens WHERE token_hash = ? AND expires_at > datetime('now')`
  ).bind(tokenHash).first();
  if (!tok) return null;
  const row = await env.DB.prepare(
    `SELECT s.user_id, s.csrf_secret, s.expires_at, u.role, u.social_handle, u.first_name, u.last_name, u.email, u.is_allowlisted
       FROM sessions s
       JOIN users u ON u.id = s.user_id
      WHERE s.user_id = ? AND s.expires_at > datetime('now')
      ORDER BY s.created_at DESC LIMIT 1`
  ).bind(tok.user_id).first();
  return row || null;
}
async function destroySession(env, tokenRaw) {
  if (!tokenRaw) return;
  const tokenHash = await sha256b644(tokenRaw);
  await env.DB.prepare(`DELETE FROM session_tokens WHERE token_hash = ?`).bind(tokenHash).run();
}
async function onRequest7(context) {
  const { request, env } = context;
  const { method } = request;
  const url = new URL(request.url);
  const path = url.pathname;
  const origin = request.headers.get("Origin") || "";
  const headers = secHeaders(origin, env);
  if (method === "OPTIONS") return new Response(null, { status: 204, headers });
  try {
    const sessionCookie = getCookie(request, COOKIE_NAME);
    const session = await readSession(env, sessionCookie);
    if (path === "/api/health" && method === "GET") {
      return json(
        { status: "healthy", ts: (/* @__PURE__ */ new Date()).toISOString(), service: "SBS Unity v3 API" },
        200,
        headers
      );
    }
    if (path === "/api/users/register" && method === "POST") {
      const body = await request.json();
      const allowed = [
        "social_handle",
        "email",
        "phone",
        "password",
        "first_name",
        "last_name",
        "address",
        "city",
        "eircode",
        "preferred_contact"
      ];
      for (const k of Object.keys(body)) {
        if (!allowed.includes(k)) return json({ success: false, error: `Unknown field: ${k}` }, 400, headers);
      }
      if (!body.social_handle || !body.password)
        return json({ success: false, error: "social_handle and password required" }, 400, headers);
      if (body.password.length < 6)
        return json({ success: false, error: "Password must be at least 6 characters" }, 400, headers);
      if (!/\d/.test(body.password))
        return json({ success: false, error: "Password must contain at least 1 number" }, 400, headers);
      const exists = await env.DB.prepare(
        "SELECT id FROM users WHERE social_handle = ? OR email = ?"
      ).bind(body.social_handle, body.email || null).first();
      if (exists) return json({ success: false, error: "User already exists" }, 409, headers);
      const { hash, salt, type, iterations } = await hashPassword(body.password);
      const emailVerified = body.email ? 0 : 1;
      const res = await env.DB.prepare(
        `INSERT INTO users
        (social_handle,email,phone,password_hash,password_salt,password_hash_type,password_iterations,
         first_name,last_name,address,city,eircode,preferred_contact,email_verified)
         VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)`
      ).bind(
        body.social_handle,
        body.email || null,
        body.phone || null,
        hash,
        salt,
        type,
        iterations,
        body.first_name || null,
        body.last_name || null,
        body.address || null,
        body.city || null,
        body.eircode || null,
        body.preferred_contact || null,
        emailVerified
      ).run();
      const userId = res.meta?.last_row_id ?? null;
      if (body.email && userId) {
        try {
          const { createVerificationToken: createVerificationToken2, sendVerificationEmail: sendVerificationEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
          const token = await createVerificationToken2(env.DB, userId);
          const siteUrl = env.SITE_URL || "https://thesbsofficial.com";
          await sendVerificationEmail2(body.email, token, siteUrl);
          return json(
            {
              success: true,
              message: "Account created! Check your email to verify your account.",
              user_id: userId,
              email_sent: true
            },
            201,
            headers
          );
        } catch (emailError) {
          console.error("Failed to send verification email:", emailError);
          return json(
            {
              success: true,
              message: "Account created! Email verification will be sent shortly.",
              user_id: userId,
              email_sent: false
            },
            201,
            headers
          );
        }
      }
      return json(
        { success: true, message: "Account created successfully!", user_id: userId },
        201,
        headers
      );
    }
    if (path === "/api/users/login" && method === "POST") {
      const body = await request.json();
      const { social_handle, password } = body;
      if (!social_handle || !password)
        return json({ success: false, error: "social_handle and password required" }, 400, headers);
      const user = await env.DB.prepare("SELECT * FROM users WHERE social_handle = ?").bind(social_handle).first();
      if (!user || !await verifyPassword2(password, user))
        return json({ success: false, error: "Invalid credentials" }, 401, headers);
      if (user.email && user.email_verified === 0) {
        return json({
          success: false,
          error: "Please verify your email before logging in. Check your inbox for the verification link.",
          email_verification_required: true,
          email: user.email
        }, 403, headers);
      }
      const allowHandles = (env.ADMIN_ALLOWLIST_HANDLES || "").split(",").map((s) => s.trim());
      if (user.role !== "admin" && allowHandles.includes(user.social_handle)) {
        await env.DB.prepare("UPDATE users SET role='admin' WHERE id = ?").bind(user.id).run();
        user.role = "admin";
      }
      const ip = ipOf(request);
      const ua = request.headers.get("User-Agent") || "unknown";
      const { token, csrfSecret } = await createSession(env, user.id, ip, ua);
      const csrfToken = await csrfTokenFromSecret(csrfSecret);
      return json(
        {
          success: true,
          csrf_token: csrfToken,
          user: {
            id: user.id,
            social_handle: user.social_handle,
            email: user.email,
            role: user.role,
            first_name: user.first_name,
            last_name: user.last_name
          }
        },
        200,
        { ...headers, "Set-Cookie": setCookie(token) }
      );
    }
    if (path === "/api/users/logout" && method === "POST") {
      if (sessionCookie) await destroySession(env, sessionCookie);
      return json({ success: true }, 200, { ...headers, "Set-Cookie": clearCookie() });
    }
    if (path === "/api/verify-email" && method === "POST") {
      const body = await request.json();
      const { token } = body;
      if (!token) {
        return json({ success: false, error: "Token required" }, 400, headers);
      }
      try {
        const { verifyEmailToken: verifyEmailToken2 } = await Promise.resolve().then(() => (init_email(), email_exports));
        const result = await verifyEmailToken2(env.DB, token);
        if (!result.success) {
          return json({ success: false, error: result.error }, 400, headers);
        }
        return json({
          success: true,
          message: "Email verified successfully! You can now log in.",
          user: result.user
        }, 200, headers);
      } catch (error) {
        console.error("Email verification error:", error);
        return json({ success: false, error: "Verification failed" }, 500, headers);
      }
    }
    if (path === "/api/resend-verification" && method === "POST") {
      const body = await request.json();
      const { email } = body;
      if (!email) {
        return json({ success: false, error: "Email required" }, 400, headers);
      }
      const user = await env.DB.prepare(
        "SELECT id, email, email_verified, first_name FROM users WHERE email = ?"
      ).bind(email).first();
      if (!user) {
        return json({
          success: true,
          message: "If that email exists, a verification link has been sent."
        }, 200, headers);
      }
      if (user.email_verified === 1) {
        return json({
          success: false,
          error: "Email is already verified. You can log in now!"
        }, 400, headers);
      }
      try {
        const { createVerificationToken: createVerificationToken2 } = await Promise.resolve().then(() => (init_email(), email_exports));
        const { sendBeautifulVerificationEmail: sendBeautifulVerificationEmail2 } = await Promise.resolve().then(() => (init_resend_wrapper(), resend_wrapper_exports));
        const token = await createVerificationToken2(env.DB, user.id);
        const siteUrl = env.SITE_URL || "https://thesbsofficial.com";
        await sendBeautifulVerificationEmail2(
          env.RESEND_API_KEY,
          user.email,
          user.first_name || "there",
          token,
          siteUrl
        );
        return json({
          success: true,
          message: "Verification email sent! Check your inbox."
        }, 200, headers);
      } catch (error) {
        console.error("Resend verification error:", error);
        return json({
          success: false,
          error: "Failed to send verification email"
        }, 500, headers);
      }
    }
    if (path === "/api/test-email" && method === "POST") {
      const body = await request.json();
      const { email } = body;
      if (!email) {
        return json({ success: false, error: "Email required" }, 400, headers);
      }
      try {
        const { sendVerificationEmail: sendVerificationEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
        const testToken = "test-" + Math.random().toString(36).substring(2, 15);
        const siteUrl = env.SITE_URL || "https://thesbsofficial.com";
        const result = await sendVerificationEmail2(email, testToken, siteUrl);
        return json({
          success: true,
          message: `Test verification email sent to ${email}`,
          note: "This is a test email with a dummy token",
          mailChannelsResponse: result
        }, 200, headers);
      } catch (error) {
        console.error("Test email error:", error);
        console.error("Error stack:", error.stack);
        return json({
          success: false,
          error: "Failed to send test email",
          details: error.message,
          errorType: error.name,
          stack: error.stack
        }, 500, headers);
      }
    }
    if (path === "/api/products" && method === "GET") {
      try {
        return json(
          {
            success: true,
            products: [],
            message: "Products API ready - CF Images integration pending"
          },
          200,
          headers
        );
      } catch (error) {
        console.error("Products API error:", error);
        return json(
          {
            success: true,
            products: [],
            error: "Failed to fetch products"
          },
          200,
          headers
        );
      }
    }
    if (!session) return json({ success: false, error: "Unauthorized" }, 401, headers);
    if (path === "/api/users/me" && method === "GET") {
      const csrfToken = await csrfTokenFromSecret(session.csrf_secret);
      return json(
        {
          success: true,
          user: {
            id: session.user_id,
            social_handle: session.social_handle,
            email: session.email,
            role: session.role,
            first_name: session.first_name,
            last_name: session.last_name,
            is_allowlisted: session.is_allowlisted
          },
          csrf_token: csrfToken,
          is_admin: isAdmin(session)
        },
        200,
        headers
      );
    }
    if (path.startsWith("/api/admin/")) {
      if (!isAdmin(session)) return json({ success: false, error: "Forbidden" }, 403, headers);
      if (path === "/api/admin/menu" && method === "GET") {
        const html = `
          <section class="admin-menu">
            <h2>\u{1F39B}\uFE0F SBS Unity Admin</h2>
            <ul>
              <li><a href="/admin/" target="_blank">\u{1F3E0} Overview</a></li>
              <li><a href="/admin/inventory/" target="_blank">\u{1F4E6} Inventory</a></li>
              <li><a href="/admin/requests/" target="_blank">\u{1F4CB} Requests</a></li>
              <li><a href="/admin/customers/" target="_blank">\u{1F465} Customers</a></li>
              <li><a href="/admin/data/" target="_blank">\u{1F4BE} Data</a></li>
              <li><a href="/admin/logs/" target="_blank">\uFFFD Logs & Analytics</a></li>
              <li><a href="/admin/security/" target="_blank">\u{1F512} Security</a></li>
              <li><a href="/admin/audit/" target="_blank">\u{1F4DC} Audit</a></li>
            </ul>
            <hr style="margin: 20px 0; border-color: #333;">
            <h3 style="font-size: 14px; color: #999; margin-bottom: 10px;">\u2699\uFE0F Utilities</h3>
            <ul>
              <li><a href="/admin/system-check.html" target="_blank">\u{1F50D} System Check</a></li>
              <li><a href="/admin/status.html" target="_blank">\uFFFD API Status</a></li>
              <li><a href="/admin/diagnostic.html" target="_blank">\u{1F6E0}\uFE0F Diagnostics</a></li>
              <li><button id="runBoard07" type="button">\u26A1 Quick Diagnostics</button></li>
            </ul>
          </section>`;
        return new Response(html, { status: 200, headers: { "Content-Type": "text/html", ...headers } });
      }
      if (path === "/api/admin/tests/board07" && method === "GET") {
        const tables = await env.DB.prepare(
          "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name"
        ).all();
        return json(
          {
            success: true,
            checks: [
              { name: "tables_present", passed: true, details: tables.results?.map((r) => r.name) || [] }
            ],
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          },
          200,
          headers
        );
      }
      if (path === "/api/admin/health-check" && method === "GET") {
        const checks = [];
        let totalChecks = 0;
        let passedChecks = 0;
        totalChecks++;
        try {
          const tables = await env.DB.prepare(
            "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name"
          ).all();
          const requiredTables = ["users", "sessions", "session_tokens", "orders", "products", "sell_cases"];
          const foundTables = tables.results?.map((r) => r.name) || [];
          const missingTables = requiredTables.filter((t) => !foundTables.includes(t));
          if (missingTables.length === 0) {
            passedChecks++;
            checks.push({
              name: "D1 Database",
              status: "\u2713 PASS",
              details: `All ${requiredTables.length} required tables present`,
              tables: foundTables
            });
          } else {
            checks.push({
              name: "D1 Database",
              status: "\u2717 FAIL",
              details: `Missing tables: ${missingTables.join(", ")}`,
              tables: foundTables
            });
          }
        } catch (dbError) {
          checks.push({
            name: "D1 Database",
            status: "\u2717 FAIL",
            error: dbError.message
          });
        }
        const envChecks = [
          { name: "CLOUDFLARE_ACCOUNT_ID", value: env.CLOUDFLARE_ACCOUNT_ID },
          { name: "SITE_URL", value: env.SITE_URL },
          { name: "ADMIN_ALLOWLIST_HANDLES", value: env.ADMIN_ALLOWLIST_HANDLES }
        ];
        envChecks.forEach((check) => {
          totalChecks++;
          if (check.value) {
            passedChecks++;
            checks.push({
              name: check.name,
              status: "\u2713 PASS",
              details: "Configured",
              value: check.value
            });
          } else {
            checks.push({
              name: check.name,
              status: "\u2717 FAIL",
              details: "Not configured"
            });
          }
        });
        const secretChecks = [
          { name: "CLOUDFLARE_API_TOKEN", value: env.CLOUDFLARE_API_TOKEN },
          { name: "CLOUDFLARE_IMAGES_API_TOKEN", value: env.CLOUDFLARE_IMAGES_API_TOKEN },
          { name: "CLOUDFLARE_IMAGES_HASH", value: env.CLOUDFLARE_IMAGES_HASH }
        ];
        secretChecks.forEach((check) => {
          totalChecks++;
          if (check.value) {
            passedChecks++;
            checks.push({
              name: check.name,
              status: "\u2713 PASS",
              details: "Secret configured (encrypted)"
            });
          } else {
            checks.push({
              name: check.name,
              status: "\u26A0 WARN",
              details: "Not configured (optional)"
            });
          }
        });
        const bindingChecks = [
          { name: "DB (D1)", binding: env.DB, type: "D1 Database" },
          { name: "PRODUCT_IMAGES (R2)", binding: env.PRODUCT_IMAGES, type: "R2 Bucket" },
          { name: "USER_UPLOADS (R2)", binding: env.USER_UPLOADS, type: "R2 Bucket" }
        ];
        bindingChecks.forEach((check) => {
          totalChecks++;
          if (check.binding) {
            passedChecks++;
            checks.push({
              name: check.name,
              status: "\u2713 PASS",
              details: `${check.type} bound`,
              type: check.type
            });
          } else {
            checks.push({
              name: check.name,
              status: "\u2717 FAIL",
              details: `${check.type} not bound`
            });
          }
        });
        totalChecks++;
        const hasImagesConfig = env.CLOUDFLARE_ACCOUNT_ID && (env.CLOUDFLARE_API_TOKEN || env.CLOUDFLARE_IMAGES_API_TOKEN);
        if (hasImagesConfig) {
          passedChecks++;
          checks.push({
            name: "Cloudflare Images API",
            status: "\u2713 PASS",
            details: "Account ID and API token configured",
            ready: true
          });
        } else {
          checks.push({
            name: "Cloudflare Images API",
            status: "\u2717 FAIL",
            details: "Missing account ID or API token"
          });
        }
        const successRate = (passedChecks / totalChecks * 100).toFixed(1);
        const overallStatus = passedChecks === totalChecks ? "HEALTHY" : passedChecks >= totalChecks * 0.8 ? "DEGRADED" : "UNHEALTHY";
        return json({
          success: true,
          status: overallStatus,
          summary: {
            total_checks: totalChecks,
            passed: passedChecks,
            failed: totalChecks - passedChecks,
            success_rate: `${successRate}%`
          },
          checks,
          environment: {
            production_branch: "MAIN",
            compatibility_date: "2024-09-30",
            project: "unity-v3"
          },
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        }, 200, headers);
      }
      if (path === "/api/admin/upload-image" && method === "POST") {
        try {
          const accountId = env.CLOUDFLARE_ACCOUNT_ID;
          const apiToken = env.CLOUDFLARE_API_TOKEN || env.CLOUDFLARE_IMAGES_API_TOKEN;
          if (!accountId || !apiToken) {
            return json({ success: false, error: "Missing CF Images credentials" }, 500, headers);
          }
          let formData;
          try {
            formData = await request.formData();
          } catch (parseError) {
            return json({ success: false, error: "Invalid form data format" }, 400, headers);
          }
          const file = formData.get("file");
          const filename = formData.get("filename");
          const metadata = formData.get("metadata");
          if (!file) {
            return json({ success: false, error: "File is required" }, 400, headers);
          }
          if (!file.type || !file.type.startsWith("image/")) {
            return json({ success: false, error: "File must be an image" }, 400, headers);
          }
          const cfFormData = new FormData();
          cfFormData.append("file", file);
          if (metadata) {
            const meta = JSON.parse(metadata);
            cfFormData.append("metadata", JSON.stringify(meta));
          }
          if (filename) {
            const cleanFilename = filename.replace(/\.(jpeg|jpg|png|webp)$/i, "").toLowerCase();
            cfFormData.append("id", cleanFilename);
          }
          const uploadUrl = `https://api.cloudflare.com/client/v4/accounts/${accountId}/images/v1`;
          const uploadResponse = await fetch(uploadUrl, {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${apiToken}`
            },
            body: cfFormData
          });
          const result = await uploadResponse.json();
          if (!uploadResponse.ok || !result.success) {
            console.error("CF Images upload failed:", result);
            console.error("Attempted filename:", filename);
            return json({
              success: false,
              error: result.errors?.[0]?.message || "Upload failed",
              details: result,
              attemptedFilename: filename
            }, uploadResponse.status, headers);
          }
          return json({
            success: true,
            image: result.result,
            message: "Image uploaded successfully",
            uploadedId: result.result?.id,
            requestedFilename: filename
          }, 200, headers);
        } catch (err) {
          console.error("Upload error:", err);
          return json({
            success: false,
            error: "Upload failed",
            details: err.message
          }, 500, headers);
        }
      }
      if (path === "/api/admin/update-image-metadata" && method === "PATCH") {
        try {
          const accountId = env.CLOUDFLARE_ACCOUNT_ID;
          const apiToken = env.CLOUDFLARE_API_TOKEN || env.CLOUDFLARE_IMAGES_API_TOKEN;
          if (!accountId || !apiToken) {
            return json({ success: false, error: "Missing CF Images credentials" }, 500, headers);
          }
          const body = await request.json();
          const imageId = body.imageId || body.id;
          const metadata = body.metadata;
          if (!imageId) {
            return json({ success: false, error: "Image ID required" }, 400, headers);
          }
          if (!metadata) {
            return json({ success: false, error: "Metadata required" }, 400, headers);
          }
          const updateUrl = `https://api.cloudflare.com/client/v4/accounts/${accountId}/images/v1/${imageId}`;
          const updateResponse = await fetch(updateUrl, {
            method: "PATCH",
            headers: {
              "Authorization": `Bearer ${apiToken}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({ metadata })
          });
          const result = await updateResponse.json();
          if (!updateResponse.ok || !result.success) {
            console.error("CF Images metadata update failed:", result);
            return json({
              success: false,
              error: result.errors?.[0]?.message || "Metadata update failed",
              details: result
            }, updateResponse.status, headers);
          }
          return json({
            success: true,
            message: "Metadata updated successfully",
            imageId,
            metadata
          }, 200, headers);
        } catch (err) {
          console.error("Update metadata error:", err);
          return json({
            success: false,
            error: "Metadata update failed",
            details: err.message
          }, 500, headers);
        }
      }
      if (path === "/api/admin/delete-image" && (method === "DELETE" || method === "POST")) {
        try {
          const accountId = env.CLOUDFLARE_ACCOUNT_ID;
          const apiToken = env.CLOUDFLARE_API_TOKEN || env.CLOUDFLARE_IMAGES_API_TOKEN;
          if (!accountId || !apiToken) {
            return json({ success: false, error: "Missing CF Images credentials" }, 500, headers);
          }
          let body;
          try {
            body = await request.json();
          } catch (parseError) {
            return json({ success: false, error: "Invalid JSON format" }, 400, headers);
          }
          const imageId = body.imageId || body.id;
          if (!imageId) {
            return json({ success: false, error: "imageId is required" }, 400, headers);
          }
          if (typeof imageId !== "string" || imageId.trim().length === 0) {
            return json({ success: false, error: "imageId must be a non-empty string" }, 400, headers);
          }
          const deleteUrl = `https://api.cloudflare.com/client/v4/accounts/${accountId}/images/v1/${imageId}`;
          const deleteResponse = await fetch(deleteUrl, {
            method: "DELETE",
            headers: {
              "Authorization": `Bearer ${apiToken}`
            }
          });
          const result = await deleteResponse.json();
          if (!deleteResponse.ok || !result.success) {
            console.error("CF Images delete failed:", result);
            return json({
              success: false,
              error: result.errors?.[0]?.message || "Delete failed",
              details: result
            }, deleteResponse.status, headers);
          }
          return json({
            success: true,
            message: "Image deleted successfully",
            imageId
          }, 200, headers);
        } catch (err) {
          console.error("Delete error:", err);
          return json({
            success: false,
            error: "Delete failed",
            details: err.message
          }, 500, headers);
        }
      }
    }
    if (path === "/api/orders" && method === "POST") {
      const ok = await assertCsrf(request, session);
      if (!ok) return json({ success: false, error: "Invalid CSRF token" }, 403, headers);
      const body = await request.json();
      if (!Array.isArray(body.items) || !body.items.length)
        return json({ success: false, error: "Items required" }, 400, headers);
      const orderNo = `SBS-${crypto.randomUUID().slice(0, 8).toUpperCase()}`;
      const res = await env.DB.prepare(
        `INSERT INTO orders (user_id, order_number, items_json, total_amount, delivery_address, delivery_city, delivery_method, status, created_at)
         VALUES (?,?,?,?,?,?,?,'pending',CURRENT_TIMESTAMP)`
      ).bind(
        session.user_id,
        orderNo,
        JSON.stringify(body.items),
        body.total_amount || 0,
        body.delivery_address || null,
        body.delivery_city || null,
        body.delivery_method || "delivery"
      ).run();
      const user = await env.DB.prepare(
        `SELECT email, first_name, last_name FROM users WHERE id=?`
      ).bind(session.user_id).first();
      const newOrder = {
        id: res.meta?.last_row_id ?? null,
        order_number: orderNo,
        status: "pending",
        total_amount: body.total_amount || 0,
        user_email: user?.email,
        user_name: user ? `${user.first_name || ""} ${user.last_name || ""}`.trim() : null
      };
      try {
        const notificationService = new notification_service_default(env);
        const notificationResult = await notificationService.sendOrderConfirmation(newOrder, body.items);
        if (notificationResult.success) {
          console.log(`\u2705 Order confirmation sent for ${orderNo}`);
        } else {
          console.warn(`\u26A0\uFE0F  Order confirmation failed for ${orderNo}: ${notificationResult.reason}`);
        }
      } catch (notificationError) {
        console.error("\u274C Order confirmation error:", notificationError);
      }
      return json(
        { success: true, order: newOrder },
        201,
        headers
      );
    }
    if (path === "/api/orders" && method === "GET") {
      const rows = await env.DB.prepare(
        `SELECT id, order_number, total_amount, status, created_at FROM orders WHERE user_id=? ORDER BY created_at DESC`
      ).bind(session.user_id).all();
      return json({ success: true, orders: rows.results || [] }, 200, headers);
    }
    if (path === "/api/users/me" && method === "GET") {
      const user = await env.DB.prepare(
        `SELECT id, social_handle, email, phone, first_name, last_name, address, city, eircode,
         preferred_contact, role, created_at FROM users WHERE id=?`
      ).bind(session.user_id).first();
      if (!user) return json({ success: false, error: "User not found" }, 404, headers);
      return json({ success: true, user }, 200, headers);
    }
    if (path === "/api/users/me/orders" && method === "GET") {
      const orders = await env.DB.prepare(
        `SELECT id, order_number, items_json, total_amount, delivery_address, delivery_city,
         delivery_method, status, created_at FROM orders WHERE user_id=? ORDER BY created_at DESC`
      ).bind(session.user_id).all();
      return json({ success: true, orders: orders.results || [] }, 200, headers);
    }
    if (path === "/api/verify-email" && method === "POST") {
      const body = await request.json();
      const { token } = body;
      if (!token) {
        return json({ success: false, error: "Token required" }, 400, headers);
      }
      try {
        const { verifyEmailToken: verifyEmailToken2 } = await Promise.resolve().then(() => (init_email(), email_exports));
        const result = await verifyEmailToken2(env.DB, token);
        if (result.success) {
          return json({
            success: true,
            message: "Email verified successfully! You can now login.",
            user: result.user
          }, 200, headers);
        } else {
          return json({
            success: false,
            error: result.error || "Verification failed"
          }, 400, headers);
        }
      } catch (error) {
        console.error("Verification error:", error);
        return json({
          success: false,
          error: "Verification failed"
        }, 500, headers);
      }
    }
    if (path === "/api/resend-verification" && method === "POST") {
      const body = await request.json();
      const { email } = body;
      if (!email) {
        return json({ success: false, error: "Email required" }, 400, headers);
      }
      const user = await env.DB.prepare(
        `SELECT id, email, email_verified_at FROM users WHERE email = ?`
      ).bind(email).first();
      if (!user) {
        return json({ success: true, message: "If that email is registered, a verification link has been sent." }, 200, headers);
      }
      if (user.email_verified_at) {
        return json({ success: false, error: "Email already verified" }, 400, headers);
      }
      try {
        const { createVerificationToken: createVerificationToken2, sendVerificationEmail: sendVerificationEmail2 } = await Promise.resolve().then(() => (init_email(), email_exports));
        const token = await createVerificationToken2(env.DB, user.id);
        const siteUrl = env.SITE_URL || "https://thesbsofficial.com";
        await sendVerificationEmail2(email, token, siteUrl);
        return json({
          success: true,
          message: "Verification email sent! Check your inbox."
        }, 200, headers);
      } catch (error) {
        console.error("Resend email error:", error);
        return json({
          success: false,
          error: "Failed to send email"
        }, 500, headers);
      }
    }
    if (path === "/api/users/me/sell-cases" && method === "GET") {
      const cases = await env.DB.prepare(
        `SELECT case_id, brand, category, size, color, condition_rating, price,
         offer_amount, status, created_at FROM sell_cases WHERE user_id=? ORDER BY created_at DESC`
      ).bind(session.user_id).all();
      return json({ success: true, cases: cases.results || [] }, 200, headers);
    }
    if (path === "/api/users/update-profile" && method === "PUT") {
      const ok = await assertCsrf(request, session);
      if (!ok) return json({ success: false, error: "Invalid CSRF token" }, 403, headers);
      const body = await request.json();
      const allowed = [
        "first_name",
        "last_name",
        "social_handle",
        "email",
        "phone",
        "address",
        "city",
        "eircode",
        "instagram",
        "snapchat",
        "preferred_contact",
        "current_password",
        "new_password"
      ];
      for (const k of Object.keys(body)) {
        if (!allowed.includes(k)) {
          return json({ success: false, error: `Unknown field: ${k}` }, 400, headers);
        }
      }
      if (body.new_password) {
        if (!body.current_password) {
          return json({ success: false, error: "Current password required" }, 400, headers);
        }
        const user = await env.DB.prepare("SELECT * FROM users WHERE id = ?").bind(session.user_id).first();
        if (!user || !await verifyPassword2(body.current_password, user)) {
          return json({ success: false, error: "Current password incorrect" }, 401, headers);
        }
        const { hash, salt, type, iterations } = await hashPassword(body.new_password);
        await env.DB.prepare(
          `UPDATE users SET password_hash = ?, password_salt = ?, password_hash_type = ?,
           password_iterations = ? WHERE id = ?`
        ).bind(hash, salt, type, iterations, session.user_id).run();
      }
      const updates = [];
      const values = [];
      if (body.first_name !== void 0) {
        updates.push("first_name = ?");
        values.push(body.first_name);
      }
      if (body.last_name !== void 0) {
        updates.push("last_name = ?");
        values.push(body.last_name);
      }
      if (body.social_handle !== void 0) {
        updates.push("social_handle = ?");
        values.push(body.social_handle);
      }
      if (body.email !== void 0) {
        updates.push("email = ?");
        values.push(body.email);
      }
      if (body.phone !== void 0) {
        updates.push("phone = ?");
        values.push(body.phone);
      }
      if (body.address !== void 0) {
        updates.push("address = ?");
        values.push(body.address);
      }
      if (body.city !== void 0) {
        updates.push("city = ?");
        values.push(body.city);
      }
      if (body.eircode !== void 0) {
        updates.push("eircode = ?");
        values.push(body.eircode);
      }
      if (body.instagram !== void 0) {
        updates.push("instagram = ?");
        values.push(body.instagram);
      }
      if (body.snapchat !== void 0) {
        updates.push("snapchat = ?");
        values.push(body.snapchat);
      }
      if (body.preferred_contact !== void 0) {
        updates.push("preferred_contact = ?");
        values.push(body.preferred_contact);
      }
      if (updates.length > 0) {
        updates.push("updated_at = CURRENT_TIMESTAMP");
        values.push(session.user_id);
        await env.DB.prepare(
          `UPDATE users SET ${updates.join(", ")} WHERE id = ?`
        ).bind(...values).run();
      }
      const updatedUser = await env.DB.prepare(
        `SELECT id, social_handle, email, phone, first_name, last_name, address, city,
         eircode, instagram, snapchat, preferred_contact, role FROM users WHERE id = ?`
      ).bind(session.user_id).first();
      return json({
        success: true,
        message: "Profile updated successfully",
        user: updatedUser
      }, 200, headers);
    }
    if (path === "/api/users/delete" && method === "DELETE") {
      const ok = await assertCsrf(request, session);
      if (!ok) return json({ success: false, error: "Invalid CSRF token" }, 403, headers);
      try {
        await env.DB.prepare(
          `UPDATE users SET
           is_active = 0,
           email = NULL,
           phone = NULL,
           address = NULL,
           city = NULL,
           eircode = NULL,
           social_handle = CONCAT('deleted_', id, '_', social_handle),
           updated_at = CURRENT_TIMESTAMP
           WHERE id = ?`
        ).bind(session.user_id).run();
        await env.DB.prepare("DELETE FROM sessions WHERE user_id = ?").bind(session.user_id).run();
        return json(
          {
            success: true,
            message: "Account deleted. Your purchase and sell history has been anonymized."
          },
          200,
          { ...headers, "Set-Cookie": clearCookie() }
        );
      } catch (err) {
        console.error("Delete user error:", err);
        return json({ success: false, error: "Failed to delete account" }, 500, headers);
      }
    }
    if (path === "/api/admin/login" && method === "POST") {
      const body = await request.json();
      const { email, password } = body;
      if (!email || !password) {
        return json({ success: false, error: "Email and password required" }, 400, headers);
      }
      const user = await env.DB.prepare(`
        SELECT id, email, password_hash, password_salt, password_hash_type,
               password_iterations, role, is_allowlisted, first_name, last_name
        FROM users
        WHERE email = ? AND role = 'admin'
      `).bind(email).first();
      if (!user || !await verifyPassword2(password, user)) {
        return json({ success: false, error: "Invalid credentials" }, 401, headers);
      }
      if (!user.is_allowlisted) {
        return json({ success: false, error: "Access denied" }, 403, headers);
      }
      const ip = ipOf(request);
      const ua = request.headers.get("User-Agent") || "unknown";
      const { token, csrfSecret } = await createSession(env, user.id, ip, ua);
      try {
        const { logAdminAction: logAdminAction2 } = await Promise.resolve().then(() => (init_admin(), admin_exports));
        const mockSession = { user_id: user.id, role: "admin", is_allowlisted: 1 };
        await logAdminAction2(env, mockSession, "admin_login", null, {
          email: user.email,
          ip_address: ip
        });
      } catch (e) {
        console.warn("Admin logging failed:", e);
      }
      return json({
        success: true,
        token,
        csrf_token: await csrfTokenFromSecret(csrfSecret),
        user: {
          id: user.id,
          email: user.email,
          role: user.role,
          name: `${user.first_name || ""} ${user.last_name || ""}`.trim() || "Admin"
        }
      }, 200, headers);
    }
    if (path === "/api/admin/logout" && method === "POST") {
      const authHeader = request.headers.get("Authorization");
      if (authHeader && authHeader.startsWith("Bearer ")) {
        const token = authHeader.substring(7);
        await destroySession(env, token);
      }
      return json({ success: true }, 200, headers);
    }
    if (path === "/api/admin/verify" && method === "GET") {
      const authHeader = request.headers.get("Authorization");
      if (!authHeader || !authHeader.startsWith("Bearer ")) {
        return json({ success: false, error: "No token provided" }, 401, headers);
      }
      const token = authHeader.substring(7);
      const adminSession = await readSession(env, token);
      if (!adminSession || !isAdmin(adminSession)) {
        return json({ success: false, error: "Invalid admin session" }, 401, headers);
      }
      return json({
        success: true,
        user: {
          id: adminSession.user_id,
          email: adminSession.email,
          role: adminSession.role,
          name: `${adminSession.first_name || ""} ${adminSession.last_name || ""}`.trim() || "Admin"
        },
        csrf_token: await csrfTokenFromSecret(adminSession.csrf_secret)
      }, 200, headers);
    }
    return json({ success: false, error: "Endpoint not found" }, 404, headers);
  } catch (err) {
    console.error("API error:", err);
    console.error("Error stack:", err.stack);
    console.error("Error message:", err.message);
    return json({ success: false, error: "Internal server error", details: err.message }, 500, secHeaders("", env));
  }
}
var enc2, json, b64, b64toBuf, randB32, timingSafeEq, COOKIE_NAME, cookieAttrs, setCookie, clearCookie, isAdmin, ipOf;
var init_path = __esm({
  "api/[[path]].js"() {
    init_functionsRoutes_0_9937148203508366();
    init_notification_service();
    enc2 = new TextEncoder();
    json = /* @__PURE__ */ __name((data, status = 200, headers = {}) => new Response(JSON.stringify(data), {
      status,
      headers: { "Content-Type": "application/json", ...headers }
    }), "json");
    b64 = /* @__PURE__ */ __name((buf) => btoa(String.fromCharCode(...new Uint8Array(buf))), "b64");
    b64toBuf = /* @__PURE__ */ __name((s) => Uint8Array.from(atob(s), (c) => c.charCodeAt(0)), "b64toBuf");
    randB32 = /* @__PURE__ */ __name(() => crypto.getRandomValues(new Uint8Array(32)), "randB32");
    timingSafeEq = /* @__PURE__ */ __name((a, b) => {
      if (a.length !== b.length) return false;
      let diff = 0;
      for (let i = 0; i < a.length; i++) diff |= a.charCodeAt(i) ^ b.charCodeAt(i);
      return diff === 0;
    }, "timingSafeEq");
    __name(secHeaders, "secHeaders");
    COOKIE_NAME = "sbs_session";
    cookieAttrs = "; HttpOnly; Secure; SameSite=Lax; Path=/; Max-Age=2592000";
    setCookie = /* @__PURE__ */ __name((token) => `${COOKIE_NAME}=${token}${cookieAttrs}`, "setCookie");
    clearCookie = /* @__PURE__ */ __name(() => `${COOKIE_NAME}=; Path=/; Max-Age=0; HttpOnly; Secure; SameSite=Lax`, "clearCookie");
    __name(getCookie, "getCookie");
    __name(hashPassword, "hashPassword");
    __name(verifyPassword2, "verifyPassword");
    __name(issueCsrfSecret, "issueCsrfSecret");
    __name(csrfTokenFromSecret, "csrfTokenFromSecret");
    __name(assertCsrf, "assertCsrf");
    __name(createSession, "createSession");
    __name(sha256b644, "sha256b64");
    __name(readSession, "readSession");
    __name(destroySession, "destroySession");
    isAdmin = /* @__PURE__ */ __name((session) => session?.role === "admin" && session?.is_allowlisted === 1, "isAdmin");
    ipOf = /* @__PURE__ */ __name((req) => req.headers.get("CF-Connecting-IP") || (req.headers.get("X-Forwarded-For") || "").split(",")[0] || "unknown", "ipOf");
    __name(onRequest7, "onRequest");
  }
});

// ../.wrangler/tmp/pages-SqvGc9/functionsRoutes-0.9937148203508366.mjs
var routes;
var init_functionsRoutes_0_9937148203508366 = __esm({
  "../.wrangler/tmp/pages-SqvGc9/functionsRoutes-0.9937148203508366.mjs"() {
    init_activity();
    init_activity();
    init_analytics();
    init_auth();
    init_auth();
    init_auth();
    init_delete_image();
    init_orders();
    init_orders();
    init_orders();
    init_orders();
    init_products();
    init_products();
    init_products();
    init_products();
    init_products();
    init_update_image_metadata();
    init_upload_image();
    init_sync();
    init_track();
    init_submit();
    init_upload_photos();
    init_create();
    init_reservations();
    init_sell_requests();
    init_sell_submissions();
    init_sell_submissions();
    init_analytics_v2();
    init_eircode_proxy();
    init_products2();
    init_products_smart();
    init_path();
    routes = [
      {
        routePath: "/api/admin/activity",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet]
      },
      {
        routePath: "/api/admin/activity",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions]
      },
      {
        routePath: "/api/admin/analytics",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet2]
      },
      {
        routePath: "/api/admin/auth",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet3]
      },
      {
        routePath: "/api/admin/auth",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions2]
      },
      {
        routePath: "/api/admin/auth",
        mountPath: "/api/admin",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost]
      },
      {
        routePath: "/api/admin/delete-image",
        mountPath: "/api/admin",
        method: "DELETE",
        middlewares: [],
        modules: [onRequestDelete]
      },
      {
        routePath: "/api/admin/orders",
        mountPath: "/api/admin",
        method: "DELETE",
        middlewares: [],
        modules: [onRequestDelete2]
      },
      {
        routePath: "/api/admin/orders",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet4]
      },
      {
        routePath: "/api/admin/orders",
        mountPath: "/api/admin",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost2]
      },
      {
        routePath: "/api/admin/orders",
        mountPath: "/api/admin",
        method: "PUT",
        middlewares: [],
        modules: [onRequestPut]
      },
      {
        routePath: "/api/admin/products",
        mountPath: "/api/admin",
        method: "DELETE",
        middlewares: [],
        modules: [onRequestDelete3]
      },
      {
        routePath: "/api/admin/products",
        mountPath: "/api/admin",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet5]
      },
      {
        routePath: "/api/admin/products",
        mountPath: "/api/admin",
        method: "OPTIONS",
        middlewares: [],
        modules: [onRequestOptions3]
      },
      {
        routePath: "/api/admin/products",
        mountPath: "/api/admin",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost3]
      },
      {
        routePath: "/api/admin/products",
        mountPath: "/api/admin",
        method: "PUT",
        middlewares: [],
        modules: [onRequestPut2]
      },
      {
        routePath: "/api/admin/update-image-metadata",
        mountPath: "/api/admin",
        method: "PATCH",
        middlewares: [],
        modules: [onRequestPatch]
      },
      {
        routePath: "/api/admin/upload-image",
        mountPath: "/api/admin",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost4]
      },
      {
        routePath: "/api/analytics/sync",
        mountPath: "/api/analytics",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost5]
      },
      {
        routePath: "/api/analytics/track",
        mountPath: "/api/analytics",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost6]
      },
      {
        routePath: "/api/cases/submit",
        mountPath: "/api/cases",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost7]
      },
      {
        routePath: "/api/cases/upload-photos",
        mountPath: "/api/cases",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost8]
      },
      {
        routePath: "/api/reservations/create",
        mountPath: "/api/reservations",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost9]
      },
      {
        routePath: "/api/admin/reservations",
        mountPath: "/api/admin",
        method: "",
        middlewares: [],
        modules: [onRequest]
      },
      {
        routePath: "/api/admin/sell-requests",
        mountPath: "/api/admin",
        method: "",
        middlewares: [],
        modules: [onRequest2]
      },
      {
        routePath: "/api/sell-submissions",
        mountPath: "/api",
        method: "GET",
        middlewares: [],
        modules: [onRequestGet6]
      },
      {
        routePath: "/api/sell-submissions",
        mountPath: "/api",
        method: "POST",
        middlewares: [],
        modules: [onRequestPost10]
      },
      {
        routePath: "/api/analytics-v2",
        mountPath: "/api",
        method: "",
        middlewares: [],
        modules: [onRequest3]
      },
      {
        routePath: "/api/eircode-proxy",
        mountPath: "/api",
        method: "",
        middlewares: [],
        modules: [onRequest4]
      },
      {
        routePath: "/api/products",
        mountPath: "/api",
        method: "",
        middlewares: [],
        modules: [onRequest5]
      },
      {
        routePath: "/api/products-smart",
        mountPath: "/api",
        method: "",
        middlewares: [],
        modules: [onRequest6]
      },
      {
        routePath: "/api/:path*",
        mountPath: "/api",
        method: "",
        middlewares: [],
        modules: [onRequest7]
      }
    ];
  }
});

// ../node_modules/wrangler/templates/pages-template-worker.ts
init_functionsRoutes_0_9937148203508366();

// ../node_modules/path-to-regexp/dist.es2015/index.js
init_functionsRoutes_0_9937148203508366();
function lexer(str) {
  var tokens = [];
  var i = 0;
  while (i < str.length) {
    var char = str[i];
    if (char === "*" || char === "+" || char === "?") {
      tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
      continue;
    }
    if (char === "\\") {
      tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
      continue;
    }
    if (char === "{") {
      tokens.push({ type: "OPEN", index: i, value: str[i++] });
      continue;
    }
    if (char === "}") {
      tokens.push({ type: "CLOSE", index: i, value: str[i++] });
      continue;
    }
    if (char === ":") {
      var name = "";
      var j = i + 1;
      while (j < str.length) {
        var code = str.charCodeAt(j);
        if (
          // `0-9`
          code >= 48 && code <= 57 || // `A-Z`
          code >= 65 && code <= 90 || // `a-z`
          code >= 97 && code <= 122 || // `_`
          code === 95
        ) {
          name += str[j++];
          continue;
        }
        break;
      }
      if (!name)
        throw new TypeError("Missing parameter name at ".concat(i));
      tokens.push({ type: "NAME", index: i, value: name });
      i = j;
      continue;
    }
    if (char === "(") {
      var count = 1;
      var pattern = "";
      var j = i + 1;
      if (str[j] === "?") {
        throw new TypeError('Pattern cannot start with "?" at '.concat(j));
      }
      while (j < str.length) {
        if (str[j] === "\\") {
          pattern += str[j++] + str[j++];
          continue;
        }
        if (str[j] === ")") {
          count--;
          if (count === 0) {
            j++;
            break;
          }
        } else if (str[j] === "(") {
          count++;
          if (str[j + 1] !== "?") {
            throw new TypeError("Capturing groups are not allowed at ".concat(j));
          }
        }
        pattern += str[j++];
      }
      if (count)
        throw new TypeError("Unbalanced pattern at ".concat(i));
      if (!pattern)
        throw new TypeError("Missing pattern at ".concat(i));
      tokens.push({ type: "PATTERN", index: i, value: pattern });
      i = j;
      continue;
    }
    tokens.push({ type: "CHAR", index: i, value: str[i++] });
  }
  tokens.push({ type: "END", index: i, value: "" });
  return tokens;
}
__name(lexer, "lexer");
function parse(str, options) {
  if (options === void 0) {
    options = {};
  }
  var tokens = lexer(str);
  var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a, _b = options.delimiter, delimiter = _b === void 0 ? "/#?" : _b;
  var result = [];
  var key = 0;
  var i = 0;
  var path = "";
  var tryConsume = /* @__PURE__ */ __name(function(type) {
    if (i < tokens.length && tokens[i].type === type)
      return tokens[i++].value;
  }, "tryConsume");
  var mustConsume = /* @__PURE__ */ __name(function(type) {
    var value2 = tryConsume(type);
    if (value2 !== void 0)
      return value2;
    var _a2 = tokens[i], nextType = _a2.type, index = _a2.index;
    throw new TypeError("Unexpected ".concat(nextType, " at ").concat(index, ", expected ").concat(type));
  }, "mustConsume");
  var consumeText = /* @__PURE__ */ __name(function() {
    var result2 = "";
    var value2;
    while (value2 = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")) {
      result2 += value2;
    }
    return result2;
  }, "consumeText");
  var isSafe = /* @__PURE__ */ __name(function(value2) {
    for (var _i = 0, delimiter_1 = delimiter; _i < delimiter_1.length; _i++) {
      var char2 = delimiter_1[_i];
      if (value2.indexOf(char2) > -1)
        return true;
    }
    return false;
  }, "isSafe");
  var safePattern = /* @__PURE__ */ __name(function(prefix2) {
    var prev = result[result.length - 1];
    var prevText = prefix2 || (prev && typeof prev === "string" ? prev : "");
    if (prev && !prevText) {
      throw new TypeError('Must have text between two parameters, missing text after "'.concat(prev.name, '"'));
    }
    if (!prevText || isSafe(prevText))
      return "[^".concat(escapeString(delimiter), "]+?");
    return "(?:(?!".concat(escapeString(prevText), ")[^").concat(escapeString(delimiter), "])+?");
  }, "safePattern");
  while (i < tokens.length) {
    var char = tryConsume("CHAR");
    var name = tryConsume("NAME");
    var pattern = tryConsume("PATTERN");
    if (name || pattern) {
      var prefix = char || "";
      if (prefixes.indexOf(prefix) === -1) {
        path += prefix;
        prefix = "";
      }
      if (path) {
        result.push(path);
        path = "";
      }
      result.push({
        name: name || key++,
        prefix,
        suffix: "",
        pattern: pattern || safePattern(prefix),
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    var value = char || tryConsume("ESCAPED_CHAR");
    if (value) {
      path += value;
      continue;
    }
    if (path) {
      result.push(path);
      path = "";
    }
    var open = tryConsume("OPEN");
    if (open) {
      var prefix = consumeText();
      var name_1 = tryConsume("NAME") || "";
      var pattern_1 = tryConsume("PATTERN") || "";
      var suffix = consumeText();
      mustConsume("CLOSE");
      result.push({
        name: name_1 || (pattern_1 ? key++ : ""),
        pattern: name_1 && !pattern_1 ? safePattern(prefix) : pattern_1,
        prefix,
        suffix,
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    mustConsume("END");
  }
  return result;
}
__name(parse, "parse");
function match(str, options) {
  var keys = [];
  var re = pathToRegexp(str, keys, options);
  return regexpToFunction(re, keys, options);
}
__name(match, "match");
function regexpToFunction(re, keys, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.decode, decode = _a === void 0 ? function(x) {
    return x;
  } : _a;
  return function(pathname) {
    var m = re.exec(pathname);
    if (!m)
      return false;
    var path = m[0], index = m.index;
    var params = /* @__PURE__ */ Object.create(null);
    var _loop_1 = /* @__PURE__ */ __name(function(i2) {
      if (m[i2] === void 0)
        return "continue";
      var key = keys[i2 - 1];
      if (key.modifier === "*" || key.modifier === "+") {
        params[key.name] = m[i2].split(key.prefix + key.suffix).map(function(value) {
          return decode(value, key);
        });
      } else {
        params[key.name] = decode(m[i2], key);
      }
    }, "_loop_1");
    for (var i = 1; i < m.length; i++) {
      _loop_1(i);
    }
    return { path, index, params };
  };
}
__name(regexpToFunction, "regexpToFunction");
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
__name(escapeString, "escapeString");
function flags(options) {
  return options && options.sensitive ? "" : "i";
}
__name(flags, "flags");
function regexpToRegexp(path, keys) {
  if (!keys)
    return path;
  var groupsRegex = /\((?:\?<(.*?)>)?(?!\?)/g;
  var index = 0;
  var execResult = groupsRegex.exec(path.source);
  while (execResult) {
    keys.push({
      // Use parenthesized substring match if available, index otherwise
      name: execResult[1] || index++,
      prefix: "",
      suffix: "",
      modifier: "",
      pattern: ""
    });
    execResult = groupsRegex.exec(path.source);
  }
  return path;
}
__name(regexpToRegexp, "regexpToRegexp");
function arrayToRegexp(paths, keys, options) {
  var parts = paths.map(function(path) {
    return pathToRegexp(path, keys, options).source;
  });
  return new RegExp("(?:".concat(parts.join("|"), ")"), flags(options));
}
__name(arrayToRegexp, "arrayToRegexp");
function stringToRegexp(path, keys, options) {
  return tokensToRegexp(parse(path, options), keys, options);
}
__name(stringToRegexp, "stringToRegexp");
function tokensToRegexp(tokens, keys, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function(x) {
    return x;
  } : _d, _e = options.delimiter, delimiter = _e === void 0 ? "/#?" : _e, _f = options.endsWith, endsWith = _f === void 0 ? "" : _f;
  var endsWithRe = "[".concat(escapeString(endsWith), "]|$");
  var delimiterRe = "[".concat(escapeString(delimiter), "]");
  var route = start ? "^" : "";
  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
    var token = tokens_1[_i];
    if (typeof token === "string") {
      route += escapeString(encode(token));
    } else {
      var prefix = escapeString(encode(token.prefix));
      var suffix = escapeString(encode(token.suffix));
      if (token.pattern) {
        if (keys)
          keys.push(token);
        if (prefix || suffix) {
          if (token.modifier === "+" || token.modifier === "*") {
            var mod = token.modifier === "*" ? "?" : "";
            route += "(?:".concat(prefix, "((?:").concat(token.pattern, ")(?:").concat(suffix).concat(prefix, "(?:").concat(token.pattern, "))*)").concat(suffix, ")").concat(mod);
          } else {
            route += "(?:".concat(prefix, "(").concat(token.pattern, ")").concat(suffix, ")").concat(token.modifier);
          }
        } else {
          if (token.modifier === "+" || token.modifier === "*") {
            throw new TypeError('Can not repeat "'.concat(token.name, '" without a prefix and suffix'));
          }
          route += "(".concat(token.pattern, ")").concat(token.modifier);
        }
      } else {
        route += "(?:".concat(prefix).concat(suffix, ")").concat(token.modifier);
      }
    }
  }
  if (end) {
    if (!strict)
      route += "".concat(delimiterRe, "?");
    route += !options.endsWith ? "$" : "(?=".concat(endsWithRe, ")");
  } else {
    var endToken = tokens[tokens.length - 1];
    var isEndDelimited = typeof endToken === "string" ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1 : endToken === void 0;
    if (!strict) {
      route += "(?:".concat(delimiterRe, "(?=").concat(endsWithRe, "))?");
    }
    if (!isEndDelimited) {
      route += "(?=".concat(delimiterRe, "|").concat(endsWithRe, ")");
    }
  }
  return new RegExp(route, flags(options));
}
__name(tokensToRegexp, "tokensToRegexp");
function pathToRegexp(path, keys, options) {
  if (path instanceof RegExp)
    return regexpToRegexp(path, keys);
  if (Array.isArray(path))
    return arrayToRegexp(path, keys, options);
  return stringToRegexp(path, keys, options);
}
__name(pathToRegexp, "pathToRegexp");

// ../node_modules/wrangler/templates/pages-template-worker.ts
var escapeRegex = /[.+?^${}()|[\]\\]/g;
function* executeRequest(request) {
  const requestPath = new URL(request.url).pathname;
  for (const route of [...routes].reverse()) {
    if (route.method && route.method !== request.method) {
      continue;
    }
    const routeMatcher = match(route.routePath.replace(escapeRegex, "\\$&"), {
      end: false
    });
    const mountMatcher = match(route.mountPath.replace(escapeRegex, "\\$&"), {
      end: false
    });
    const matchResult = routeMatcher(requestPath);
    const mountMatchResult = mountMatcher(requestPath);
    if (matchResult && mountMatchResult) {
      for (const handler of route.middlewares.flat()) {
        yield {
          handler,
          params: matchResult.params,
          path: mountMatchResult.path
        };
      }
    }
  }
  for (const route of routes) {
    if (route.method && route.method !== request.method) {
      continue;
    }
    const routeMatcher = match(route.routePath.replace(escapeRegex, "\\$&"), {
      end: true
    });
    const mountMatcher = match(route.mountPath.replace(escapeRegex, "\\$&"), {
      end: false
    });
    const matchResult = routeMatcher(requestPath);
    const mountMatchResult = mountMatcher(requestPath);
    if (matchResult && mountMatchResult && route.modules.length) {
      for (const handler of route.modules.flat()) {
        yield {
          handler,
          params: matchResult.params,
          path: matchResult.path
        };
      }
      break;
    }
  }
}
__name(executeRequest, "executeRequest");
var pages_template_worker_default = {
  async fetch(originalRequest, env, workerContext) {
    let request = originalRequest;
    const handlerIterator = executeRequest(request);
    let data = {};
    let isFailOpen = false;
    const next = /* @__PURE__ */ __name(async (input, init) => {
      if (input !== void 0) {
        let url = input;
        if (typeof input === "string") {
          url = new URL(input, request.url).toString();
        }
        request = new Request(url, init);
      }
      const result = handlerIterator.next();
      if (result.done === false) {
        const { handler, params, path } = result.value;
        const context = {
          request: new Request(request.clone()),
          functionPath: path,
          next,
          params,
          get data() {
            return data;
          },
          set data(value) {
            if (typeof value !== "object" || value === null) {
              throw new Error("context.data must be an object");
            }
            data = value;
          },
          env,
          waitUntil: workerContext.waitUntil.bind(workerContext),
          passThroughOnException: /* @__PURE__ */ __name(() => {
            isFailOpen = true;
          }, "passThroughOnException")
        };
        const response = await handler(context);
        if (!(response instanceof Response)) {
          throw new Error("Your Pages function should return a Response");
        }
        return cloneResponse(response);
      } else if ("ASSETS") {
        const response = await env["ASSETS"].fetch(request);
        return cloneResponse(response);
      } else {
        const response = await fetch(request);
        return cloneResponse(response);
      }
    }, "next");
    try {
      return await next();
    } catch (error) {
      if (isFailOpen) {
        const response = await env["ASSETS"].fetch(request);
        return cloneResponse(response);
      }
      throw error;
    }
  }
};
var cloneResponse = /* @__PURE__ */ __name((response) => (
  // https://fetch.spec.whatwg.org/#null-body-status
  new Response(
    [101, 204, 205, 304].includes(response.status) ? null : response.body,
    response
  )
), "cloneResponse");
export {
  pages_template_worker_default as default
};

------formdata-undici-028884142580--
